{"initialLink":"http://darobin.github.io/api-design-privacy/api-design-privacy.html","sanitizedLink":"http://darobin.github.io/api-design-privacy/api-design-privacy.html","finalLink":"http://darobin.github.io/api-design-privacy/api-design-privacy.html","htmlEmbed":"<script>window.contexterSetup=window.contexterSetup||function(){window.contexterSetupComplete=!0;class ContexterLink extends HTMLAnchorElement{constructor(){super()}connectedCallback(){this.setAttribute(\"target\",\"_blank\")}}customElements.define(\"contexter-link\",ContexterLink,{extends:\"a\"}),customElements.define(\"contexter-inner\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__inner\"}}),customElements.define(\"contexter-thumbnail\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__thumbnail\"}}),customElements.define(\"contexter-byline\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__byline\"}}),customElements.define(\"contexter-keywordset\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__keywordset\"}}),customElements.define(\"contexter-linkset\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__linkset\"}}),customElements.define(\"contexter-meta\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__meta\"}}),customElements.define(\"contexter-summary\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"p-summary entry-summary\"}}),customElements.define(\"contexter-box-head\",class extends HTMLElement{constructor(){super()}connectedCallback(){this.className=\"contexter-box__head\"}}),customElements.define(\"contexter-box-inner\",class extends HTMLElement{constructor(){super()}connectedCallback(){}});class ContexterBox extends HTMLElement{constructor(){super(),this.first=!0,this.shadow=this.attachShadow({mode:\"open\"})}connectedCallback(){if(this.first){this.first=!1;var style=document.createElement(\"style\"),lightDomStyle=(style.innerHTML=`:host {--background: #f5f6f7;--border: darkblue;--blue: #0000ee;--font-color: black;--inner-border: black;font-family: Franklin,Arial,Helvetica,sans-serif;font-size: 14px;background: var(--background);width: 600px;color: var(--font-color);min-height: 90px;display: block;padding: 8px;border: 1px solid var(--border);cursor: pointer;box-sizing: border-box;margin: 6px;contain: content;margin: 6px auto;}// can only select top-level nodes with slotted::slotted(*) {max-width: 100%;display:block;}::slotted([slot=thumbnail]) {max-width: 100%;display:block;}::slotted([slot=header]) {width: 100%;font-size: 1.25rem;font-weight: bold;display:block;margin-bottom: 6px;}::slotted([slot=author]) {max-width: 50%;font-size: 12px;display:inline-block;float: left;}::slotted([slot=time]) {max-width: 50%;font-size: 12px;display:inline-block;float: right;}::slotted([slot=summary]) {width: 100%;margin-top: 6px;padding: 10px 2px;border-top: 1px solid var(--inner-border);font-size: 15px;display:inline-block;margin-bottom: 6px;}contexter-meta {height: auto;margin-bottom: 4px;width: 100%;display: grid;position: relative;min-height: 16px;grid-template-columns: repeat(2, 1fr);}::slotted([slot=keywords]) {width: 80%;padding: 2px 4px;border-top: 1px solid var(--inner-border);font-size: 11px;display: block;float: right;font-style: italic;text-align: right;grid-column: 2/2;grid-row: 1;align-self: end;justify-self: end;}::slotted([slot=keywords]):empty {border-top: 0px solid var(--inner-border);}::slotted([slot=archive-link]) {font-size: 1em;display: inline;}::slotted([slot=archive-link])::after {content: \"|\";display: inline;color: var(--font-color);text-decoration: none;margin: 0 .5em;}::slotted([slot=read-link]) {font-size: 1em;display: inline;}contexter-linkset {width: 80%;padding: 2px 4px;font-size: 13px;float: left;font-weight: bold;grid-row: 1;grid-column: 1/2;align-self: end;justify-self: start;}/* Extra small devices (phones, 600px and down) */@media only screen and (max-width: 600px) {:host {width: 310px;}}/* Small devices (portrait tablets and large phones, 600px and up) */@media only screen and (min-width: 600px) {...}/* Medium devices (landscape tablets, 768px and up) */@media only screen and (min-width: 768px) {...}/* Large devices (laptops/desktops, 992px and up) */@media only screen and (min-width: 992px) {...}/* Extra large devices (large laptops and desktops, 1200px and up) */@media only screen and (min-width: 1200px) {...}@media (prefers-color-scheme: dark){:host {--background: #354150;--border: #1f2b37;--blue: #55b0ff;--font-color: #ffffff;--inner-border: #787a7c;background: var(--background);border: 1px solid var(--border)}}`,document.createElement(\"style\"));lightDomStyle.innerHTML=`contexter-box {contain: content;}contexter-box .read-link {font-weight: bold;}contexter-box a {color: #0000ee;}contexter-box img {width: 100%;border: 0;padding: 0;margin: 0;}/* Extra small devices (phones, 600px and down) */@media only screen and (max-width: 600px) {...}/* Small devices (portrait tablets and large phones, 600px and up) */@media only screen and (min-width: 600px) {...}/* Medium devices (landscape tablets, 768px and up) */@media only screen and (min-width: 768px) {...}/* Large devices (laptops/desktops, 992px and up) */@media only screen and (min-width: 992px) {...}/* Extra large devices (large laptops and desktops, 1200px and up) */@media only screen and (min-width: 1200px) {...}@media (prefers-color-scheme: dark){contexter-box a {color: #55b0ff;}}`,this.appendChild(lightDomStyle),this.shadow.appendChild(style);const innerContainer=document.createElement(\"contexter-box-inner\"),innerSlotThumbnail=(this.shadow.appendChild(innerContainer),document.createElement(\"slot\")),innerSlotHeader=(innerSlotThumbnail.name=\"thumbnail\",innerContainer.appendChild(innerSlotThumbnail),document.createElement(\"slot\")),innerSlotAuthor=(innerSlotHeader.name=\"header\",innerContainer.appendChild(innerSlotHeader),document.createElement(\"slot\")),innerSlotTime=(innerSlotAuthor.name=\"author\",innerContainer.appendChild(innerSlotAuthor),document.createElement(\"slot\")),innerSlotSummary=(innerSlotTime.name=\"time\",innerContainer.appendChild(innerSlotTime),document.createElement(\"slot\")),metaContainer=(innerSlotSummary.name=\"summary\",innerContainer.appendChild(innerSlotSummary),document.createElement(\"contexter-meta\")),innerSlotInfo=(innerContainer.appendChild(metaContainer),document.createElement(\"slot\")),linkContainer=(innerSlotInfo.name=\"keywords\",metaContainer.appendChild(innerSlotInfo),document.createElement(\"contexter-linkset\")),innerSlotArchiveLink=(metaContainer.appendChild(linkContainer),document.createElement(\"slot\")),innerSlotReadLink=(innerSlotArchiveLink.name=\"archive-link\",linkContainer.appendChild(innerSlotArchiveLink),document.createElement(\"slot\"));innerSlotReadLink.name=\"read-link\",linkContainer.appendChild(innerSlotReadLink),this.className=\"contexter-box\",this.onclick=e=>{if(!e.target.className.includes(\"read-link\")&&!e.target.className.includes(\"title-link\")){const mainLinks=this.querySelectorAll(\"a.main-link\");mainLinks[0].click()}}}}}customElements.define(\"contexter-box\",ContexterBox)},window.contexterSetupComplete||window.contexterSetup();</script><contexter-box class=\"link-card h-entry hentry\" itemscope=\"\" itemtype=\"https://schema.org/CreativeWork\"><contexter-thumbnail class=\"thumbnail\" slot=\"thumbnail\"></contexter-thumbnail><contexter-box-head slot=\"header\" class=\"p-name entry-title\" itemprop=\"headline\"><contexter-box-head slot=\"header\" class=\"p-name entry-title\" itemprop=\"headline\"><a is=\"contexter-link\" href=\"http://darobin.github.io/api-design-privacy/api-design-privacy.html\" itemprop=\"url\">Patterns for Privacy by Design in Javascript APIs</a></contexter-box-head></contexter-box-head><time class=\"dt-published published\" slot=\"time\" itemprop=\"datePublished\" datetime=\"2022-04-05T17:38:36.764Z\">3/5/2022</time><contexter-summary class=\"p-summary entry-summary\" itemprop=\"abstract\" slot=\"summary\"><p>This document provides some background on the threats to users' privacy that Javascript APIs help createon the Web, and provides some patterns to mitigate such threats at the API design level. Its primaryaudience is therefore people involved in the definition and implementation inside user agents of such APIs.</p></contexter-summary><contexter-keywordset itemprop=\"keywords\" slot=\"keywords\"></contexter-keywordset><a is=\"contexter-link\" href=\"http://darobin.github.io/api-design-privacy/api-design-privacy.html\" class=\"read-link main-link\" itemprop=\"sameAs\" slot=\"read-link\">Read</a></contexter-box>","linkId":"a5f7ca6efd8e89eadbe5fb5faca783ad4d228fd9","data":{"originalLink":"http://darobin.github.io/api-design-privacy/api-design-privacy.html","sanitizedLink":"http://darobin.github.io/api-design-privacy/api-design-privacy.html","canonical":"http://darobin.github.io/api-design-privacy/api-design-privacy.html","htmlText":"<!DOCTYPE html>\n<html xmlns='http://www.w3.org/1999/xhtml' lang='en'>\n  <head>\n    <meta charset='utf-8'/>\n    <title>Patterns for Privacy by Design in Javascript APIs</title>\n    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' async></script>\n    <script class='remove'>\n      var respecConfig = {\n          specStatus:           \"draft-finding\"\n      ,   shortName:            \"privacy-by-design-in-apis\"\n      //,  publishDate:  \"2009-08-06\"\n      // ,   copyrightStart: \"2011\"\n      // ,   previousPublishDate:  \"2011-04-28\"\n      // ,   previousMaturity:  \"draft-finding\"\n      ,   edDraftURI:           \"http://darobin.github.com/api-design-privacy/api-design-privacy.html\"\n      ,   extraCSS:             [\"http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css\"]\n      ,   editors:  [\n              { name: \"Robin Berjon\", url: \"http://berjon.com/\", company: \"freelance\" }\n          ,   { name: \"Daniel Appelquist\", url: \"http://www.torgo.com/\" }\n          ]\n      ,   wg:           \"Technical Architecture Group\"\n      ,   wgURI:        \"http://www.w3.org/2001/tag/\"\n      ,   wgPublicList: \"www-tag\"\n      ,   wgPatentURI:  \"\"\n      };\n    </script>\n  </head>\n  <!-- \n    XXX\n      - get feedback from DAP, WebApps\n      - http://tools.ietf.org/html/draft-iab-privacy-considerations-02\n  -->\n  <body>\n    <section id='abstract'>\n      <p>\n        This document provides some background on the threats to users' privacy that Javascript APIs help create\n        on the Web, and provides some patterns to mitigate such threats at the API design level. Its primary\n        audience is therefore people involved in the definition and implementation inside user agents of such APIs.\n      </p>\n    </section>\n    <section id='sotd'>\n      <p>\n        This document is a draft TAG finding, and as such has no official standing whatsoever.\n      </p>\n      <p>\n        This document is a work in progress from the\n        <a href=\"http://www.w3.org/2001/tag/\"><acronym title=\"World Wide Web Consortium\">W3C</acronym> \n        Technical Architecture Group (TAG)</a>. <a href=\"/2001/tag/findings\">Additional TAG findings</a>, both\n        accepted and in draft state, may also be available. The TAG may incorporate this and other findings \n        into future versions of the [[WEBARCH]].  Please send comments on this finding to the publicly archived \n        TAG mailing list <a href=\"mailto:www-tag@w3.org\">www-tag@w3.org</a> \n        (<a href=\"http://lists.w3.org/Archives/Public/www-tag/\">archive</a>).\n      </p>\n    </section>\n    <section>\n      <h2>Introduction</h2>\n      <p>\n        User privacy is a core feature of the Web. As the Web continues its evolution into a powerful application\n        platform, an increasing number of its additional abilities risk compromising user privacy unless they\n        are specifically created to promote it. While potentially present in all aspects of the Web platform,\n        this issue is particularly salient when it comes to Javascript APIs since they comprise one of the\n        most frequent and natural extensibility point for powerful features that can be misused, and that are\n        hard to mitigate against.\n      </p>\n      <p>\n        This leads to a strong requirement on these APIs to take user privacy into account from the earliest steps\n        in their conception. This, in turn, imposes design constraints that are different from those found in more\n        traditional applications programming which entails that experience with APIs designed for the latter \n        seldom applies in full and needs to be revisited.\n      </p>\n    </section>\n    <section>\n      <h2>Scope</h2>\n      <p>\n        User privacy on the Web is a multifaceted topic which defies easy answers often causes great disagreement \n        and debate. This document does not seek to analyse all facets of Web privacy. However, it does recognise \n        the fact that awareness of Web privacy issues is on the rise, both on the part of Web users and Web developers. \n        Over the past three years, the W3C has run several workshops and launched two new groups on topics related to \n        user privacy. The IETF has also strongly expanded its activities in the privacy space. Strong privacy laws \n        are in force in many parts of the world and being discussed in others.\n      </p>\n      <p>\n        Privacy on the Web is a topic that overlaps technical, social, regulatory and emotional barriers and is \n        therefore difficult to pin down when creating a technical specification. This paper therefore chooses to \n        focus on a deliberately limited subset of the problem space.\n      </p>\n      <p>\n        In this document we consider only those aspects of privacy and APIs that can be mitigated by API designers,\n        such as providing more information than is necessary for a given operation, not making it possible for the\n        user to control what information is being shared, and device fingerprinting. Conversely we do not cover other\n        privacy attacks such as tricking the user into providing information or maliciously using collected information\n        in ways that were not agreed to by the user. We have chosen this focus because well-designed APIs from the \n        privacy standpoint should provide a solid foundation for better user privacy in general, because they can help\n        address the problem at the root, and because we feel that they form a coherent whole.\n      </p>\n      <p>\n        It is important in reading this document that its ambition is simply to capture known best current practices\n        in API design in order to help spread them amongst groups, and so as to provide a common starting point on top\n        of which further privacy-enhancing API design patterns can be built. Its content is therefore not expected to\n        remain static for all of eternity, but rather to evolve so as to capture the community's knowledge\n        of this domain.\n      </p>\n      <p>\n        Privacy is a very broad topic that covers most parts of the technological stack as well as its relationship\n        to society. Rather than attempt to “boil the privacy ocean” and address the entirety of the issue at once,\n        it is the firm opinion of this document's authors that the users' privacy will be best served by addressing\n        the problem separately at each layer that it touches so as to avoid the architectural infelicities involved\n        in crossing layer boundaries with a single solution. Such well-scoped changes can furthermore be deployed\n        quickly and provide the greater leverage of being accepted in their respective communities. There are\n        therefore <em>many</em> privacy issues that this document does not address; we can only encourage others\n        to attempt similar exercises across the board. Note that while the TAG's remit reaches well beyond API\n        design and thus leaves the door open for further TAG work on privacy, this specific domain was selected\n        as an area of high priority due to the great number of APIs being designed concurrently at this time.\n      </p>\n    </section>\n    <section>\n      <h2>Background</h2>\n      <p>\n        This section introduces some of the background thinking and history behind the development of this\n        document.\n      </p>\n      <section>\n        <h2>Data Minimisation</h2>\n        <p>\n          In their 1975 paper <a href='http://www.cs.virginia.edu/~evans/cs551/saltzer/'>The Protection of Information \n          in Computer Systems</a>, computer scientists Jerome Saltzer and Michael Schroeder articulated a principle of \n          “least privilege:”\n        </p>\n        <blockquote>\n          Every program and every user of the system should operate using the least set of privileges \n          necessary to complete the job. Primarily, this principle limits the damage that can result \n          from an accident or error. It also reduces the number of potential interactions among privileged \n          programs to the minimum for correct operation, so that unintentional, unwanted, or improper uses \n          of privilege are less likely to occur.\n        </blockquote>\n        <p>\n          Although written long before the Web came into use and firmly form a security standpoint, Saltzer \n          and Schroeder's definition could apply as easily to the distributed world of Web applications as \n          they did to time-sharing mainframe programming of the 1970s.\n        </p>\n        <p>\n          Today, client-side Web applications are increasingly playing a role as intermediates for our personal,\n          privileged information between the devices we carry and applications residing somewhere on the Internet.\n        </p>\n        <p>\n          In the “<a href='http://tools.ietf.org/id/draft-hansen-privacy-terminology-00.html'>Terminology for \n          Talking about Privacy by Data Minimization: Anonymity, Unlinkability, Undetectability, Unobservability,\n          Pseudonymity, and Identity Management</a>”, Andreas Pfitzmann, Marit Hansen, and Hannes Tschofenig \n          succinctly define minimisation as a strategy towards implementing enhanced privacy in (personal) data\n          collection and usage:\n        </p>\n        <blockquote>\n          <p>\n            Data minimization means that first of all, the possibility to collect personal data about others \n            should be minimized. Next within the remaining possibilities, collecting personal data should be\n            minimized. Finally, the time how long collected personal data is stored should be minimized.\n          </p>\n          <p>\n            Data minimization is the only generic strategy to enable anonymity, since all correct personal data \n            help to identify if we exclude providing misinformation (inaccurate or erroneous information, provided \n            usually without conscious effort at misleading, deceiving, or persuading one way or another) \n            or disinformation (deliberately false or distorted information given out in order to mislead or deceive).\n          </p>\n          <p>\n            Furthermore, data minimization is the only generic strategy to enable unlinkability, since all correct \n            personal data provides some linkability if we exclude providing misinformation or disinformation.\n          </p>\n        </blockquote>\n        <p>\n          In attempting to apply these principles to the area of client-side Web APIs, the W3C Device APIs Working \n          Group has refined this definition within their <a href=\"http://www.w3.org/TR/dap-privacy-reqs/\">Device \n          API Privacy Requirements</a>.\n        </p>\n        <blockquote>\n          <ul>\n            <li>\n              APIs MUST make it easy to request as little information as required for the intended usage. For \n              instance, an API call should require specific parameters to be set to obtain more information, \n              and should default to little or no information.\n            </li>\n            <li>\n              APIs SHOULD make it possible for user agents to convey the breadth of information that the requester \n              is asking for. For instance, if a developer only needs to access a specific field of a user address \n              book, it should be possible to explicitly mark that field in the API call so that the user agent can \n              inform the user that this single field of data will be shared.\n            </li>\n            <li>\n              APIs SHOULD make it possible for user agents to let the user select, filter, and transform information\n              before it is shared with the requester. The user agent can then act as a broker for trusted data, and will\n              only transmit data to the requester that the user has explicitly allowed.\n            </li>\n          </ul>\n        </blockquote>\n      </section>\n      <section>\n        <h2>Privacy by Design</h2>\n        <p>\n          “Privacy by design” is a relatively loaded term which has taken on multiple different definitions depending\n          on context. However, since it is the term of trade that has been in use in groups tasked with defining\n          Javascript APIs over the past few years, we have chosen to keep it, while ensuring that a specific definition\n          is provided here.\n        </p>\n        <p>\n          Within the scope of this document, <dfn>privacy by design</dfn> is a design approach that takes malicious \n          practices for granted and endeavours to prevent and mitigate them from the ground up by applying specific \n          patterns to the creation of Javascript APIs.\n        </p>\n        <p>\n          It is particularly important in privacy by design that users be exposed to as few direct privacy decisions as\n          possible. Notably, it should never be assumed that users can be “educated” into making correct privacy decisions.\n          The reason for this is that user typically interact with their user agent in order to accomplish a specific task.\n          Anything that interrupts the flow of that task's realisation is likely to only be given as cursory a thought\n          as possible. Therefore, requiring users to make privacy decisions whilst in the middle of accomplishing a task\n          is a recipe for poor decisions.\n        </p>\n        <p>\n          There are two primary issues that privacy by design seeks to address within the scope of Javascript APIs.\n        </p>\n        <section>\n          <h2>Poor Information Scoping</h2>\n          <p>\n            In order to accomplish a given operation, a Web application may legitimately require access to some of \n            the user's private information. The issue here is that in providing access to the required information\n            can sometimes entail exposing a lot more information. For instance, when the user wishes to share one\n            event in their calendar, the entire calendar becomes available; or where the user needs to share the\n            name and email addresses of some of their contacts, the phone numbers, pictures, home addresses, etc.\n            of these contacts are also returned.\n          </p>\n        </section>\n        <section>\n          <h2>Device Fingerprinting</h2>\n          <p>\n            Users are routinely tracked across the Web through the use of cookies and other such identification\n            mechanisms. In many cases, these tracking methods can be successfully mitigated by the user agent, for instance\n            by only returning cookies for the top level window in the browsing context (as opposed to providing them\n            for <code>iframe</code>s for instance).\n          </p>\n          <p>\n            Fingerprinting circumvents this by looking at as many of the unique features of a user agent in order to\n            ascertain its uniqueness. For instance, it may look at screen resolution, the availability of specific\n            plugins, at the list of fonts that are installed on the system, the user agent string, the timezone, and\n            a wealth of information that user agents tend to provide by default. Taken one by one, none of these\n            data are sufficient to identify a single user, but put together they collect enough bits to narrow\n            the identification down to just the one person — especially if you take into account the population \n            that visits a given site or set of sites.\n          </p>\n          <p>\n            A very good demonstration of fingerprinting, alongside with a paper detailing the approach, are\n            available from <a href='http://panopticlick.eff.org/'>Panopticlick — How Unique and Traceable is Your Browser?</a>\n          </p>\n        </section>\n      </section>\n    </section>\n    <section>\n      <h2>Privacy-Enhancing API Patterns</h2>\n      <p>\n        The Web application platform requires the availability of a vast array of functionality that can greatly \n        vary in nature. As a result, not all APIs can look the same, and no single approach can be applied automatically\n        across the board in order to take privacy into account during API design. This section therefore lists\n        patterns that API designers are expected to adapt to the specific requirements of their work.\n      </p>\n      <section>\n        <h2>Action-Based Availability</h2>\n        <p>\n          We seldom pause to think about it, but the manner in which mouse events are provided to Web applications\n          is a good example of privacy by design. When a page is loaded, the application has no way of knowing\n          whether a mouse is attached, what type of mouse it is (let alone which make and model), what kind of\n          capabilities it exposes, how many are attached, and so on. Only when the user decides to use the \n          mouse — presumably because it is required for interaction — does some of this information become \n          available. And even then, only the strict minimal is exposed: you could not know whether it is a \n          trackpad for instance, and the fact that it may have a right button is only exposed if it is used.\n        </p>\n        <p>\n          This is an efficient way to prevent fingerprinting: only the minimal amount of information is provided, and\n          even that only when it is required. Contrast it with a design approach that is more typical of the first\n          proposals one sees to expose new interaction modalities:\n        </p>\n        <pre class='example sh_javascript'>\n          var mice = navigator.getAllMice();\n          for (var i = 0, n = mice.length; i &lt; n; i++) {\n              var mouse = mice[i];\n              // discover all sorts of unnecessary information about each mouse\n              // presumably do something to register event handlers on them\n          }\n        </pre>\n        <p>\n          The “Action-Based Availability” design pattern is applicable beyond mouse events. For instance, \n          the <a href='https://dvcs.w3.org/hg/gamepad/raw-file/default/gamepad.html'>Gamepad API</a> makes \n          use of it. It is impossible for a Web game to know if the user\n          agent has access to gamepads, how many there are, what their capabilities are, etc. It is simply\n          assumed that if the user wishes to interact with the game through the gamepad then she will know\n          when to action it — and actioning it will provide the application with all the information that\n          it needs to operate (but no more than that).\n        </p>\n        <p>\n          The way in which this pattern is supported for the mouse is simply by only providing information\n          on the mouse's behaviour when certain events take place. The approach is therefore to expose\n          event handling (e.g. triggering on click, move, button press) as the sole interface to the device.\n        </p>\n        <p>\n          The Gamepad API supports this in a different, but equally good, fashion. The <code>navigator.gamepads</code>\n          array is initially empty, and only becomes populated when a gamepad has been interacted with (and then,\n          only with those of the connected gamepads that have been manipulated). Once they have been interacted with,\n          for the lifetime of the document these gamepads become available in the array and can be queried for a limited\n          (but essential) set of information.\n        </p>\n      </section>\n      <section>\n        <h2>Graceful Degradation</h2>\n        <p>\n          Graceful degradation is the principle according to which a system will continue to operate at the\n          best of its capabilities despite the fact that a given piece of functionality may be missing.\n          While commonly relied upon in Web technology, notably for document styling, it also has value\n          as a tool that can minimise device fingerprinting.\n        </p>\n        <p>\n          A good example of this pattern in action is the <a href='http://www.w3.org/TR/vibration/'>Vibration API</a>.\n          Traditional APIs for vibration would make it possible for the developer to detect whether the device\n          on which her application is being run features a vibrator. Additionally, attempting to trigger\n          vibration would likely cause an exception or other such code-detectable failure. This would produce\n          at least one bit of additional fingerprinting information, possibly more if the device's vibrators could be\n          further investigated.\n        </p>\n        <p>\n          The Vibration API approaches this problem differently: when a device does not support actual vibration,\n          it does not surface this information. Calling <code>navigator.vibrate(1000)</code> will work just as\n          well as if a vibrator had been present, and indistinguishably from that set up. In addition to making\n          the code more robust, this approach therefore also contributes to fingerprinting reduction.\n        </p>\n      </section>\n      <section>\n        <h2>User Mediation</h2>\n        <p>\n          By default, the user agent should provide Web applications with an environment that is privacy-safe\n          for the user in that it does not expose any of the user's information without her consent. But in\n          order to be most useful, and properly constitute a <em>user</em> agent, it should be allowed to \n          occasionally punch limited holes through this protection and access relevant data. This should \n          never happen without the user's express consent and such access therefore needs to be mediated\n          by the user.\n        </p>\n        <p>\n          At first sight this appears to conflict with the requirement that users be asked to make direct privacy\n          decisions as little as possible, but there is a subtle distinction at play. Direct privacy decisions\n          will prompt the user to provide access to information at the application's behest, usually through\n          some form of permissions dialog. User-mediated access will afford a control for the user to provide\n          the requisite information, and do so in a manner that contextualises the request and places it in\n          the flow of the user's intended action.\n        </p>\n        <p>\n          A good and well-established example of user-mediated access to private data is the file upload form control.\n          If we imagine a Web application that wishes to obtain a picture of the user to use on her profile, \n          the direct privacy decision approach would, as soon as the page is loaded, prompt the user with a\n          permissions dialog asking if the user wishes to share her picture, without any context as to why\n          or for what purpose. Conversely, using a file upload form control the user will naturally go through\n          the form, reach the picture field, activate the file picker dialog, and offer a picture of her choosing.\n          The operative difference is that in the latter case the user need not specifically <em>think</em> about whether\n          providing this picture is a good idea or not. All the context in which the picture is asked for is\n          clearly available, and the decision to share is an inherent part of the action of sharing it. Naturally, the\n          application could still be malicious but at least the user is in the driving seat and in a far better position\n          to make the right call.\n        </p>\n        <p>\n          A counter-example to this pattern can be seen at work in the Geolocation API [[GEOLOCATION-API]]. If a\n          user visits a mapping application in order to obtain the route between two addresses that she enters, she\n          should not be prompted to provide her location since it is useless to the operation at hand. Nevertheless,\n          with the Geolocation API as currently designed she will typically be asked right at load to provide it.\n          A better design would be to require a user-mediated action to expose the user's location.\n        </p>\n        <p>\n          This approach is applicable well beyond file access and geolocation. \n          <a href='http://dvcs.w3.org/hg/web-intents/raw-file/tip/spec/Overview-respec.html'>Web Intents</a> are\n          currently being designed as a generic mechanism for user-mediated access to user-specific data and\n          services and they are expected to apply to a broad range of features such as address book, calendar,\n          messaging, sensors, and more.\n        </p>\n      </section>\n      <section>\n        <h2>Minimisation</h2>\n        <p>\n          Minimisation is a strategy that involves exposing as little information as is required for a given\n          operation to complete. More specifically, it requires not providing access to more information than\n          was apparent in the user-mediated access or allowing the user some control over which information \n          exactly is provided.\n        </p>\n        <p>\n          For instance, if the user has provided access to a given file, the object representing that should not\n          make it possible to obtain information about that file's parent directory and its contents as that is\n          clearly not what is expected.\n        </p>\n        <p>\n          During user-mediated access, the user should also be in control of what is shared. For example, if the\n          user is sharing a list of contacts from her address book it should be clear which fields of these\n          contacts are being requested (e.g. name and email), and she should be able to choose whether those\n          fields are actually going to be returned or not. An example dialog for this may look as follows:\n        </p>\n        <p>\n          <img src='contacts-picker.png' width='752' height='511' alt='Example contact picker'/>\n        </p>\n        <p>\n          In this case the application has clearly requested that the First Name, Salutations, and Email Addresses\n          fields be returned. If it seems unnecessary to the user, she could unselect for instance First Name before\n          providing the list of selected contacts and the application would not be made aware of this choice. Such\n          a decision is made in the flow of user action.\n        </p>\n        <p>\n          The above requires the API to be designed not only in such a manner that the user can initiate the mediation\n          process of access to her data, but also so that it can specify which fields it claims to need.\n        </p>\n      </section>\n    </section>\n    <section class='appendix'>\n      <h2>Acknowledgments</h2>\n      <p>\n        In addition to the members of the TAG, the editors would like to thank the following individuals \n        for their contributions to this document:\n      </p>\n      <p>\n        Ernesto Jiménez, Dominique Hazaël-Massieux, Frederick Hirsch, and Hannes Tschofenig.\n      </p>\n    </section>\n  </body>\n</html>\n","oembed":false,"readabilityObject":{"title":"Patterns for Privacy by Design in Javascript APIs","content":"<div id=\"readability-page-1\" class=\"page\">\n    <section id=\"abstract\">\n      <p>\n        This document provides some background on the threats to users' privacy that Javascript APIs help create\n        on the Web, and provides some patterns to mitigate such threats at the API design level. Its primary\n        audience is therefore people involved in the definition and implementation inside user agents of such APIs.\n      </p>\n    </section>\n    <section id=\"sotd\">\n      <p>\n        This document is a draft TAG finding, and as such has no official standing whatsoever.\n      </p>\n      <p>\n        This document is a work in progress from the\n        <a href=\"http://www.w3.org/2001/tag/\"><acronym title=\"World Wide Web Consortium\">W3C</acronym> \n        Technical Architecture Group (TAG)</a>. <a href=\"/2001/tag/findings\">Additional TAG findings</a>, both\n        accepted and in draft state, may also be available. The TAG may incorporate this and other findings \n        into future versions of the [[WEBARCH]].  Please send comments on this finding to the publicly archived \n        TAG mailing list <a href=\"mailto:www-tag@w3.org\">www-tag@w3.org</a> \n        (<a href=\"http://lists.w3.org/Archives/Public/www-tag/\">archive</a>).\n      </p>\n    </section>\n    <section>\n      <h2>Introduction</h2>\n      <p>\n        User privacy is a core feature of the Web. As the Web continues its evolution into a powerful application\n        platform, an increasing number of its additional abilities risk compromising user privacy unless they\n        are specifically created to promote it. While potentially present in all aspects of the Web platform,\n        this issue is particularly salient when it comes to Javascript APIs since they comprise one of the\n        most frequent and natural extensibility point for powerful features that can be misused, and that are\n        hard to mitigate against.\n      </p>\n      <p>\n        This leads to a strong requirement on these APIs to take user privacy into account from the earliest steps\n        in their conception. This, in turn, imposes design constraints that are different from those found in more\n        traditional applications programming which entails that experience with APIs designed for the latter \n        seldom applies in full and needs to be revisited.\n      </p>\n    </section>\n    <section>\n      <h2>Scope</h2>\n      <p>\n        User privacy on the Web is a multifaceted topic which defies easy answers often causes great disagreement \n        and debate. This document does not seek to analyse all facets of Web privacy. However, it does recognise \n        the fact that awareness of Web privacy issues is on the rise, both on the part of Web users and Web developers. \n        Over the past three years, the W3C has run several workshops and launched two new groups on topics related to \n        user privacy. The IETF has also strongly expanded its activities in the privacy space. Strong privacy laws \n        are in force in many parts of the world and being discussed in others.\n      </p>\n      <p>\n        Privacy on the Web is a topic that overlaps technical, social, regulatory and emotional barriers and is \n        therefore difficult to pin down when creating a technical specification. This paper therefore chooses to \n        focus on a deliberately limited subset of the problem space.\n      </p>\n      <p>\n        In this document we consider only those aspects of privacy and APIs that can be mitigated by API designers,\n        such as providing more information than is necessary for a given operation, not making it possible for the\n        user to control what information is being shared, and device fingerprinting. Conversely we do not cover other\n        privacy attacks such as tricking the user into providing information or maliciously using collected information\n        in ways that were not agreed to by the user. We have chosen this focus because well-designed APIs from the \n        privacy standpoint should provide a solid foundation for better user privacy in general, because they can help\n        address the problem at the root, and because we feel that they form a coherent whole.\n      </p>\n      <p>\n        It is important in reading this document that its ambition is simply to capture known best current practices\n        in API design in order to help spread them amongst groups, and so as to provide a common starting point on top\n        of which further privacy-enhancing API design patterns can be built. Its content is therefore not expected to\n        remain static for all of eternity, but rather to evolve so as to capture the community's knowledge\n        of this domain.\n      </p>\n      <p>\n        Privacy is a very broad topic that covers most parts of the technological stack as well as its relationship\n        to society. Rather than attempt to “boil the privacy ocean” and address the entirety of the issue at once,\n        it is the firm opinion of this document's authors that the users' privacy will be best served by addressing\n        the problem separately at each layer that it touches so as to avoid the architectural infelicities involved\n        in crossing layer boundaries with a single solution. Such well-scoped changes can furthermore be deployed\n        quickly and provide the greater leverage of being accepted in their respective communities. There are\n        therefore <em>many</em> privacy issues that this document does not address; we can only encourage others\n        to attempt similar exercises across the board. Note that while the TAG's remit reaches well beyond API\n        design and thus leaves the door open for further TAG work on privacy, this specific domain was selected\n        as an area of high priority due to the great number of APIs being designed concurrently at this time.\n      </p>\n    </section>\n    <section>\n      <h2>Background</h2>\n      <p>\n        This section introduces some of the background thinking and history behind the development of this\n        document.\n      </p>\n      <section>\n        <h2>Data Minimisation</h2>\n        <p>\n          In their 1975 paper <a href=\"http://www.cs.virginia.edu/~evans/cs551/saltzer/\">The Protection of Information \n          in Computer Systems</a>, computer scientists Jerome Saltzer and Michael Schroeder articulated a principle of \n          “least privilege:”\n        </p>\n        <blockquote>\n          Every program and every user of the system should operate using the least set of privileges \n          necessary to complete the job. Primarily, this principle limits the damage that can result \n          from an accident or error. It also reduces the number of potential interactions among privileged \n          programs to the minimum for correct operation, so that unintentional, unwanted, or improper uses \n          of privilege are less likely to occur.\n        </blockquote>\n        <p>\n          Although written long before the Web came into use and firmly form a security standpoint, Saltzer \n          and Schroeder's definition could apply as easily to the distributed world of Web applications as \n          they did to time-sharing mainframe programming of the 1970s.\n        </p>\n        <p>\n          Today, client-side Web applications are increasingly playing a role as intermediates for our personal,\n          privileged information between the devices we carry and applications residing somewhere on the Internet.\n        </p>\n        <p>\n          In the “<a href=\"http://tools.ietf.org/id/draft-hansen-privacy-terminology-00.html\">Terminology for \n          Talking about Privacy by Data Minimization: Anonymity, Unlinkability, Undetectability, Unobservability,\n          Pseudonymity, and Identity Management</a>”, Andreas Pfitzmann, Marit Hansen, and Hannes Tschofenig \n          succinctly define minimisation as a strategy towards implementing enhanced privacy in (personal) data\n          collection and usage:\n        </p>\n        <blockquote>\n          <p>\n            Data minimization means that first of all, the possibility to collect personal data about others \n            should be minimized. Next within the remaining possibilities, collecting personal data should be\n            minimized. Finally, the time how long collected personal data is stored should be minimized.\n          </p>\n          <p>\n            Data minimization is the only generic strategy to enable anonymity, since all correct personal data \n            help to identify if we exclude providing misinformation (inaccurate or erroneous information, provided \n            usually without conscious effort at misleading, deceiving, or persuading one way or another) \n            or disinformation (deliberately false or distorted information given out in order to mislead or deceive).\n          </p>\n          <p>\n            Furthermore, data minimization is the only generic strategy to enable unlinkability, since all correct \n            personal data provides some linkability if we exclude providing misinformation or disinformation.\n          </p>\n        </blockquote>\n        <p>\n          In attempting to apply these principles to the area of client-side Web APIs, the W3C Device APIs Working \n          Group has refined this definition within their <a href=\"http://www.w3.org/TR/dap-privacy-reqs/\">Device \n          API Privacy Requirements</a>.\n        </p>\n        <blockquote>\n          <ul>\n            <li>\n              APIs MUST make it easy to request as little information as required for the intended usage. For \n              instance, an API call should require specific parameters to be set to obtain more information, \n              and should default to little or no information.\n            </li>\n            <li>\n              APIs SHOULD make it possible for user agents to convey the breadth of information that the requester \n              is asking for. For instance, if a developer only needs to access a specific field of a user address \n              book, it should be possible to explicitly mark that field in the API call so that the user agent can \n              inform the user that this single field of data will be shared.\n            </li>\n            <li>\n              APIs SHOULD make it possible for user agents to let the user select, filter, and transform information\n              before it is shared with the requester. The user agent can then act as a broker for trusted data, and will\n              only transmit data to the requester that the user has explicitly allowed.\n            </li>\n          </ul>\n        </blockquote>\n      </section>\n      <section>\n        \n        <p>\n          “Privacy by design” is a relatively loaded term which has taken on multiple different definitions depending\n          on context. However, since it is the term of trade that has been in use in groups tasked with defining\n          Javascript APIs over the past few years, we have chosen to keep it, while ensuring that a specific definition\n          is provided here.\n        </p>\n        <p>\n          Within the scope of this document, <dfn>privacy by design</dfn> is a design approach that takes malicious \n          practices for granted and endeavours to prevent and mitigate them from the ground up by applying specific \n          patterns to the creation of Javascript APIs.\n        </p>\n        <p>\n          It is particularly important in privacy by design that users be exposed to as few direct privacy decisions as\n          possible. Notably, it should never be assumed that users can be “educated” into making correct privacy decisions.\n          The reason for this is that user typically interact with their user agent in order to accomplish a specific task.\n          Anything that interrupts the flow of that task's realisation is likely to only be given as cursory a thought\n          as possible. Therefore, requiring users to make privacy decisions whilst in the middle of accomplishing a task\n          is a recipe for poor decisions.\n        </p>\n        <p>\n          There are two primary issues that privacy by design seeks to address within the scope of Javascript APIs.\n        </p>\n        <section>\n          <h2>Poor Information Scoping</h2>\n          <p>\n            In order to accomplish a given operation, a Web application may legitimately require access to some of \n            the user's private information. The issue here is that in providing access to the required information\n            can sometimes entail exposing a lot more information. For instance, when the user wishes to share one\n            event in their calendar, the entire calendar becomes available; or where the user needs to share the\n            name and email addresses of some of their contacts, the phone numbers, pictures, home addresses, etc.\n            of these contacts are also returned.\n          </p>\n        </section>\n        <section>\n          <h2>Device Fingerprinting</h2>\n          <p>\n            Users are routinely tracked across the Web through the use of cookies and other such identification\n            mechanisms. In many cases, these tracking methods can be successfully mitigated by the user agent, for instance\n            by only returning cookies for the top level window in the browsing context (as opposed to providing them\n            for <code>iframe</code>s for instance).\n          </p>\n          <p>\n            Fingerprinting circumvents this by looking at as many of the unique features of a user agent in order to\n            ascertain its uniqueness. For instance, it may look at screen resolution, the availability of specific\n            plugins, at the list of fonts that are installed on the system, the user agent string, the timezone, and\n            a wealth of information that user agents tend to provide by default. Taken one by one, none of these\n            data are sufficient to identify a single user, but put together they collect enough bits to narrow\n            the identification down to just the one person — especially if you take into account the population \n            that visits a given site or set of sites.\n          </p>\n          <p>\n            A very good demonstration of fingerprinting, alongside with a paper detailing the approach, are\n            available from <a href=\"http://panopticlick.eff.org/\">Panopticlick — How Unique and Traceable is Your Browser?</a>\n          </p>\n        </section>\n      </section>\n    </section>\n    <section>\n      <h2>Privacy-Enhancing API Patterns</h2>\n      <p>\n        The Web application platform requires the availability of a vast array of functionality that can greatly \n        vary in nature. As a result, not all APIs can look the same, and no single approach can be applied automatically\n        across the board in order to take privacy into account during API design. This section therefore lists\n        patterns that API designers are expected to adapt to the specific requirements of their work.\n      </p>\n      <section>\n        <h2>Action-Based Availability</h2>\n        <p>\n          We seldom pause to think about it, but the manner in which mouse events are provided to Web applications\n          is a good example of privacy by design. When a page is loaded, the application has no way of knowing\n          whether a mouse is attached, what type of mouse it is (let alone which make and model), what kind of\n          capabilities it exposes, how many are attached, and so on. Only when the user decides to use the \n          mouse — presumably because it is required for interaction — does some of this information become \n          available. And even then, only the strict minimal is exposed: you could not know whether it is a \n          trackpad for instance, and the fact that it may have a right button is only exposed if it is used.\n        </p>\n        <p>\n          This is an efficient way to prevent fingerprinting: only the minimal amount of information is provided, and\n          even that only when it is required. Contrast it with a design approach that is more typical of the first\n          proposals one sees to expose new interaction modalities:\n        </p>\n        <pre>          var mice = navigator.getAllMice();\n          for (var i = 0, n = mice.length; i &lt; n; i++) {\n              var mouse = mice[i];\n              // discover all sorts of unnecessary information about each mouse\n              // presumably do something to register event handlers on them\n          }\n        </pre>\n        <p>\n          The “Action-Based Availability” design pattern is applicable beyond mouse events. For instance, \n          the <a href=\"https://dvcs.w3.org/hg/gamepad/raw-file/default/gamepad.html\">Gamepad API</a> makes \n          use of it. It is impossible for a Web game to know if the user\n          agent has access to gamepads, how many there are, what their capabilities are, etc. It is simply\n          assumed that if the user wishes to interact with the game through the gamepad then she will know\n          when to action it — and actioning it will provide the application with all the information that\n          it needs to operate (but no more than that).\n        </p>\n        <p>\n          The way in which this pattern is supported for the mouse is simply by only providing information\n          on the mouse's behaviour when certain events take place. The approach is therefore to expose\n          event handling (e.g. triggering on click, move, button press) as the sole interface to the device.\n        </p>\n        <p>\n          The Gamepad API supports this in a different, but equally good, fashion. The <code>navigator.gamepads</code>\n          array is initially empty, and only becomes populated when a gamepad has been interacted with (and then,\n          only with those of the connected gamepads that have been manipulated). Once they have been interacted with,\n          for the lifetime of the document these gamepads become available in the array and can be queried for a limited\n          (but essential) set of information.\n        </p>\n      </section>\n      <section>\n        <h2>Graceful Degradation</h2>\n        <p>\n          Graceful degradation is the principle according to which a system will continue to operate at the\n          best of its capabilities despite the fact that a given piece of functionality may be missing.\n          While commonly relied upon in Web technology, notably for document styling, it also has value\n          as a tool that can minimise device fingerprinting.\n        </p>\n        <p>\n          A good example of this pattern in action is the <a href=\"http://www.w3.org/TR/vibration/\">Vibration API</a>.\n          Traditional APIs for vibration would make it possible for the developer to detect whether the device\n          on which her application is being run features a vibrator. Additionally, attempting to trigger\n          vibration would likely cause an exception or other such code-detectable failure. This would produce\n          at least one bit of additional fingerprinting information, possibly more if the device's vibrators could be\n          further investigated.\n        </p>\n        <p>\n          The Vibration API approaches this problem differently: when a device does not support actual vibration,\n          it does not surface this information. Calling <code>navigator.vibrate(1000)</code> will work just as\n          well as if a vibrator had been present, and indistinguishably from that set up. In addition to making\n          the code more robust, this approach therefore also contributes to fingerprinting reduction.\n        </p>\n      </section>\n      <section>\n        <h2>User Mediation</h2>\n        <p>\n          By default, the user agent should provide Web applications with an environment that is privacy-safe\n          for the user in that it does not expose any of the user's information without her consent. But in\n          order to be most useful, and properly constitute a <em>user</em> agent, it should be allowed to \n          occasionally punch limited holes through this protection and access relevant data. This should \n          never happen without the user's express consent and such access therefore needs to be mediated\n          by the user.\n        </p>\n        <p>\n          At first sight this appears to conflict with the requirement that users be asked to make direct privacy\n          decisions as little as possible, but there is a subtle distinction at play. Direct privacy decisions\n          will prompt the user to provide access to information at the application's behest, usually through\n          some form of permissions dialog. User-mediated access will afford a control for the user to provide\n          the requisite information, and do so in a manner that contextualises the request and places it in\n          the flow of the user's intended action.\n        </p>\n        <p>\n          A good and well-established example of user-mediated access to private data is the file upload form control.\n          If we imagine a Web application that wishes to obtain a picture of the user to use on her profile, \n          the direct privacy decision approach would, as soon as the page is loaded, prompt the user with a\n          permissions dialog asking if the user wishes to share her picture, without any context as to why\n          or for what purpose. Conversely, using a file upload form control the user will naturally go through\n          the form, reach the picture field, activate the file picker dialog, and offer a picture of her choosing.\n          The operative difference is that in the latter case the user need not specifically <em>think</em> about whether\n          providing this picture is a good idea or not. All the context in which the picture is asked for is\n          clearly available, and the decision to share is an inherent part of the action of sharing it. Naturally, the\n          application could still be malicious but at least the user is in the driving seat and in a far better position\n          to make the right call.\n        </p>\n        <p>\n          A counter-example to this pattern can be seen at work in the Geolocation API [[GEOLOCATION-API]]. If a\n          user visits a mapping application in order to obtain the route between two addresses that she enters, she\n          should not be prompted to provide her location since it is useless to the operation at hand. Nevertheless,\n          with the Geolocation API as currently designed she will typically be asked right at load to provide it.\n          A better design would be to require a user-mediated action to expose the user's location.\n        </p>\n        <p>\n          This approach is applicable well beyond file access and geolocation. \n          <a href=\"http://dvcs.w3.org/hg/web-intents/raw-file/tip/spec/Overview-respec.html\">Web Intents</a> are\n          currently being designed as a generic mechanism for user-mediated access to user-specific data and\n          services and they are expected to apply to a broad range of features such as address book, calendar,\n          messaging, sensors, and more.\n        </p>\n      </section>\n      <section>\n        <h2>Minimisation</h2>\n        <p>\n          Minimisation is a strategy that involves exposing as little information as is required for a given\n          operation to complete. More specifically, it requires not providing access to more information than\n          was apparent in the user-mediated access or allowing the user some control over which information \n          exactly is provided.\n        </p>\n        <p>\n          For instance, if the user has provided access to a given file, the object representing that should not\n          make it possible to obtain information about that file's parent directory and its contents as that is\n          clearly not what is expected.\n        </p>\n        <p>\n          During user-mediated access, the user should also be in control of what is shared. For example, if the\n          user is sharing a list of contacts from her address book it should be clear which fields of these\n          contacts are being requested (e.g. name and email), and she should be able to choose whether those\n          fields are actually going to be returned or not. An example dialog for this may look as follows:\n        </p>\n        <p>\n          <img src=\"contacts-picker.png\" width=\"752\" height=\"511\" alt=\"Example contact picker\">\n        </p>\n        <p>\n          In this case the application has clearly requested that the First Name, Salutations, and Email Addresses\n          fields be returned. If it seems unnecessary to the user, she could unselect for instance First Name before\n          providing the list of selected contacts and the application would not be made aware of this choice. Such\n          a decision is made in the flow of user action.\n        </p>\n        <p>\n          The above requires the API to be designed not only in such a manner that the user can initiate the mediation\n          process of access to her data, but also so that it can specify which fields it claims to need.\n        </p>\n      </section>\n    </section>\n    <section>\n      <h2>Acknowledgments</h2>\n      <p>\n        In addition to the members of the TAG, the editors would like to thank the following individuals \n        for their contributions to this document:\n      </p>\n      <p>\n        Ernesto Jiménez, Dominique Hazaël-Massieux, Frederick Hirsch, and Hannes Tschofenig.\n      </p>\n    </section>\n  \n\n</div>","textContent":"\n    \n      \n        This document provides some background on the threats to users' privacy that Javascript APIs help create\n        on the Web, and provides some patterns to mitigate such threats at the API design level. Its primary\n        audience is therefore people involved in the definition and implementation inside user agents of such APIs.\n      \n    \n    \n      \n        This document is a draft TAG finding, and as such has no official standing whatsoever.\n      \n      \n        This document is a work in progress from the\n        W3C \n        Technical Architecture Group (TAG). Additional TAG findings, both\n        accepted and in draft state, may also be available. The TAG may incorporate this and other findings \n        into future versions of the [[WEBARCH]].  Please send comments on this finding to the publicly archived \n        TAG mailing list www-tag@w3.org \n        (archive).\n      \n    \n    \n      Introduction\n      \n        User privacy is a core feature of the Web. As the Web continues its evolution into a powerful application\n        platform, an increasing number of its additional abilities risk compromising user privacy unless they\n        are specifically created to promote it. While potentially present in all aspects of the Web platform,\n        this issue is particularly salient when it comes to Javascript APIs since they comprise one of the\n        most frequent and natural extensibility point for powerful features that can be misused, and that are\n        hard to mitigate against.\n      \n      \n        This leads to a strong requirement on these APIs to take user privacy into account from the earliest steps\n        in their conception. This, in turn, imposes design constraints that are different from those found in more\n        traditional applications programming which entails that experience with APIs designed for the latter \n        seldom applies in full and needs to be revisited.\n      \n    \n    \n      Scope\n      \n        User privacy on the Web is a multifaceted topic which defies easy answers often causes great disagreement \n        and debate. This document does not seek to analyse all facets of Web privacy. However, it does recognise \n        the fact that awareness of Web privacy issues is on the rise, both on the part of Web users and Web developers. \n        Over the past three years, the W3C has run several workshops and launched two new groups on topics related to \n        user privacy. The IETF has also strongly expanded its activities in the privacy space. Strong privacy laws \n        are in force in many parts of the world and being discussed in others.\n      \n      \n        Privacy on the Web is a topic that overlaps technical, social, regulatory and emotional barriers and is \n        therefore difficult to pin down when creating a technical specification. This paper therefore chooses to \n        focus on a deliberately limited subset of the problem space.\n      \n      \n        In this document we consider only those aspects of privacy and APIs that can be mitigated by API designers,\n        such as providing more information than is necessary for a given operation, not making it possible for the\n        user to control what information is being shared, and device fingerprinting. Conversely we do not cover other\n        privacy attacks such as tricking the user into providing information or maliciously using collected information\n        in ways that were not agreed to by the user. We have chosen this focus because well-designed APIs from the \n        privacy standpoint should provide a solid foundation for better user privacy in general, because they can help\n        address the problem at the root, and because we feel that they form a coherent whole.\n      \n      \n        It is important in reading this document that its ambition is simply to capture known best current practices\n        in API design in order to help spread them amongst groups, and so as to provide a common starting point on top\n        of which further privacy-enhancing API design patterns can be built. Its content is therefore not expected to\n        remain static for all of eternity, but rather to evolve so as to capture the community's knowledge\n        of this domain.\n      \n      \n        Privacy is a very broad topic that covers most parts of the technological stack as well as its relationship\n        to society. Rather than attempt to “boil the privacy ocean” and address the entirety of the issue at once,\n        it is the firm opinion of this document's authors that the users' privacy will be best served by addressing\n        the problem separately at each layer that it touches so as to avoid the architectural infelicities involved\n        in crossing layer boundaries with a single solution. Such well-scoped changes can furthermore be deployed\n        quickly and provide the greater leverage of being accepted in their respective communities. There are\n        therefore many privacy issues that this document does not address; we can only encourage others\n        to attempt similar exercises across the board. Note that while the TAG's remit reaches well beyond API\n        design and thus leaves the door open for further TAG work on privacy, this specific domain was selected\n        as an area of high priority due to the great number of APIs being designed concurrently at this time.\n      \n    \n    \n      Background\n      \n        This section introduces some of the background thinking and history behind the development of this\n        document.\n      \n      \n        Data Minimisation\n        \n          In their 1975 paper The Protection of Information \n          in Computer Systems, computer scientists Jerome Saltzer and Michael Schroeder articulated a principle of \n          “least privilege:”\n        \n        \n          Every program and every user of the system should operate using the least set of privileges \n          necessary to complete the job. Primarily, this principle limits the damage that can result \n          from an accident or error. It also reduces the number of potential interactions among privileged \n          programs to the minimum for correct operation, so that unintentional, unwanted, or improper uses \n          of privilege are less likely to occur.\n        \n        \n          Although written long before the Web came into use and firmly form a security standpoint, Saltzer \n          and Schroeder's definition could apply as easily to the distributed world of Web applications as \n          they did to time-sharing mainframe programming of the 1970s.\n        \n        \n          Today, client-side Web applications are increasingly playing a role as intermediates for our personal,\n          privileged information between the devices we carry and applications residing somewhere on the Internet.\n        \n        \n          In the “Terminology for \n          Talking about Privacy by Data Minimization: Anonymity, Unlinkability, Undetectability, Unobservability,\n          Pseudonymity, and Identity Management”, Andreas Pfitzmann, Marit Hansen, and Hannes Tschofenig \n          succinctly define minimisation as a strategy towards implementing enhanced privacy in (personal) data\n          collection and usage:\n        \n        \n          \n            Data minimization means that first of all, the possibility to collect personal data about others \n            should be minimized. Next within the remaining possibilities, collecting personal data should be\n            minimized. Finally, the time how long collected personal data is stored should be minimized.\n          \n          \n            Data minimization is the only generic strategy to enable anonymity, since all correct personal data \n            help to identify if we exclude providing misinformation (inaccurate or erroneous information, provided \n            usually without conscious effort at misleading, deceiving, or persuading one way or another) \n            or disinformation (deliberately false or distorted information given out in order to mislead or deceive).\n          \n          \n            Furthermore, data minimization is the only generic strategy to enable unlinkability, since all correct \n            personal data provides some linkability if we exclude providing misinformation or disinformation.\n          \n        \n        \n          In attempting to apply these principles to the area of client-side Web APIs, the W3C Device APIs Working \n          Group has refined this definition within their Device \n          API Privacy Requirements.\n        \n        \n          \n            \n              APIs MUST make it easy to request as little information as required for the intended usage. For \n              instance, an API call should require specific parameters to be set to obtain more information, \n              and should default to little or no information.\n            \n            \n              APIs SHOULD make it possible for user agents to convey the breadth of information that the requester \n              is asking for. For instance, if a developer only needs to access a specific field of a user address \n              book, it should be possible to explicitly mark that field in the API call so that the user agent can \n              inform the user that this single field of data will be shared.\n            \n            \n              APIs SHOULD make it possible for user agents to let the user select, filter, and transform information\n              before it is shared with the requester. The user agent can then act as a broker for trusted data, and will\n              only transmit data to the requester that the user has explicitly allowed.\n            \n          \n        \n      \n      \n        \n        \n          “Privacy by design” is a relatively loaded term which has taken on multiple different definitions depending\n          on context. However, since it is the term of trade that has been in use in groups tasked with defining\n          Javascript APIs over the past few years, we have chosen to keep it, while ensuring that a specific definition\n          is provided here.\n        \n        \n          Within the scope of this document, privacy by design is a design approach that takes malicious \n          practices for granted and endeavours to prevent and mitigate them from the ground up by applying specific \n          patterns to the creation of Javascript APIs.\n        \n        \n          It is particularly important in privacy by design that users be exposed to as few direct privacy decisions as\n          possible. Notably, it should never be assumed that users can be “educated” into making correct privacy decisions.\n          The reason for this is that user typically interact with their user agent in order to accomplish a specific task.\n          Anything that interrupts the flow of that task's realisation is likely to only be given as cursory a thought\n          as possible. Therefore, requiring users to make privacy decisions whilst in the middle of accomplishing a task\n          is a recipe for poor decisions.\n        \n        \n          There are two primary issues that privacy by design seeks to address within the scope of Javascript APIs.\n        \n        \n          Poor Information Scoping\n          \n            In order to accomplish a given operation, a Web application may legitimately require access to some of \n            the user's private information. The issue here is that in providing access to the required information\n            can sometimes entail exposing a lot more information. For instance, when the user wishes to share one\n            event in their calendar, the entire calendar becomes available; or where the user needs to share the\n            name and email addresses of some of their contacts, the phone numbers, pictures, home addresses, etc.\n            of these contacts are also returned.\n          \n        \n        \n          Device Fingerprinting\n          \n            Users are routinely tracked across the Web through the use of cookies and other such identification\n            mechanisms. In many cases, these tracking methods can be successfully mitigated by the user agent, for instance\n            by only returning cookies for the top level window in the browsing context (as opposed to providing them\n            for iframes for instance).\n          \n          \n            Fingerprinting circumvents this by looking at as many of the unique features of a user agent in order to\n            ascertain its uniqueness. For instance, it may look at screen resolution, the availability of specific\n            plugins, at the list of fonts that are installed on the system, the user agent string, the timezone, and\n            a wealth of information that user agents tend to provide by default. Taken one by one, none of these\n            data are sufficient to identify a single user, but put together they collect enough bits to narrow\n            the identification down to just the one person — especially if you take into account the population \n            that visits a given site or set of sites.\n          \n          \n            A very good demonstration of fingerprinting, alongside with a paper detailing the approach, are\n            available from Panopticlick — How Unique and Traceable is Your Browser?\n          \n        \n      \n    \n    \n      Privacy-Enhancing API Patterns\n      \n        The Web application platform requires the availability of a vast array of functionality that can greatly \n        vary in nature. As a result, not all APIs can look the same, and no single approach can be applied automatically\n        across the board in order to take privacy into account during API design. This section therefore lists\n        patterns that API designers are expected to adapt to the specific requirements of their work.\n      \n      \n        Action-Based Availability\n        \n          We seldom pause to think about it, but the manner in which mouse events are provided to Web applications\n          is a good example of privacy by design. When a page is loaded, the application has no way of knowing\n          whether a mouse is attached, what type of mouse it is (let alone which make and model), what kind of\n          capabilities it exposes, how many are attached, and so on. Only when the user decides to use the \n          mouse — presumably because it is required for interaction — does some of this information become \n          available. And even then, only the strict minimal is exposed: you could not know whether it is a \n          trackpad for instance, and the fact that it may have a right button is only exposed if it is used.\n        \n        \n          This is an efficient way to prevent fingerprinting: only the minimal amount of information is provided, and\n          even that only when it is required. Contrast it with a design approach that is more typical of the first\n          proposals one sees to expose new interaction modalities:\n        \n                  var mice = navigator.getAllMice();\n          for (var i = 0, n = mice.length; i < n; i++) {\n              var mouse = mice[i];\n              // discover all sorts of unnecessary information about each mouse\n              // presumably do something to register event handlers on them\n          }\n        \n        \n          The “Action-Based Availability” design pattern is applicable beyond mouse events. For instance, \n          the Gamepad API makes \n          use of it. It is impossible for a Web game to know if the user\n          agent has access to gamepads, how many there are, what their capabilities are, etc. It is simply\n          assumed that if the user wishes to interact with the game through the gamepad then she will know\n          when to action it — and actioning it will provide the application with all the information that\n          it needs to operate (but no more than that).\n        \n        \n          The way in which this pattern is supported for the mouse is simply by only providing information\n          on the mouse's behaviour when certain events take place. The approach is therefore to expose\n          event handling (e.g. triggering on click, move, button press) as the sole interface to the device.\n        \n        \n          The Gamepad API supports this in a different, but equally good, fashion. The navigator.gamepads\n          array is initially empty, and only becomes populated when a gamepad has been interacted with (and then,\n          only with those of the connected gamepads that have been manipulated). Once they have been interacted with,\n          for the lifetime of the document these gamepads become available in the array and can be queried for a limited\n          (but essential) set of information.\n        \n      \n      \n        Graceful Degradation\n        \n          Graceful degradation is the principle according to which a system will continue to operate at the\n          best of its capabilities despite the fact that a given piece of functionality may be missing.\n          While commonly relied upon in Web technology, notably for document styling, it also has value\n          as a tool that can minimise device fingerprinting.\n        \n        \n          A good example of this pattern in action is the Vibration API.\n          Traditional APIs for vibration would make it possible for the developer to detect whether the device\n          on which her application is being run features a vibrator. Additionally, attempting to trigger\n          vibration would likely cause an exception or other such code-detectable failure. This would produce\n          at least one bit of additional fingerprinting information, possibly more if the device's vibrators could be\n          further investigated.\n        \n        \n          The Vibration API approaches this problem differently: when a device does not support actual vibration,\n          it does not surface this information. Calling navigator.vibrate(1000) will work just as\n          well as if a vibrator had been present, and indistinguishably from that set up. In addition to making\n          the code more robust, this approach therefore also contributes to fingerprinting reduction.\n        \n      \n      \n        User Mediation\n        \n          By default, the user agent should provide Web applications with an environment that is privacy-safe\n          for the user in that it does not expose any of the user's information without her consent. But in\n          order to be most useful, and properly constitute a user agent, it should be allowed to \n          occasionally punch limited holes through this protection and access relevant data. This should \n          never happen without the user's express consent and such access therefore needs to be mediated\n          by the user.\n        \n        \n          At first sight this appears to conflict with the requirement that users be asked to make direct privacy\n          decisions as little as possible, but there is a subtle distinction at play. Direct privacy decisions\n          will prompt the user to provide access to information at the application's behest, usually through\n          some form of permissions dialog. User-mediated access will afford a control for the user to provide\n          the requisite information, and do so in a manner that contextualises the request and places it in\n          the flow of the user's intended action.\n        \n        \n          A good and well-established example of user-mediated access to private data is the file upload form control.\n          If we imagine a Web application that wishes to obtain a picture of the user to use on her profile, \n          the direct privacy decision approach would, as soon as the page is loaded, prompt the user with a\n          permissions dialog asking if the user wishes to share her picture, without any context as to why\n          or for what purpose. Conversely, using a file upload form control the user will naturally go through\n          the form, reach the picture field, activate the file picker dialog, and offer a picture of her choosing.\n          The operative difference is that in the latter case the user need not specifically think about whether\n          providing this picture is a good idea or not. All the context in which the picture is asked for is\n          clearly available, and the decision to share is an inherent part of the action of sharing it. Naturally, the\n          application could still be malicious but at least the user is in the driving seat and in a far better position\n          to make the right call.\n        \n        \n          A counter-example to this pattern can be seen at work in the Geolocation API [[GEOLOCATION-API]]. If a\n          user visits a mapping application in order to obtain the route between two addresses that she enters, she\n          should not be prompted to provide her location since it is useless to the operation at hand. Nevertheless,\n          with the Geolocation API as currently designed she will typically be asked right at load to provide it.\n          A better design would be to require a user-mediated action to expose the user's location.\n        \n        \n          This approach is applicable well beyond file access and geolocation. \n          Web Intents are\n          currently being designed as a generic mechanism for user-mediated access to user-specific data and\n          services and they are expected to apply to a broad range of features such as address book, calendar,\n          messaging, sensors, and more.\n        \n      \n      \n        Minimisation\n        \n          Minimisation is a strategy that involves exposing as little information as is required for a given\n          operation to complete. More specifically, it requires not providing access to more information than\n          was apparent in the user-mediated access or allowing the user some control over which information \n          exactly is provided.\n        \n        \n          For instance, if the user has provided access to a given file, the object representing that should not\n          make it possible to obtain information about that file's parent directory and its contents as that is\n          clearly not what is expected.\n        \n        \n          During user-mediated access, the user should also be in control of what is shared. For example, if the\n          user is sharing a list of contacts from her address book it should be clear which fields of these\n          contacts are being requested (e.g. name and email), and she should be able to choose whether those\n          fields are actually going to be returned or not. An example dialog for this may look as follows:\n        \n        \n          \n        \n        \n          In this case the application has clearly requested that the First Name, Salutations, and Email Addresses\n          fields be returned. If it seems unnecessary to the user, she could unselect for instance First Name before\n          providing the list of selected contacts and the application would not be made aware of this choice. Such\n          a decision is made in the flow of user action.\n        \n        \n          The above requires the API to be designed not only in such a manner that the user can initiate the mediation\n          process of access to her data, but also so that it can specify which fields it claims to need.\n        \n      \n    \n    \n      Acknowledgments\n      \n        In addition to the members of the TAG, the editors would like to thank the following individuals \n        for their contributions to this document:\n      \n      \n        Ernesto Jiménez, Dominique Hazaël-Massieux, Frederick Hirsch, and Hannes Tschofenig.\n      \n    \n  \n\n","length":23858,"excerpt":"This document provides some background on the threats to users' privacy that Javascript APIs help create\n        on the Web, and provides some patterns to mitigate such threats at the API design level. Its primary\n        audience is therefore people involved in the definition and implementation inside user agents of such APIs.","byline":null,"dir":null,"siteName":null,"lang":"en"},"finalizedMeta":{"title":"Patterns for Privacy by Design in Javascript APIs","description":"This document provides some background on the threats to users' privacy that Javascript APIs help create\n        on the Web, and provides some patterns to mitigate such threats at the API design level. Its primary\n        audience is therefore people involved in the definition and implementation inside user agents of such APIs.","author":false,"creator":"","publisher":false,"date":"2022-04-05T17:38:36.764Z","topics":[]},"jsonLd":{"@type":false,"headline":false,"description":false,"image":[],"mainEntityOfPage":{"@type":false,"@id":false},"datePublished":false,"dateModified":false,"isAccessibleForFree":false,"isPartOf":{"@type":[],"name":false,"productID":false},"discussionUrl":false,"license":false,"author":{"@type":false,"name":false,"description":false,"sameAs":false,"image":{"@type":false,"url":false},"givenName":false,"familyName":false,"alternateName":false,"publishingPrinciples":false},"publisher":{"@type":false,"name":false,"description":false,"sameAs":false,"logo":{"@type":false,"url":false},"publishingPrinciples":false},"editor":{"@type":false,"name":false,"description":false,"sameAs":false,"image":{"@type":false,"url":false},"givenName":false,"familyName":false,"alternateName":false,"publishingPrinciples":false}},"twitterObj":false,"status":200,"metadata":{"author":false,"title":"Patterns for Privacy by Design in Javascript APIs","description":false,"canonical":"http://darobin.github.io/api-design-privacy/api-design-privacy.html","keywords":[],"image":"contacts-picker.png","firstParagraph":"\n        This document provides some background on the threats to users' privacy that Javascript APIs help create\n        on the Web, and provides some patterns to mitigate such threats at the API design level. Its primary\n        audience is therefore people involved in the definition and implementation inside user agents of such APIs.\n      "},"dublinCore":{},"opengraph":{"title":false,"description":false,"url":false,"site_name":false,"locale":false,"type":false,"typeObject":{"published_time":false,"modified_time":false,"author":false,"publisher":false,"section":false,"tag":[]},"image":false},"twitter":{"site":false,"description":false,"card":false,"creator":false,"title":false,"image":false},"archivedData":{"link":false,"wayback":false}}}