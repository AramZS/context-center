{"initialLink":"https://mikewest.github.io/http-state-tokens/draft-west-http-state-tokens.html","sanitizedLink":"https://mikewest.github.io/http-state-tokens/draft-west-http-state-tokens.html","finalLink":"https://mikewest.github.io/http-state-tokens/draft-west-http-state-tokens.html","htmlEmbed":"<script>window.contexterSetup=window.contexterSetup||function(){window.contexterSetupComplete=!0;class ContexterLink extends HTMLAnchorElement{constructor(){super()}connectedCallback(){this.setAttribute(\"target\",\"_blank\")}}customElements.define(\"contexter-link\",ContexterLink,{extends:\"a\"}),customElements.define(\"contexter-inner\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__inner\"}}),customElements.define(\"contexter-thumbnail\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__thumbnail\"}}),customElements.define(\"contexter-byline\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__byline\"}}),customElements.define(\"contexter-keywordset\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__keywordset\"}}),customElements.define(\"contexter-linkset\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__linkset\"}}),customElements.define(\"contexter-meta\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__meta\"}}),customElements.define(\"contexter-summary\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"p-summary entry-summary\"}}),customElements.define(\"contexter-box-head\",class extends HTMLElement{constructor(){super()}connectedCallback(){this.className=\"contexter-box__head\"}}),customElements.define(\"contexter-box-inner\",class extends HTMLElement{constructor(){super()}connectedCallback(){}});class ContexterBox extends HTMLElement{constructor(){super(),this.first=!0,this.shadow=this.attachShadow({mode:\"open\"})}connectedCallback(){if(this.first){this.first=!1;var style=document.createElement(\"style\"),lightDomStyle=(style.innerHTML=`:host {--background: #f5f6f7;--border: darkblue;--blue: #0000ee;--font-color: black;--inner-border: black;font-family: Franklin,Arial,Helvetica,sans-serif;font-size: 14px;background: var(--background);width: 600px;color: var(--font-color);min-height: 90px;display: block;padding: 8px;border: 1px solid var(--border);cursor: pointer;box-sizing: border-box;margin: 6px;contain: content;margin: 6px auto;}// can only select top-level nodes with slotted::slotted(*) {max-width: 100%;display:block;}::slotted([slot=thumbnail]) {max-width: 100%;display:block;}::slotted([slot=header]) {width: 100%;font-size: 1.25rem;font-weight: bold;display:block;margin-bottom: 6px;}::slotted([slot=author]) {max-width: 50%;font-size: 12px;display:inline-block;float: left;}::slotted([slot=time]) {max-width: 50%;font-size: 12px;display:inline-block;float: right;}::slotted([slot=summary]) {width: 100%;margin-top: 6px;padding: 10px 2px;border-top: 1px solid var(--inner-border);font-size: 15px;display:inline-block;margin-bottom: 6px;}contexter-meta {height: auto;margin-bottom: 4px;width: 100%;display: grid;position: relative;min-height: 16px;grid-template-columns: repeat(2, 1fr);}::slotted([slot=keywords]) {width: 80%;padding: 2px 4px;border-top: 1px solid var(--inner-border);font-size: 11px;display: block;float: right;font-style: italic;text-align: right;grid-column: 2/2;grid-row: 1;align-self: end;justify-self: end;}::slotted([slot=keywords]):empty {border-top: 0px solid var(--inner-border);}::slotted([slot=archive-link]) {font-size: 1em;display: inline;}::slotted([slot=archive-link])::after {content: \"|\";display: inline;color: var(--font-color);text-decoration: none;margin: 0 .5em;}::slotted([slot=read-link]) {font-size: 1em;display: inline;}contexter-linkset {width: 80%;padding: 2px 4px;font-size: 13px;float: left;font-weight: bold;grid-row: 1;grid-column: 1/2;align-self: end;justify-self: start;}/* Extra small devices (phones, 600px and down) */@media only screen and (max-width: 600px) {:host {width: 310px;}}/* Small devices (portrait tablets and large phones, 600px and up) */@media only screen and (min-width: 600px) {...}/* Medium devices (landscape tablets, 768px and up) */@media only screen and (min-width: 768px) {...}/* Large devices (laptops/desktops, 992px and up) */@media only screen and (min-width: 992px) {...}/* Extra large devices (large laptops and desktops, 1200px and up) */@media only screen and (min-width: 1200px) {...}@media (prefers-color-scheme: dark){:host {--background: #354150;--border: #1f2b37;--blue: #55b0ff;--font-color: #ffffff;--inner-border: #787a7c;background: var(--background);border: 1px solid var(--border)}}`,document.createElement(\"style\"));lightDomStyle.innerHTML=`contexter-box {contain: content;}contexter-box .read-link {font-weight: bold;}contexter-box a {color: #0000ee;}contexter-box img {width: 100%;border: 0;padding: 0;margin: 0;}/* Extra small devices (phones, 600px and down) */@media only screen and (max-width: 600px) {...}/* Small devices (portrait tablets and large phones, 600px and up) */@media only screen and (min-width: 600px) {...}/* Medium devices (landscape tablets, 768px and up) */@media only screen and (min-width: 768px) {...}/* Large devices (laptops/desktops, 992px and up) */@media only screen and (min-width: 992px) {...}/* Extra large devices (large laptops and desktops, 1200px and up) */@media only screen and (min-width: 1200px) {...}@media (prefers-color-scheme: dark){contexter-box a {color: #55b0ff;}}`,this.appendChild(lightDomStyle),this.shadow.appendChild(style);const innerContainer=document.createElement(\"contexter-box-inner\"),innerSlotThumbnail=(this.shadow.appendChild(innerContainer),document.createElement(\"slot\")),innerSlotHeader=(innerSlotThumbnail.name=\"thumbnail\",innerContainer.appendChild(innerSlotThumbnail),document.createElement(\"slot\")),innerSlotAuthor=(innerSlotHeader.name=\"header\",innerContainer.appendChild(innerSlotHeader),document.createElement(\"slot\")),innerSlotTime=(innerSlotAuthor.name=\"author\",innerContainer.appendChild(innerSlotAuthor),document.createElement(\"slot\")),innerSlotSummary=(innerSlotTime.name=\"time\",innerContainer.appendChild(innerSlotTime),document.createElement(\"slot\")),metaContainer=(innerSlotSummary.name=\"summary\",innerContainer.appendChild(innerSlotSummary),document.createElement(\"contexter-meta\")),innerSlotInfo=(innerContainer.appendChild(metaContainer),document.createElement(\"slot\")),linkContainer=(innerSlotInfo.name=\"keywords\",metaContainer.appendChild(innerSlotInfo),document.createElement(\"contexter-linkset\")),innerSlotArchiveLink=(metaContainer.appendChild(linkContainer),document.createElement(\"slot\")),innerSlotReadLink=(innerSlotArchiveLink.name=\"archive-link\",linkContainer.appendChild(innerSlotArchiveLink),document.createElement(\"slot\"));innerSlotReadLink.name=\"read-link\",linkContainer.appendChild(innerSlotReadLink),this.className=\"contexter-box\",this.onclick=e=>{if(!e.target.className.includes(\"read-link\")&&!e.target.className.includes(\"title-link\")){const mainLinks=this.querySelectorAll(\"a.main-link\");mainLinks[0].click()}}}}}customElements.define(\"contexter-box\",ContexterBox)},window.contexterSetupComplete||window.contexterSetup();</script><contexter-box class=\"link-card h-entry hentry\" itemscope=\"\" itemtype=\"https://schema.org/CreativeWork\"><contexter-thumbnail class=\"thumbnail\" slot=\"thumbnail\"></contexter-thumbnail><contexter-box-head slot=\"header\" class=\"p-name entry-title\" itemprop=\"headline\"><contexter-box-head slot=\"header\" class=\"p-name entry-title\" itemprop=\"headline\"><a is=\"contexter-link\" href=\"https://mikewest.github.io/http-state-tokens/draft-west-http-state-tokens.html\" itemprop=\"url\">HTTP State Tokens</a></contexter-box-head></contexter-box-head><time class=\"dt-published published\" slot=\"time\" itemprop=\"datePublished\" datetime=\"2022-04-05T17:38:39.672Z\">3/5/2022</time><contexter-summary class=\"p-summary entry-summary\" itemprop=\"abstract\" slot=\"summary\"><p>This document describes a mechanism which allows HTTP servers to maintain stateful sessions with HTTP user agents. It aims to address some of the security and privacy considerations which have been identified in existing state management mechanisms, providing developers with a well-lit path towards our current understanding of best practice.</p></contexter-summary><contexter-keywordset itemprop=\"keywords\" slot=\"keywords\"></contexter-keywordset><a is=\"contexter-link\" href=\"https://mikewest.github.io/http-state-tokens/draft-west-http-state-tokens.html\" class=\"read-link main-link\" itemprop=\"sameAs\" slot=\"read-link\">Read</a></contexter-box>","linkId":"7453c83a184708033c19269a13f0a6dc13cb008a","data":{"originalLink":"https://mikewest.github.io/http-state-tokens/draft-west-http-state-tokens.html","sanitizedLink":"https://mikewest.github.io/http-state-tokens/draft-west-http-state-tokens.html","canonical":"https://mikewest.github.io/http-state-tokens/draft-west-http-state-tokens.html","htmlText":"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \n  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n\n<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n<head profile=\"http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/\">\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=us-ascii\" />\n\n  <title>HTTP State Tokens</title>\n\n  \n<style type=\"text/css\">/*<![CDATA[*/\n\nbody {\n  font: 16px \"Helvetica Neue\",\"Open Sans\",Helvetica,Calibri,sans-serif;\n  color: #333;\n  font-size-adjust: 0.5;\n  line-height: 24px;\n  margin: 75px auto;\n  max-width: 624px;\n  padding: 0 5px;\n}\n\n.title, .filename, h1, h2, h3, h4, h5 {\n  font: 16px \"Roboto Condensed\",\"Helvetica Neue\",\"Open Sans\",Helvetica,Calibri,sans-serif;\n  font-size-adjust: 0.5;\n  font-weight: bold;\n  color: #333;\n  line-height: 100%;\n  margin: 1.2em 0 0.3em;\n}\n.title, #rfc\\.title h1 { font-size: 32px; }\nh1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }\nh3, section h4, h4, section h5 { font-size: 16px; }\nh1 a[href], h2 a[href], h3 a[href], h4 a[href] {\n  color: #333;\n}\n\ntable {\n  margin-left: 0em;\n  border-collapse: collapse;\n}\nth {\n  text-align: left;\n  border-bottom: 2px solid #ddd;\n}\ntd {\n  border-top: 1px solid #ddd;\n  vertical-align: top;\n}\ntr:nth-child(2n+1) > td,\ntr:nth-child(2n+1) > th {\n  background-color: #f9f9f9;\n}\ntd.reference {\n  max-width: 200px;\n  border-top: none;\n  padding-right: 1em;\n}\n.right {\n  text-align: right;\n}\n\n\ntable.header, table#rfc\\.headerblock {\n  width: 100%;\n}\ntable.header td, table#rfc\\.headerblock td {\n  border: none;\n  background-color: transparent;\n  color: black;\n  padding: 0;\n}\n.filename {\n  display: block;\n  color: rgb(119, 119, 119);\n  font-size: 20px;\n  font-weight: normal;\n  line-height: 100%;\n  margin: 10px 0 32px;\n}\n#rfc\\.abstract+p, #rfc\\.abstract p {\n  font-size: 20px;\n  line-height: 28px;\n}\n\nsamp, tt, code, pre, span.tt {\n  font: 13.5px Consolas, monospace;\n  font-size-adjust: none;\n}\npre {\n  background-color: #eee;\n  border: 1px solid #ddd;\n  overflow-x: auto;\n  padding: 5px;\n  margin: 5px;\n}\n.figure, caption {\n  font-style: italic;\n  margin: 0 1.5em;\n  text-align: left;\n}\n\naddress {\n  margin: 16px 2px;\n  line-height: 20px;\n}\n.vcard {\n  font-style: normal;\n}\n.vcardline {\n  display: block;\n}\n.vcardline .fn, address b {\n  font-weight: normal;\n}\n.vcardline .hidden {\n  display: none;\n}\n\ndl {\n  margin-left: 1em;\n}\ndl.dl-horizontal: {\n  margin-left: 0;\n}\ndl > dt {\n  float: left;\n  margin-right: 1em;\n}\ndl.nohang > dt {\n  float: none;\n}\ndl > dd {\n  margin-bottom: .5em;\n}\ndl.compact > dd {\n  margin-bottom: 0em;\n}\ndl > dd > dl {\n  margin-top: 0.5em;\n  margin-bottom: 0em;\n}\nul.empty {\n  list-style-type: none;\n}\nul.empty li {\n  margin-top: .5em;\n}\n\nhr {\n  border: 0;\n  border-top: 1px solid #eee;\n}\nhr.noprint {\n  display: none;\n}\n\na {\n  text-decoration: none;\n}\na[href] {\n  color: #2a6496;\n}\na[href]:hover {\n  background-color: #eee;\n}\n\np, ol, ul, li {\n  padding: 0;\n}\np {\n  margin: 0.5em 0;\n}\nol, ul {\n  margin: 0.2em 0 0.2em 2em;\n}\nli {\n  margin: 0.2em 0;\n}\naddress {\n  font-style: normal;\n}\n\nul.toc ul {\n  margin: 0 0 0 2em;\n}\nul.toc li {\n  list-style: none;\n  margin: 0;\n}\n\n@media screen and (min-width: 924px) {\n  body {\n    padding-right: 350px;\n  }\n  body>ul.toc, body>#rfc\\.toc {\n    position: fixed;\n    bottom: 0;\n    right: 0;\n    right: calc(50vw - 500px);\n    width: 300px;\n    z-index: 1;\n    overflow: auto;\n    overscroll-behavior: contain;\n  }\n  body>#rfc\\.toc {\n    top: 55px;\n  }\n  body>ul.toc {\n    top: 100px;\n  }\n\n  ul.toc {\n    margin: 0 0 0 4px;\n    font-size: 12px;\n    line-height: 20px;\n  }\n  ul.toc ul {\n    margin-left: 1.2em;\n  }\n}\n\n.github-fork-ribbon-wrapper {\n  display: none;\n}\n@media screen and (min-width: 800px) {\n  /* \"Fork me on GitHub\" CSS ribbon based on\n   * https://github.com/simonwhitaker/github-fork-ribbon-css\n   */\n  .github-fork-ribbon {\n    position: absolute;\n    padding: 2px 0;\n    background-color: #a00;\n    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));\n    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);\n    font: 700 12px \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n\n    pointer-events: auto;\n\n    top: 38px;\n    right: -45px;\n\n    transform: rotate(45deg);\n  }\n\n  .github-fork-ribbon a[href],\n  .github-fork-ribbon a[href]:hover {\n    color: #fff;\n    background-color: transparent;\n    text-decoration: none;\n    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);\n    text-align: center;\n\n    width: 190px;\n    line-height: 18px;\n\n    display: inline-block;\n    padding: 2px 0;\n\n    border: 1.5px dotted #fff;\n    border-color: rgba(255, 255, 255, 0.6);\n  }\n\n  .github-fork-ribbon-wrapper {\n    display: block;\n    width: 130px;\n    height: 130px;\n    position: absolute;\n    overflow: hidden;\n    top: 0; right: 0;\n    z-index: 2;\n    pointer-events: none;\n  }\n}\n@media screen and (min-width: 1000px) {\n  .github-fork-ribbon-wrapper {\n    position: fixed;\n  }\n  /*]]>*/</style>\n  <meta name=\"viewport\" content=\"initial-scale=1.0\">\n\n\n  <link href=\"#rfc.toc\" rel=\"Contents\">\n<link href=\"#rfc.section.1\" rel=\"Chapter\" title=\"1 Introduction\">\n<link href=\"#rfc.section.1.1\" rel=\"Chapter\" title=\"1.1 Wait. Don&#8217;t we already have cookies?\">\n<link href=\"#rfc.section.1.2\" rel=\"Chapter\" title=\"1.2 No. Really. We have cookies today. Why do we need this new thing?\">\n<link href=\"#rfc.section.1.3\" rel=\"Chapter\" title=\"1.3 Examples\">\n<link href=\"#rfc.section.2\" rel=\"Chapter\" title=\"2 Conventions\">\n<link href=\"#rfc.section.2.1\" rel=\"Chapter\" title=\"2.1 Conformance\">\n<link href=\"#rfc.section.2.2\" rel=\"Chapter\" title=\"2.2 Syntax\">\n<link href=\"#rfc.section.3\" rel=\"Chapter\" title=\"3 Infrastructure\">\n<link href=\"#rfc.section.3.1\" rel=\"Chapter\" title=\"3.1 HTTP State Tokens\">\n<link href=\"#rfc.section.3.2\" rel=\"Chapter\" title=\"3.2 Requests and Responses\">\n<link href=\"#rfc.section.3.3\" rel=\"Chapter\" title=\"3.3 Token Storage\">\n<link href=\"#rfc.section.4\" rel=\"Chapter\" title=\"4 Syntax\">\n<link href=\"#rfc.section.4.1\" rel=\"Chapter\" title=\"4.1 The &#8216;Sec-Http-State&#8217; HTTP Header Field\">\n<link href=\"#rfc.section.4.2\" rel=\"Chapter\" title=\"4.2 The &#8216;Sec-Http-State-Options&#8217; HTTP Header Field\">\n<link href=\"#rfc.section.5\" rel=\"Chapter\" title=\"5 Delivering HTTP State Tokens\">\n<link href=\"#rfc.section.5.1\" rel=\"Chapter\" title=\"5.1 Attach HTTP State Tokens to a request\">\n<link href=\"#rfc.section.5.2\" rel=\"Chapter\" title=\"5.2 Generate a request&#8217;s signature\">\n<link href=\"#rfc.section.6\" rel=\"Chapter\" title=\"6 Configuring HTTP State Tokens\">\n<link href=\"#rfc.section.7\" rel=\"Chapter\" title=\"7 Security and Privacy Considerations\">\n<link href=\"#rfc.section.7.1\" rel=\"Chapter\" title=\"7.1 Confidentiality and Integrity\">\n<link href=\"#rfc.section.7.2\" rel=\"Chapter\" title=\"7.2 Signed Sessions\">\n<link href=\"#rfc.section.7.3\" rel=\"Chapter\" title=\"7.3 User Control\">\n<link href=\"#rfc.section.7.4\" rel=\"Chapter\" title=\"7.4 Lifetime\">\n<link href=\"#rfc.section.7.5\" rel=\"Chapter\" title=\"7.5 Ambient Authority and Cross-Site Delivery\">\n<link href=\"#rfc.section.8\" rel=\"Chapter\" title=\"8 Implementation Considerations\">\n<link href=\"#rfc.section.8.1\" rel=\"Chapter\" title=\"8.1 Notifying developers on token reset\">\n<link href=\"#rfc.section.9\" rel=\"Chapter\" title=\"9 IANA Considerations\">\n<link href=\"#rfc.section.9.1\" rel=\"Chapter\" title=\"9.1 Header Field Registry\">\n<link href=\"#rfc.references\" rel=\"Chapter\" title=\"10 References\">\n<link href=\"#rfc.references.1\" rel=\"Chapter\" title=\"10.1 Normative References\">\n<link href=\"#rfc.references.2\" rel=\"Chapter\" title=\"10.2 Informative References\">\n<link href=\"#rfc.appendix.A\" rel=\"Chapter\" title=\"A Acknowledgements\">\n<link href=\"#rfc.appendix.B\" rel=\"Chapter\" title=\"B Changes\">\n<link href=\"#rfc.authors\" rel=\"Chapter\">\n\n\n  <meta name=\"generator\" content=\"xml2rfc version 2.22.2 - https://tools.ietf.org/tools/xml2rfc\" />\n  <link rel=\"schema.dct\" href=\"http://purl.org/dc/terms/\" />\n\n  <meta name=\"dct.creator\" content=\"West, M.\" />\n  <meta name=\"dct.identifier\" content=\"urn:ietf:id:draft-west-http-state-tokens-latest\" />\n  <meta name=\"dct.issued\" scheme=\"ISO8601\" content=\"2019-01\" />\n  <meta name=\"dct.abstract\" content=\"This document describes a mechanism which allows HTTP servers to maintain stateful sessions with HTTP user agents. It aims to address some of the security and privacy considerations which have been identified in existing state management mechanisms, providing developers with a well-lit path towards our current understanding of best practice.\" />\n  <meta name=\"description\" content=\"This document describes a mechanism which allows HTTP servers to maintain stateful sessions with HTTP user agents. It aims to address some of the security and privacy considerations which have been identified in existing state management mechanisms, providing developers with a well-lit path towards our current understanding of best practice.\" />\n\n</head>\n\n<body>\n\n  <table class=\"header\">\n    <tbody>\n    \n    \t<tr>\n<td class=\"left\">Network Working Group</td>\n<td class=\"right\">M. West</td>\n</tr>\n<tr>\n<td class=\"left\">Internet-Draft</td>\n<td class=\"right\">Google</td>\n</tr>\n<tr>\n<td class=\"left\">Intended status: Standards Track</td>\n<td class=\"right\">April 1, 2019</td>\n</tr>\n<tr>\n<td class=\"left\">Expires: October 3, 2019</td>\n<td class=\"right\"></td>\n</tr>\n\n    \t\n    </tbody>\n  </table>\n\n  <p class=\"title\">HTTP State Tokens<br />\n  <span class=\"filename\">draft-west-http-state-tokens-latest</span></p>\n  \n  <h1 id=\"rfc.abstract\"><a href=\"#rfc.abstract\">Abstract</a></h1>\n<p>This document describes a mechanism which allows HTTP servers to maintain stateful sessions with HTTP user agents. It aims to address some of the security and privacy considerations which have been identified in existing state management mechanisms, providing developers with a well-lit path towards our current understanding of best practice.</p>\n<h1 id=\"rfc.status\"><a href=\"#rfc.status\">Status of This Memo</a></h1>\n<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>\n<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>\n<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as \"work in progress.\"</p>\n<p>This Internet-Draft will expire on October 3, 2019.</p>\n<h1 id=\"rfc.copyrightnotice\"><a href=\"#rfc.copyrightnotice\">Copyright Notice</a></h1>\n<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>\n<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>\n\n  \n  <hr class=\"noprint\" />\n  <h1 class=\"np\" id=\"rfc.toc\"><a href=\"#rfc.toc\">Table of Contents</a></h1>\n  <ul class=\"toc\">\n\n  \t<li>1.   <a href=\"#rfc.section.1\">Introduction</a>\n</li>\n<ul><li>1.1.   <a href=\"#rfc.section.1.1\">Wait. Don&#8217;t we already have cookies?</a>\n</li>\n<li>1.2.   <a href=\"#rfc.section.1.2\">No. Really. We have cookies today. Why do we need this new thing?</a>\n</li>\n<li>1.3.   <a href=\"#rfc.section.1.3\">Examples</a>\n</li>\n</ul><li>2.   <a href=\"#rfc.section.2\">Conventions</a>\n</li>\n<ul><li>2.1.   <a href=\"#rfc.section.2.1\">Conformance</a>\n</li>\n<li>2.2.   <a href=\"#rfc.section.2.2\">Syntax</a>\n</li>\n</ul><li>3.   <a href=\"#rfc.section.3\">Infrastructure</a>\n</li>\n<ul><li>3.1.   <a href=\"#rfc.section.3.1\">HTTP State Tokens</a>\n</li>\n<li>3.2.   <a href=\"#rfc.section.3.2\">Requests and Responses</a>\n</li>\n<li>3.3.   <a href=\"#rfc.section.3.3\">Token Storage</a>\n</li>\n</ul><li>4.   <a href=\"#rfc.section.4\">Syntax</a>\n</li>\n<ul><li>4.1.   <a href=\"#rfc.section.4.1\">The &#8216;Sec-Http-State&#8217; HTTP Header Field</a>\n</li>\n<li>4.2.   <a href=\"#rfc.section.4.2\">The &#8216;Sec-Http-State-Options&#8217; HTTP Header Field</a>\n</li>\n</ul><li>5.   <a href=\"#rfc.section.5\">Delivering HTTP State Tokens</a>\n</li>\n<ul><li>5.1.   <a href=\"#rfc.section.5.1\">Attach HTTP State Tokens to a request</a>\n</li>\n<li>5.2.   <a href=\"#rfc.section.5.2\">Generate a request&#8217;s signature</a>\n</li>\n</ul><li>6.   <a href=\"#rfc.section.6\">Configuring HTTP State Tokens</a>\n</li>\n<li>7.   <a href=\"#rfc.section.7\">Security and Privacy Considerations</a>\n</li>\n<ul><li>7.1.   <a href=\"#rfc.section.7.1\">Confidentiality and Integrity</a>\n</li>\n<li>7.2.   <a href=\"#rfc.section.7.2\">Signed Sessions</a>\n</li>\n<li>7.3.   <a href=\"#rfc.section.7.3\">User Control</a>\n</li>\n<li>7.4.   <a href=\"#rfc.section.7.4\">Lifetime</a>\n</li>\n<li>7.5.   <a href=\"#rfc.section.7.5\">Ambient Authority and Cross-Site Delivery</a>\n</li>\n</ul><li>8.   <a href=\"#rfc.section.8\">Implementation Considerations</a>\n</li>\n<ul><li>8.1.   <a href=\"#rfc.section.8.1\">Notifying developers on token reset</a>\n</li>\n</ul><li>9.   <a href=\"#rfc.section.9\">IANA Considerations</a>\n</li>\n<ul><li>9.1.   <a href=\"#rfc.section.9.1\">Header Field Registry</a>\n</li>\n</ul><li>10.   <a href=\"#rfc.references\">References</a>\n</li>\n<ul><li>10.1.   <a href=\"#rfc.references.1\">Normative References</a>\n</li>\n<li>10.2.   <a href=\"#rfc.references.2\">Informative References</a>\n</li>\n</ul><li>Appendix A.   <a href=\"#rfc.appendix.A\">Acknowledgements</a>\n</li>\n<li>Appendix B.   <a href=\"#rfc.appendix.B\">Changes</a>\n</li>\n<li><a href=\"#rfc.authors\">Author's Address</a>\n</li>\n\n\n  </ul>\n\n  <h1 id=\"rfc.section.1\">\n<a href=\"#rfc.section.1\">1.</a> <a href=\"#introduction\" id=\"introduction\">Introduction</a>\n</h1>\n<p id=\"rfc.section.1.p.1\">This document defines a state-management mechanism for HTTP that allows clients to create and persist origin-bound session identifiers that can be delivered to servers in order to enable stateful interaction. In a nutshell, each user agent will generate a single token per secure origin, and will deliver it as a <samp>Sec-Http-State</samp> structured header along with requests to that origin (defined in <a href=\"#sec-http-state\" class=\"xref\">Section 4.1</a> and <a href=\"#delivery\" class=\"xref\">Section 5</a>).</p>\n<p id=\"rfc.section.1.p.2\">Servers can configure this token&#8217;s characteristics via a <samp>Sec-Http-State-Options</samp> response header (defined in <a href=\"#sec-http-state-options\" class=\"xref\">Section 4.2</a> and <a href=\"#config\" class=\"xref\">Section 6</a>).</p>\n<p id=\"rfc.section.1.p.3\">That&#8217;s it.</p>\n<h1 id=\"rfc.section.1.1\">\n<a href=\"#rfc.section.1.1\">1.1.</a> <a href=\"#wait-dont-we-already-have-cookies\" id=\"wait-dont-we-already-have-cookies\">Wait. Don&#8217;t we already have cookies?</a>\n</h1>\n<p id=\"rfc.section.1.1.p.1\">Cookies <a href=\"#RFC6265\" class=\"xref\">[RFC6265]</a> are indeed a pervasive HTTP state management mechanism in the status quo, and they enable practically everything interesting on the web today. That said, cookies have some issues: they&#8217;re hard to use securely, they add substantial weight to users&#8217; outgoing requests, and they enable tracking users&#8217; activity across the web in potentially surprising ways.</p>\n<p id=\"rfc.section.1.1.p.2\">The mechanism proposed in this document aims at a more minimal and opinionated construct which takes inspiration from some of cookies&#8217; optional characteristics. In particular:</p>\n<p></p>\n\n<ol>\n<li>The client controls the token&#8217;s value, not the server.</li>\n<li>The token will only be available to the network layer, not to JavaScript (including network-like JavaScript, such as Service Workers).</li>\n<li>The user agent will generate only one token per origin, and will only expose the token to the origin for which it was generated.</li>\n<li>Tokens will not be generated for, or delivered to, non-secure origins.</li>\n<li>By default, token delivery and configuration is constrained to same-site requests.</li>\n<li>Each token persists for one hour after generation by default. This default expiration time can be overwritten by servers, and tokens can be reset at any time by servers, users, or user agents.</li>\n</ol>\n<p id=\"rfc.section.1.1.p.4\">These distinctions might not be appropriate for all use cases, but seem like a reasonable set of defaults. For folks for whom these defaults aren&#8217;t good enough, we&#8217;ll provide developers with a few control points that can be triggered via a <samp>Sec-HTTP-State-Options</samp> HTTP response header, described in <a href=\"#sec-http-state-options\" class=\"xref\">Section 4.2</a>.</p>\n<h1 id=\"rfc.section.1.2\">\n<a href=\"#rfc.section.1.2\">1.2.</a> <a href=\"#no-really-we-have-cookies-today-why-do-we-need-this-new-thing\" id=\"no-really-we-have-cookies-today-why-do-we-need-this-new-thing\">No. Really. We have cookies today. Why do we need this new thing?</a>\n</h1>\n<p id=\"rfc.section.1.2.p.1\">We do have cookies. And we&#8217;ve defined a number of extensions to cookies to blunt some of their sharper edges: the <samp>HttpOnly</samp> attribute, the <samp>Secure</samp> attribute, <samp>SameSite</samp>, prefixes like <samp>__Host-</samp> and <samp>__Secure-</samp>, and so on. It&#8217;s reasonable to suggest that pushing developers towards these existing flags on our existing state management primitive is the right way forward.</p>\n<p id=\"rfc.section.1.2.p.2\">A counterpoint is that we&#8217;re collectively pretty bad at helping developers understand the risks that might lead them to adopt The Good Cookie Syntax(tm) above. Adoption of these features has been quite slow. The <samp>Secure</samp> flag, for example, has been around since at least 1997 <a href=\"#RFC2109\" class=\"xref\">[RFC2109]</a>, and is hovering around 9% adoption based on data gathered from Chrome&#8217;s telemetry in March, 2019. In that dataset, cookies&#8217; other properties are set as follows:</p>\n<p></p>\n\n<ul>\n<li>~6.8% of cookies are set with <samp>HttpOnly</samp>.</li>\n<li>~5.5% are set with <samp>Secure</samp>.</li>\n<li>~3.1% are set with <samp>HttpOnly; Secure</samp>.</li>\n<li>~0.06% are set with <samp>SameSite=*; Secure</samp>.</li>\n<li>~0.05% are set with <samp>SameSite=*</samp>.</li>\n<li>~0.03% are set with <samp>HttpOnly; Secure; SameSite=*</samp>.</li>\n<li>~0.006% are set with <samp>SameSite=*; HttpOnly</samp>.</li>\n<li>~0.005% are set with a <samp>__Secure-</samp> prefix.</li>\n<li>~0.01% are set with a <samp>__Host-</samp> prefix.</li>\n</ul>\n<p id=\"rfc.section.1.2.p.4\">In total:</p>\n<p></p>\n\n<ul>\n<li>~9.9% of cookies are marked as <samp>HttpOnly</samp>.</li>\n<li>~8.8% of cookies are marked as <samp>Secure</samp>.</li>\n<li>~0.1% of cookies are marked as <samp>SameSite</samp>.</li>\n<li>~84.2% of cookies use none of these features.</li>\n</ul>\n<p id=\"rfc.section.1.2.p.6\">This document&#8217;s underlying assumption is that it&#8217;s going to be easier to teach developers about a crazy new thing that&#8217;s secure by default than it would be to convince them to change their <samp>Set-Cookie</samp> headers to be more like <samp>__Host-name=value; HttpOnly; Secure; SameSite=Lax; Path=/</samp>. A new thing resets expectations in a way that vastly exceeds the impact of explanations about the the four attributes that must be used, the one attribute that must not be used, and the weird naming convention that ought to be adopted.</p>\n<h1 id=\"rfc.section.1.3\">\n<a href=\"#rfc.section.1.3\">1.3.</a> <a href=\"#examples\" id=\"examples\">Examples</a>\n</h1>\n<p id=\"rfc.section.1.3.p.1\">User agents can deliver HTTP state tokens to a server in a <samp>Sec-Http-State</samp> header. For example, if a user agent has generated a token bound to <samp>https://example.com/</samp> whose base64 encoding is <samp>hB2RfWaGyNk60sjHze5DzGYjSnL7tRF2HWSBx6J1o4k=</samp> (<a href=\"#RFC4648\" class=\"xref\">[RFC4648]</a>, Section 4), then it would generate the following header when delivering the token along with requests to <samp>https://example.com/</samp>:</p>\n<pre>\nSec-Http-State: token=*hB2RfWaGyNk60sjHze5DzGYjSnL7tRF2HWSBx6J1o4k*\n</pre>\n<p id=\"rfc.section.1.3.p.2\">The server can control certain aspects of the token&#8217;s delivery by responding to requests with a <samp>Sec-Http-State-Options</samp> header:</p>\n<pre>\nSec-Http-State-Options: max-age=3600, key=*b7kuUkp...lkRioC2=*\n</pre>\n<h1 id=\"rfc.section.2\">\n<a href=\"#rfc.section.2\">2.</a> <a href=\"#conventions\" id=\"conventions\">Conventions</a>\n</h1>\n<h1 id=\"rfc.section.2.1\">\n<a href=\"#rfc.section.2.1\">2.1.</a> <a href=\"#conformance\" id=\"conformance\">Conformance</a>\n</h1>\n<p id=\"rfc.section.2.1.p.1\">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP&#160;14 <a href=\"#RFC2119\" class=\"xref\">[RFC2119]</a> <a href=\"#RFC8174\" class=\"xref\">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>\n<h1 id=\"rfc.section.2.2\">\n<a href=\"#rfc.section.2.2\">2.2.</a> <a href=\"#syntax\" id=\"syntax\">Syntax</a>\n</h1>\n<p id=\"rfc.section.2.2.p.1\">This document defines two Structured Headers <a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>. In doing so it relies upon the Augmented Backus-Naur Form (ABNF) notation of <a href=\"#RFC5234\" class=\"xref\">[RFC5234]</a> and the OWS rule from <a href=\"#RFC7230\" class=\"xref\">[RFC7230]</a>.</p>\n<h1 id=\"rfc.section.3\">\n<a href=\"#rfc.section.3\">3.</a> <a href=\"#infrastructure\" id=\"infrastructure\">Infrastructure</a>\n</h1>\n<h1 id=\"rfc.section.3.1\">\n<a href=\"#rfc.section.3.1\">3.1.</a> <a href=\"#http-state-tokens\" id=\"http-state-tokens\">HTTP State Tokens</a>\n</h1>\n<p id=\"rfc.section.3.1.p.1\">An HTTP State Token holds a session identifier which allows a user agent to maintain a stateful session with a specific origin, along with associated metadata:</p>\n<p></p>\n\n<ul>\n<li>\n<samp>creation</samp> is a timestamp representing the point in time when the token was created.</li>\n<li>\n<samp>delivery</samp> specifies the initiating contexts from which the token can be delivered. It is an enum of either <samp>same-origin</samp>, <samp>same-site</samp>, or <samp>cross-site</samp>. Unless otherwise specified, its value is <samp>same-site</samp>.</li>\n<li>\n<samp>key</samp> is a server-provided key which can be used to sign requests with which the token is delivered. It is either null, or contains up to 256-bits of binary data. Unless otherwise specified, its value is null.</li>\n<li>\n<samp>max-age</samp> is a number representing the token&#8217;s lifetime in seconds. Unless otherwise specified, its value is <samp>3600</samp> (1 hour).</li>\n<li>\n<samp>value</samp> is the token&#8217;s value (surprising, right?). It contains up to 256-bits of binary data.</li>\n</ul>\n<p id=\"rfc.section.3.1.p.3\">An HTTP State Token is said to be &#8220;expired&#8221; if its <samp>creation</samp> timestamp plus <samp>max-age</samp> seconds is in the past.</p>\n<h1 id=\"rfc.section.3.2\">\n<a href=\"#rfc.section.3.2\">3.2.</a> <a href=\"#requests-and-responses\" id=\"requests-and-responses\">Requests and Responses</a>\n</h1>\n<p id=\"rfc.section.3.2.p.1\">This document relies upon the definitions of &#8220;request&#8221; and &#8220;response&#8221; found in <a href=\"#Fetch\" class=\"xref\">[Fetch]</a>.</p>\n<p id=\"rfc.section.3.2.p.2\">A request&#8217;s delivery scope is <samp>same-origin</samp> if the request&#8217;s initiator and target are exactly the same origin, <samp>same-site</samp> if the request&#8217;s initiator and target are not same-origin but share a registrable domain (e.g. <samp>https://www.example.com/</samp> and <samp>https://not-www.example.com/</samp>), and <samp>cross-site</samp> otherwise. The following algorithm spells this relationship out more formally:</p>\n<p></p>\n\n<ol>\n<li>If the request was generated by the user agent as a response to direct user interaction with the user agent (e.g. the user typed an address into the agent&#8217;s address bar, clicked a bookmark, or etc.), return <samp>same-origin</samp>.</li>\n<li>Let <samp>request-origin</samp> be the request&#8217;s <samp>origin</samp>, and <samp>target-origin</samp> be the request&#8217;s <samp>URL</samp>&#8217;s <samp>origin</samp>.</li>\n<li>If <samp>request-origin</samp> is same-origin with <samp>target-origin</samp>, return <samp>same-origin</samp>.</li>\n<li>If <samp>request-origin</samp>&#8217;s registrable domain is the same as <samp>target-origin</samp>&#8217;s registrable domain, return <samp>same-site</samp>.</li>\n<li>Return <samp>cross-site</samp>.</li>\n</ol>\n<h1 id=\"rfc.section.3.3\">\n<a href=\"#rfc.section.3.3\">3.3.</a> <a href=\"#token-storage\" id=\"token-storage\">Token Storage</a>\n</h1>\n<p id=\"rfc.section.3.3.p.1\">User agents MUST keep a list of all the unexpired HTTP State Tokens which have been created. For the purposes of this document, we&#8217;ll assume that user agents keep this list in the form of a map whose keys are origins, and whose values are HTTP State Tokens.</p>\n<p id=\"rfc.section.3.3.p.2\">This map exposes three functions:</p>\n<p></p>\n\n<ul>\n<li>An HTTP State Token can be stored for a given origin. If the origin already exists in the map, the entry&#8217;s value will be overwritten with the new HTTP State Token.</li>\n<li>An origin&#8217;s HTTP State Token can be retrieved. If the origin does not exist in the map, <samp>null</samp> will be returned instead.</li>\n<li>An origin (along with its HTTP State Token) can be deleted from the map.</li>\n</ul>\n<p id=\"rfc.section.3.3.p.4\">The map is initially empty.</p>\n<h1 id=\"rfc.section.3.3.1\">\n<a href=\"#rfc.section.3.3.1\">3.3.1.</a> <a href=\"#generate\" id=\"generate\">Generate an HTTP State Token for an origin</a>\n</h1>\n<p id=\"rfc.section.3.3.1.p.1\">The user agent MUST generate a new HTTP State Token for an origin using an algorithm equivalent to the following:</p>\n<p></p>\n\n<ol>\n<li>Delete <samp>origin</samp> from the user agent&#8217;s token store.</li>\n<li>Let <samp>token</samp> be a newly created HTTP State Token with its properties set as follows:  <ul>\n<li>\n<samp>creation</samp>: The current time.</li>\n<li>\n<samp>delivery</samp>: <samp>same-site</samp>\n</li>\n<li>\n<samp>key</samp>: null</li>\n<li>\n<samp>max-age</samp>: 3600</li>\n<li>\n<samp>value</samp>: 256 cryptographically random bits.</li>\n</ul>\n</li>\n<li>Store <samp>token</samp> in the user agent&#8217;s token store for <samp>origin</samp>.</li>\n<li>If the user agent has defined a <samp>NotifyHostHTTPStateReset(origin)</samp> algorithm, call it with <samp>origin</samp> (see <a href=\"#notify-reset\" class=\"xref\">Section 8.1</a> for more context on this step).</li>\n<li>Return <samp>token</samp>.</li>\n</ol>\n<h1 id=\"rfc.section.4\">\n<a href=\"#rfc.section.4\">4.</a> <a href=\"#syntax-1\" id=\"syntax-1\">Syntax</a>\n</h1>\n<h1 id=\"rfc.section.4.1\">\n<a href=\"#rfc.section.4.1\">4.1.</a> <a href=\"#sec-http-state\" id=\"sec-http-state\">The &#8216;Sec-Http-State&#8217; HTTP Header Field</a>\n</h1>\n<p id=\"rfc.section.4.1.p.1\">The <samp>Sec-Http-State</samp> HTTP header field allows user agents to deliver HTTP state tokens to servers as part of an HTTP request.</p>\n<p><samp>Sec-Http-State</samp> is a Structured Header <a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>. Its value MUST be a dictionary (<a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.1). Its ABNF is:</p>\n<pre>\nSec-Http-State = sh-dictionary\n</pre>\n<p id=\"rfc.section.4.1.p.3\">The dictionary MUST contain:</p>\n<p></p>\n\n<ul><li>Exactly one member whose key is <samp>token</samp>, and whose value is binary content (<a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.9) that encodes the HTTP state token&#8217;s value for the origin to which the header is delivered.  <br><br> If the <samp>token</samp> member contains more than 256 bits of binary content, the member MUST be ignored.</li></ul>\n<p id=\"rfc.section.4.1.p.5\">The dictionary MAY contain:</p>\n<p></p>\n\n<ul><li>Exactly one member whose key is <samp>sig</samp>, and whose value is binary content (<a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.9) that encodes a signature over the token and the request which contains it, using a key previously delivered by the server. This mechanism is described in <a href=\"#sign\" class=\"xref\">Section 5.2</a>.  <br><br> If the <samp>sig</samp> member contains more than 256 bits of binary content, the member MUST be ignored.</li></ul>\n<p id=\"rfc.section.4.1.p.7\">The <samp>Sec-Http-State</samp> header is parsed per the algorithm in Section 4.2 of <a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>. Servers MUST ignore the header if parsing fails, or if the parsed header does not contain a member whose key is <samp>token</samp>.</p>\n<p id=\"rfc.section.4.1.p.8\">User agents will attach a <samp>Sec-Http-State</samp> header to outgoing requests according to the processing rules described in <a href=\"#delivery\" class=\"xref\">Section 5</a>.</p>\n<h1 id=\"rfc.section.4.2\">\n<a href=\"#rfc.section.4.2\">4.2.</a> <a href=\"#sec-http-state-options\" id=\"sec-http-state-options\">The &#8216;Sec-Http-State-Options&#8217; HTTP Header Field</a>\n</h1>\n<p id=\"rfc.section.4.2.p.1\">The <samp>Sec-Http-State-Options</samp> HTTP header field allows servers to deliver configuration information to user agents as part of an HTTP response.</p>\n<p><samp>Sec-Http-State-Options</samp> is a Structured Header <a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>. Its value MUST be a dictionary (<a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.1). Its ABNF is:</p>\n<pre>\nSec-Http-State-Options = sh-dictionary\n</pre>\n<p id=\"rfc.section.4.2.p.3\">The <samp>Sec-Http-State-Options</samp> header is parsed per the algorithm in Section 4.2 of <a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>. User agents MUST ignore the header if parsing fails.</p>\n<p id=\"rfc.section.4.2.p.4\">The dictionary MAY contain:</p>\n<p></p>\n\n<ul>\n<li>Exactly one member whose key is <samp>key</samp>, and whose value is binary content (<a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.10) that encodes an key which can be used to generate a signature over outgoing requests.</li>\n<li>Exactly one member whose key is <samp>delivery</samp>, and whose value is one of the following tokens (<a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.9): <samp>same-origin</samp>, <samp>same-site</samp>, or <samp>cross-site</samp>.  <br><br> If the <samp>delivery</samp> member contains an unknown identifier, the member MUST be ignored.</li>\n<li>Exactly one member whose key is <samp>max-age</samp>, and whose value is an integer (<a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.6) representing the server&#8217;s desired lifetime for its HTTP State Token.  <br><br> If the <samp>max-age</samp> member contains anything other than a positive integer, the member MUST be ignored.</li>\n</ul>\n<p id=\"rfc.section.4.2.p.6\">User agents will process the <samp>Sec-Http-State-Options</samp> header on incoming responses according to the processing rules described in <a href=\"#config\" class=\"xref\">Section 6</a>.</p>\n<h1 id=\"rfc.section.4.2.1\">\n<a href=\"#rfc.section.4.2.1\">4.2.1.</a> <a href=\"#examples-1\" id=\"examples-1\">Examples</a>\n</h1>\n<h1 id=\"rfc.section.4.2.1.1\">\n<a href=\"#rfc.section.4.2.1.1\">4.2.1.1.</a> <a href=\"#cross-site-delivery\" id=\"cross-site-delivery\">Cross-Site Delivery</a>\n</h1>\n<p id=\"rfc.section.4.2.1.1.p.1\">Some servers will require access to their tokens from cross-site contexts (perhaps to support authenticated activity or single-sign on, etc). These servers can request a <samp>cross-site</samp> delivery option by delivering the following header:</p>\n<pre>\nSec-Http-State-Options: delivery=cross-site, ...\n</pre>\n<h1 id=\"rfc.section.4.2.1.2\">\n<a href=\"#rfc.section.4.2.1.2\">4.2.1.2.</a> <a href=\"#token-lifetime\" id=\"token-lifetime\">Token Lifetime</a>\n</h1>\n<p id=\"rfc.section.4.2.1.2.p.1\">Other servers might want their sessions to persist for more than an hour. These servers can request a more reasonable token lifetime lifetime by by delivering the following header:</p>\n<pre>\nSec-Http-State-Options: max-age=2592000, ...\n</pre>\n<p id=\"rfc.section.4.2.1.2.p.2\">Servers may also wish to explicitly trigger the token&#8217;s expiration (upon signout, for instance).  Setting a <samp>max-age</samp> of <samp>0</samp> does the trick:</p>\n<pre>\nSec-Http-State-Options: max-age=0, ...\n</pre>\n<h1 id=\"rfc.section.4.2.1.3\">\n<a href=\"#rfc.section.4.2.1.3\">4.2.1.3.</a> <a href=\"#token-provenance\" id=\"token-provenance\">Token Provenance</a>\n</h1>\n<p id=\"rfc.section.4.2.1.3.p.1\">For some servers, the client-generated token will be enough to maintain state. They can treat it as an opaque session identifier, and bind the user&#8217;s state to it server-side. Other servers will require additional assurance that they can trust the token&#8217;s provenance. To that end, servers can generate a unique key, associate it with the session identifier on the server, and deliver it to the client via an HTTP response header:</p>\n<pre>\nSec-Http-State-Options: key=*ZH0GxtBMWA...nJudhZ8dtz*, ...\n</pre>\n<p id=\"rfc.section.4.2.1.3.p.2\">Clients will store that key, and use it to generate a signature over some set of data that mitigates the risk of token capture:</p>\n<pre>\nSec-HTTP-State:\n    token=*J6BRKa...MonM*,\n    sig=*(HMAC-SHA256(key, token+metadata))*\n</pre>\n<p id=\"rfc.section.4.2.1.3.p.3\">Note: This part in particular is not fully baked, and we need to do some more work to flesh out the threat model (see also Token Binding). Look at it as an area to explore, not a solidly thought-out solution.</p>\n<h1 id=\"rfc.section.5\">\n<a href=\"#rfc.section.5\">5.</a> <a href=\"#delivery\" id=\"delivery\">Delivering HTTP State Tokens</a>\n</h1>\n<p id=\"rfc.section.5.p.1\">User agents deliver HTTP state tokens to servers by appending a <samp>Sec-Http-State</samp> header field to outgoing requests.</p>\n<p id=\"rfc.section.5.p.2\">This specification provides algorithms which are called at the appropriate points in <a href=\"#Fetch\" class=\"xref\">[Fetch]</a> in order to attach <samp>Sec-Http-State</samp> headers to outgoing requests, and to ensure that <samp>Sec-Http-State-Options</samp> headers are correctly processed.</p>\n<h1 id=\"rfc.section.5.1\">\n<a href=\"#rfc.section.5.1\">5.1.</a> <a href=\"#attach\" id=\"attach\">Attach HTTP State Tokens to a request</a>\n</h1>\n<p id=\"rfc.section.5.1.p.1\">The user agent can attach HTTP State Tokens to a given request using an algorithm equivalent to the following. This algorithm is intended to execute as the request is being sent out over the network (after Service Worker processing), perhaps after the <samp>Cookie</samp> header is handled in step 5.17.1 of Section 4.5 of <a href=\"#Fetch\" class=\"xref\">[Fetch]</a>, describing the &#8220;HTTP-network-or-cache fetch&#8221; algorithm:</p>\n<p></p>\n\n<ol>\n<li>If the user agent is configured to suppress explicit identifiers for the request, or if the request&#8217;s URL is not <em>a priori</em> authenticated <a href=\"#Mixed-Content\" class=\"xref\">[Mixed-Content]</a>, then skip the remaining steps in this algorithm, and return without modifying the request.</li>\n<li>Let <samp>target-origin</samp> be the origin of <samp>request</samp>&#8217;s current URL.</li>\n<li>Let <samp>request-token</samp> be the result of retrieving origin&#8217;s token from the user agent&#8217;s token store, or <samp>null</samp> if no such token exists.</li>\n<li>If <samp>request-token</samp> is expired, clear the user agent&#8217;s token store for <samp>target-origin</samp>, and set <samp>request-token</samp> to <samp>null</samp>.</li>\n<li>If <samp>request-token</samp> is <samp>null</samp>, then:  <ol>\n<li>If <samp>request</samp>&#8217;s delivery scope is <samp>cross-site</samp>, return without modifying the request.      <br><br> Note: As the default <samp>delivery</samp> for HTTP State Tokens is <samp>same-site</samp>, we return early rather than generating a token for a cross-site request.</li>\n<li>Set <samp>request-token</samp> to the result of generating an HTTP State Token for <samp>target-origin</samp>, as defined in <a href=\"#generate\" class=\"xref\">Section 3.3.1</a>.</li>\n</ol>\n</li>\n<li>Return without modifying the request if either of the following statements are true:  <ul>\n<li>\n<samp>request-token</samp>&#8217;s <samp>delivery</samp> is <samp>same-origin</samp>, and <samp>request</samp>&#8217;s delivery scope is not <samp>same-origin</samp>.</li>\n<li>\n<samp>request-token</samp>&#8217;s <samp>delivery</samp> is <samp>same-site</samp>, and <samp>request</samp>&#8217;s delivery scope is neither <samp>same-origin</samp> nor <samp>same-site</samp>.</li>\n</ul>\n</li>\n<li>Let <samp>serialized-value</samp> be the base64 encoding (<a href=\"#RFC4648\" class=\"xref\">[RFC4648]</a>, Section 4) of <samp>request-token</samp>&#8217;s value.</li>\n<li>Insert a member into <samp>header-value</samp> whose key is <samp>token</samp> and whose value is <samp>serialized-value</samp>.</li>\n<li>If <samp>request-token</samp>&#8217;s <samp>key</samp> is not null, then insert a member into <samp>header-value</samp> whose key is <samp>sig</samp>, and whose value is the result of executing <a href=\"#sign\" class=\"xref\">Section 5.2</a> on request, <samp>serialized-value</samp>, and <samp>request-token</samp>&#8217;s <samp>key</samp>.</li>\n<li>Append a header to <samp>request</samp>&#8217;s header list whose name is <samp>Sec-Http-State</samp>, and whose value is the result of serializing <samp>header-value</samp> (<a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>, Section 4.1).</li>\n</ol>\n<h1 id=\"rfc.section.5.2\">\n<a href=\"#rfc.section.5.2\">5.2.</a> <a href=\"#sign\" id=\"sign\">Generate a request&#8217;s signature</a>\n</h1>\n<p id=\"rfc.section.5.2.p.1\">If the origin server provides a <samp>key</samp>, the user agent will use it to sign any outgoing requests which target that origin and include an HTTP State Token. Note that the signature is produced before adding the <samp>Sec-Http-State</samp> header to the request.</p>\n<p id=\"rfc.section.5.2.p.2\">Given a request, a base64-encoded token value, and a key:</p>\n<p></p>\n\n<ol>\n<li>Let <samp>cbor-request</samp> be the result of building a CBOR representation <a href=\"#RFC7409\" class=\"xref\">[RFC7409]</a> of the given request, as specified in the first element of the array described in Section 3.2 of <a href=\"#I-D.yasskin-http-origin-signed-responses\" class=\"xref\">[I-D.yasskin-http-origin-signed-responses]</a>.</li>\n<li>Add an item to <samp>cbor-request</samp> which maps the byte string &#8216;:token&#8217; to the byte string containing the given base64-encoded token value.</li>\n<li>Return the result of computing HMAC-SHA256 <a href=\"#RFC2104\" class=\"xref\">[RFC2104]</a> over the canonical CBOR serialization of <samp>cbor-request</samp> (Section 3.4 of <a href=\"#I-D.yasskin-http-origin-signed-responses\" class=\"xref\">[I-D.yasskin-http-origin-signed-responses]</a>), using the given <samp>key</samp>.</li>\n</ol>\n<h1 id=\"rfc.section.5.2.1\">\n<a href=\"#rfc.section.5.2.1\">5.2.1.</a> <a href=\"#example\" id=\"example\">Example</a>\n</h1>\n<p id=\"rfc.section.5.2.1.p.1\">The following request:</p>\n<pre>\nGET / HTTP/1.1\nHost: example.com\nAccept: */*\n</pre>\n<p id=\"rfc.section.5.2.1.p.2\">results in the following CBOR representation (represented using the extended diagnostic notation from Appendix G of <a href=\"#I-D.ietf-cbor-cddl\" class=\"xref\">[I-D.ietf-cbor-cddl]</a>):</p>\n<pre>\n{\n  ':method': 'GET',\n  ':token': 'hB2RfWaGyNk60sjHze5DzGYjSnL7tRF2HWSBx6J1o4k='\n  ':url': 'https://example.com/',\n  'accept': '*/*',\n}\n</pre>\n<h1 id=\"rfc.section.6\">\n<a href=\"#rfc.section.6\">6.</a> <a href=\"#config\" id=\"config\">Configuring HTTP State Tokens</a>\n</h1>\n<p id=\"rfc.section.6.p.1\">Servers configure the HTTP State Token representing a given users&#8217; state by appending a <samp>Sec-Http-State-Options</samp> header field to outgoing responses.</p>\n<p id=\"rfc.section.6.p.2\">User agents MUST process this header on a given response as per the following algorithm, which is intended to be called after the <samp>Set-Cookie</samp> header is handled in step 11.4 of Section 4.6 of <a href=\"#Fetch\" class=\"xref\">[Fetch]</a>, which defines the &#8220;HTTP-network fetch&#8221; algorithm.</p>\n<p></p>\n\n<ol>\n<li>Let <samp>response-origin</samp> be the origin of response&#8217;s URL.</li>\n<li>If the response&#8217;s URL is not <em>a priori</em> authenticated <a href=\"#Mixed-Content\" class=\"xref\">[Mixed-Content]</a>, return without altering <samp>response-origin</samp>&#8217;s HTTP State Token.</li>\n<li>Let <samp>token</samp> be the result of retrieving <samp>response-origin</samp>&#8217;s token from the user agent&#8217;s token store, or <samp>null</samp> if no such token exists.</li>\n<li>If <samp>token</samp> is expired, clear the user agent&#8217;s token store for <samp>response-origin</samp>, and set <samp>token</samp> to <samp>null</samp>.</li>\n<li>If <samp>token</samp> is <samp>null</samp>, then:  <ol>\n<li>If <samp>request</samp>&#8217;s delivery scope is <samp>cross-site</samp>, return without modifying the request.      <br><br> Note: As the default <samp>delivery</samp> for HTTP State Tokens is <samp>same-site</samp>, we return early rather than generating a token for a cross-site request.</li>\n<li>Set <samp>token</samp> to the result of generating an HTTP State Token for <samp>target-origin</samp>, as defined in <a href=\"#generate\" class=\"xref\">Section 3.3.1</a>.</li>\n</ol>\n</li>\n<li>If the response&#8217;s header list contains <samp>Sec-Http-State-Options</samp>, then:  <ol>\n<li>Let <samp>header</samp> be the result of getting response&#8217;s <samp>Sec-Http-State-Options</samp> header, and parsing parsing it per the algorithm in Section 4.2 of <a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>.</li>\n<li>Return without altering <samp>response-origin</samp>&#8217;s HTTP State Token if any of the following conditions hold:      <ul>\n<li>Parsing the header results in failure.</li>\n<li>\n<samp>header</samp> has a member named <samp>key</samp> whose value is not a byte sequence (Section 3.10 of <a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>)</li>\n<li>\n<samp>header</samp> has a member named <samp>delivery</samp> whose value is not one of the following tokens (Section 3.9 of <a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>): &#8220;same-origin&#8221;, &#8220;same-site&#8221;, and &#8220;cross-site&#8221;.</li>\n<li>\n<samp>header</samp> has a member named <samp>max-age</samp> whose value is not a positive integer (Section 3.6 of <a href=\"#I-D.ietf-httpbis-header-structure\" class=\"xref\">[I-D.ietf-httpbis-header-structure]</a>).</li>\n</ul>\n</li>\n<li>If <samp>header</samp> has a member named <samp>key</samp>, set <samp>token</samp>&#8217;s <samp>key</samp> to the member&#8217;s value.</li>\n<li>If <samp>header</samp> has a member named <samp>delivery</samp>, set <samp>token</samp>&#8217;s <samp>delivery</samp> to the member&#8217;s value.</li>\n<li>If <samp>header</samp> has a member named <samp>max-age</samp>:      <ol><li>If the member&#8217;s value is <samp>0</samp>, generate a new HTTP State Token for <samp>response-origin</samp> as defined in <a href=\"#generate\" class=\"xref\">Section 3.3.1</a>.          <br><br> Otherwise, set <samp>token</samp>&#8217;s <samp>max-age</samp> to the member&#8217;s value.</li></ol>\n<p> Note that </p>\n<samp>max-age</samp> is processed last, meaning that any other options specified alongside <samp>max-age=0</samp> will be de facto ignored as a new token is generated, replacing the old.</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"rfc.section.7\">\n<a href=\"#rfc.section.7\">7.</a> <a href=\"#security-and-privacy-considerations\" id=\"security-and-privacy-considerations\">Security and Privacy Considerations</a>\n</h1>\n<p id=\"rfc.section.7.p.1\">HTTP State Tokens aim to mitigate some of the security and privacy drawbacks that decades of implementation experience with cookies have laid bare. It would be worthwhile to skim through the privacy considerations (Section 7 of <a href=\"#RFC6265\" class=\"xref\">[RFC6265]</a>) and security considerations (Section 8 of <a href=\"#RFC6265\" class=\"xref\">[RFC6265]</a>) of that existing state management mechanism, as it forms a foundation upon which this document builds.</p>\n<h1 id=\"rfc.section.7.1\">\n<a href=\"#rfc.section.7.1\">7.1.</a> <a href=\"#confidentiality-and-integrity\" id=\"confidentiality-and-integrity\">Confidentiality and Integrity</a>\n</h1>\n<p id=\"rfc.section.7.1.p.1\">HTTP State Tokens improve upon cookies&#8217; weak confidentiality/integrity guarantees (see Sections 8.3, 8.5, 8.6, and 8.7 of <a href=\"#RFC6265\" class=\"xref\">[RFC6265]</a>) in several ways:</p>\n<p></p>\n\n<ol>\n<li>User agents MUST require secure channels (such as TLS) for delivery and configuration of HTTP State Tokens. User agents cannot be induced to deliver an origin&#8217;s tokens across channels visible to (and modifiable by) network attackers, nor can an attack on DNS cause tokens to be revealed (as any server to which the user could be directed will also need to authenticate itself, which is presumably difficult).</li>\n<li>HTTP State Tokens are mapped to origins, matching developers expectations for client-side data generally. This ensures that tokens are isolated by host and port: code running on <samp>https://bar.example.com/</samp> cannot alter state on <samp>https://foo.example.com/</samp> without the latter&#8217;s cooperation, and that the same applies to <samp>https://example.com:8000/</samp> and <samp>https://example.com:80/</samp>.  <br><br> Note that this origin binding means that there are no path restrictions for tokens. Servers relying upon these tokens for state management SHOULD NOT run mutually distrusting services on different paths of the same origin.</li>\n<li>User agents MUST NOT expose HTTP State Tokens to non-HTTP APIs which are web-accessible, thereby reducing the risk of accidental exposure via cross-site scripting attack.  <br><br> Further, the <samp>Sec-</samp> prefix on both <samp>Sec-HTTP-State</samp> and <samp>Sec-HTTP-State-Options</samp> ensures that both are considered &#8220;forbidden header names&#8221; by <a href=\"#Fetch\" class=\"xref\">[Fetch]</a>. The latter should also be treated as a &#8220;forbidden response header&#8221;.</li>\n</ol>\n<h1 id=\"rfc.section.7.2\">\n<a href=\"#rfc.section.7.2\">7.2.</a> <a href=\"#signed-sessions\" id=\"signed-sessions\">Signed Sessions</a>\n</h1>\n<p id=\"rfc.section.7.2.p.1\">HTTP State Tokens embrace the session identifier pattern discussed in Section 8.4 of <a href=\"#RFC6265\" class=\"xref\">[RFC6265]</a> by requiring that the client control the token&#8217;s value, setting it to a fixed-length, random byte sequence. The client&#8217;s control mitigates the risk of sensitive information being stored in the token directly, and the token&#8217;s length makes it unlikely to be easily guessed.</p>\n<p id=\"rfc.section.7.2.p.2\">Some servers will be interested in proving the token&#8217;s provenance over time, which they do today by storing cookies with signed values. Since storing a signed value directly is impossible in a client-controlled world, servers can instead store a <samp>key</samp>, which is used to sign outgoing requests.  Since this key is never exposed directly to the web, it provides a reasonable guarantee of client stability over time which a server can rely upon when making risk judgements.</p>\n<h1 id=\"rfc.section.7.3\">\n<a href=\"#rfc.section.7.3\">7.3.</a> <a href=\"#user-control\" id=\"user-control\">User Control</a>\n</h1>\n<p id=\"rfc.section.7.3.p.1\">User agents MUST provide users with the ability to control the creation and distribution of HTTP State Tokens, just as they do for cookies today. This certainly means providing controls over first- vs third-party distribution, control over the origins which can store state, control over the state presented to origins, visibility into the state of the user agent&#8217;s token store, and etc.</p>\n<p id=\"rfc.section.7.3.p.2\">Further, this document grants user agents wide latitude to experiment with various distribution policies and limitations. The capabilities offered by <samp>delivery</samp> and <samp>max-age</samp> should be considered upper bounds on distribution, within which user agents are free to roam.</p>\n<h1 id=\"rfc.section.7.4\">\n<a href=\"#rfc.section.7.4\">7.4.</a> <a href=\"#lifetime\" id=\"lifetime\">Lifetime</a>\n</h1>\n<p id=\"rfc.section.7.4.p.1\">By default, HTTP State Tokens live for an hour, which is a compromise between the reasonable desire of servers to maintain state across a given user&#8217;s session, and the privacy risks associated with long-lived tokens stored on a user&#8217;s disk.</p>\n<p id=\"rfc.section.7.4.p.2\">Servers that desire a longer session lifetime can explicitly request an extension, which the browser can choose to act on.</p>\n<h1 id=\"rfc.section.7.5\">\n<a href=\"#rfc.section.7.5\">7.5.</a> <a href=\"#ambient-authority-and-cross-site-delivery\" id=\"ambient-authority-and-cross-site-delivery\">Ambient Authority and Cross-Site Delivery</a>\n</h1>\n<p id=\"rfc.section.7.5.p.1\">HTTP State Tokens, like cookies, provide a form of ambient authority (see Section 8.2 of <a href=\"#RFC6265\" class=\"xref\">[RFC6265]</a>). By default, this authority is limited to requests initiated by same-site actors, which serves as a reasonable mitigation against some classes of attack (e.g. <samp>https://evil.com/</samp> making authenticated requests to <samp>https://example.com/</samp>).</p>\n<p id=\"rfc.section.7.5.p.2\">Servers that desire to interact in an authenticated manner in cross-site contexts are required to opt-into doing so by delivering an appropriate <samp>delivery</samp> value in a <samp>Sec-HTTP-State-Options</samp> response header. Servers which choose to do so SHOULD take reasonable precautions, implementing CSRF tokens for sensitive actions, and taking stock of the context from which a given request is initiated (by examining incoming <samp>Referrer</samp>, <samp>Origin</samp>, and <samp>Sec-Fetch-Site</samp> headers).</p>\n<p id=\"rfc.section.7.5.p.3\">Further, tokens can only be created in same-origin or same-site contexts, which means that cross-site identifier would only be available after the relevant origin was visited in a same-site context, and explicitly declared its tokens as being deliverable cross-site (at which point the user agent is empowered to make some decisions about how to handle that declaration).</p>\n<h1 id=\"rfc.section.8\">\n<a href=\"#rfc.section.8\">8.</a> <a href=\"#implementation-considerations\" id=\"implementation-considerations\">Implementation Considerations</a>\n</h1>\n<h1 id=\"rfc.section.8.1\">\n<a href=\"#rfc.section.8.1\">8.1.</a> <a href=\"#notify-reset\" id=\"notify-reset\">Notifying developers on token reset</a>\n</h1>\n<p id=\"rfc.section.8.1.p.1\">Step 4 of the token generation algorithm (<a href=\"#generate\" class=\"xref\">Section 3.3.1</a>) recognizes that user agents may wish to notify an origin&#8217;s developers that HTTP state has been reset in order to enable cleanup of state stored client-side. Embedding environments are encouraged to define an implementation of the <samp>NotifyHostHTTPStateReset(origin)</samp> algorithm that&#8217;s appropriate for the environment.</p>\n<p id=\"rfc.section.8.1.p.2\">For example, HTML may wish to enable developers to respond to token generation by posting a message to a specially-named <samp>BroadcastChannel</samp> for the to enable this kind of work:</p>\n<pre>\nlet resetChannel = new BroadcastChannel('http-state-reset'));\nresetChannel.onmessage = e =&gt; { /* Do exciting cleanup here. */ };\n</pre>\n<p id=\"rfc.section.8.1.p.3\">This algorithm could take something like the following form:</p>\n<p id=\"rfc.section.8.1.p.4\">TODO(mkwst): Write a reasonable implementation of this once I have internet again.</p>\n<h1 id=\"rfc.section.9\">\n<a href=\"#rfc.section.9\">9.</a> <a href=\"#iana-considerations\" id=\"iana-considerations\">IANA Considerations</a>\n</h1>\n<h1 id=\"rfc.section.9.1\">\n<a href=\"#rfc.section.9.1\">9.1.</a> <a href=\"#header-field-registry\" id=\"header-field-registry\">Header Field Registry</a>\n</h1>\n<p id=\"rfc.section.9.1.p.1\">This document registers the <samp>Sec-Http-State</samp> and <samp>Sec-Http-State-Options</samp> header fields in the &#8220;Permanent Message Header Field Names&#8221; registry located at <a href=\"https://www.iana.org/assignments/message-headers\">https://www.iana.org/assignments/message-headers</a>.</p>\n<h1 id=\"rfc.section.9.1.1\">\n<a href=\"#rfc.section.9.1.1\">9.1.1.</a> <a href=\"#sec-http-state-header-field\" id=\"sec-http-state-header-field\">Sec-Http-State Header Field</a>\n</h1>\n<p></p>\n\n<dl>\n<dt>Header field name:</dt>\n<dd style=\"margin-left: 8\">Sec-Http-State</dd>\n<dt>Applicable protocol:</dt>\n<dd style=\"margin-left: 8\">http</dd>\n<dt>Status:</dt>\n<dd style=\"margin-left: 8\">experimental</dd>\n<dt>Author/Change controller:</dt>\n<dd style=\"margin-left: 8\">IETF</dd>\n<dt>Specification document(s):</dt>\n<dd style=\"margin-left: 8\">This document (see <a href=\"#sec-http-state\" class=\"xref\">Section 4.1</a>)</dd>\n<dt>Related information:</dt>\n<dd style=\"margin-left: 8\">(empty)</dd>\n</dl>\n<h1 id=\"rfc.section.9.1.2\">\n<a href=\"#rfc.section.9.1.2\">9.1.2.</a> <a href=\"#sec-http-state-options-header-field\" id=\"sec-http-state-options-header-field\">Sec-Http-State-Options Header Field</a>\n</h1>\n<p></p>\n\n<dl>\n<dt>Header field name:</dt>\n<dd style=\"margin-left: 8\">Sec-Http-State-Options</dd>\n<dt>Applicable protocol:</dt>\n<dd style=\"margin-left: 8\">http</dd>\n<dt>Status:</dt>\n<dd style=\"margin-left: 8\">experimental</dd>\n<dt>Author/Change controller:</dt>\n<dd style=\"margin-left: 8\">IETF</dd>\n<dt>Specification document(s):</dt>\n<dd style=\"margin-left: 8\">This document (see <a href=\"#sec-http-state-options\" class=\"xref\">Section 4.2</a>)</dd>\n<dt>Related information:</dt>\n<dd style=\"margin-left: 8\">(empty)</dd>\n</dl>\n<h1 id=\"rfc.references\">\n<a href=\"#rfc.references\">10.</a> References</h1>\n<h1 id=\"rfc.references.1\">\n<a href=\"#rfc.references.1\">10.1.</a> Normative References</h1>\n<table><tbody>\n<tr>\n<td class=\"reference\"><b id=\"Fetch\">[Fetch]</b></td>\n<td class=\"top\">\n<a title=\"Mozilla\">van Kesteren, A.</a>, \"<a href=\"https://fetch.spec.whatwg.org/\">Fetch</a>\", n.d..</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</b></td>\n<td class=\"top\">\n<a>Nottingham, M.</a> and <a>P. Kamp</a>, \"<a href=\"https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-09\">Structured Headers for HTTP</a>\", Internet-Draft draft-ietf-httpbis-header-structure-09, December 2018.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"I-D.yasskin-http-origin-signed-responses\">[I-D.yasskin-http-origin-signed-responses]</b></td>\n<td class=\"top\">\n<a>Yasskin, J.</a>, \"<a href=\"https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-05\">Signed HTTP Exchanges</a>\", Internet-Draft draft-yasskin-http-origin-signed-responses-05, January 2019.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"Mixed-Content\">[Mixed-Content]</b></td>\n<td class=\"top\">\n<a title=\"Google\">West, M.</a>, \"<a href=\"https://w3c.github.io/webappsec-mixed-content/\">Mixed Content</a>\", n.d..</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"RFC2104\">[RFC2104]</b></td>\n<td class=\"top\">\n<a>Krawczyk, H.</a>, <a>Bellare, M.</a> and <a>R. Canetti</a>, \"<a href=\"https://tools.ietf.org/html/rfc2104\">HMAC: Keyed-Hashing for Message Authentication</a>\", RFC 2104, DOI 10.17487/RFC2104, February 1997.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"RFC2109\">[RFC2109]</b></td>\n<td class=\"top\">\n<a>Kristol, D.</a> and <a>L. Montulli</a>, \"<a href=\"https://tools.ietf.org/html/rfc2109\">HTTP State Management Mechanism</a>\", RFC 2109, DOI 10.17487/RFC2109, February 1997.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"RFC2119\">[RFC2119]</b></td>\n<td class=\"top\">\n<a>Bradner, S.</a>, \"<a href=\"https://tools.ietf.org/html/rfc2119\">Key words for use in RFCs to Indicate Requirement Levels</a>\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"RFC4648\">[RFC4648]</b></td>\n<td class=\"top\">\n<a>Josefsson, S.</a>, \"<a href=\"https://tools.ietf.org/html/rfc4648\">The Base16, Base32, and Base64 Data Encodings</a>\", RFC 4648, DOI 10.17487/RFC4648, October 2006.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"RFC5234\">[RFC5234]</b></td>\n<td class=\"top\">\n<a>Crocker, D.</a> and <a>P. Overell</a>, \"<a href=\"https://tools.ietf.org/html/rfc5234\">Augmented BNF for Syntax Specifications: ABNF</a>\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"RFC7230\">[RFC7230]</b></td>\n<td class=\"top\">\n<a>Fielding, R.</a> and <a>J. Reschke</a>, \"<a href=\"https://tools.ietf.org/html/rfc7230\">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>\", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"RFC7409\">[RFC7409]</b></td>\n<td class=\"top\">\n<a>Haleplidis, E.</a> and <a>J. Halpern</a>, \"<a href=\"https://tools.ietf.org/html/rfc7409\">Forwarding and Control Element Separation (ForCES) Packet Parallelization</a>\", RFC 7409, DOI 10.17487/RFC7409, November 2014.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"RFC8174\">[RFC8174]</b></td>\n<td class=\"top\">\n<a>Leiba, B.</a>, \"<a href=\"https://tools.ietf.org/html/rfc8174\">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>\n</tr>\n</tbody></table>\n<h1 id=\"rfc.references.2\">\n<a href=\"#rfc.references.2\">10.2.</a> Informative References</h1>\n<table><tbody>\n<tr>\n<td class=\"reference\"><b id=\"I-D.abarth-cake\">[I-D.abarth-cake]</b></td>\n<td class=\"top\">\n<a>Barth, A.</a>, \"<a href=\"https://tools.ietf.org/html/draft-abarth-cake-01\">Origin Cookies</a>\", Internet-Draft draft-abarth-cake-01, March 2011.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"I-D.ietf-cbor-cddl\">[I-D.ietf-cbor-cddl]</b></td>\n<td class=\"top\">\n<a>Birkholz, H.</a>, <a>Vigano, C.</a> and <a>C. Bormann</a>, \"<a href=\"https://tools.ietf.org/html/draft-ietf-cbor-cddl-08\">Concise data definition language (CDDL): a notational convention to express CBOR and JSON data structures</a>\", Internet-Draft draft-ietf-cbor-cddl-08, March 2019.</td>\n</tr>\n<tr>\n<td class=\"reference\"><b id=\"RFC6265\">[RFC6265]</b></td>\n<td class=\"top\">\n<a>Barth, A.</a>, \"<a href=\"https://tools.ietf.org/html/rfc6265\">HTTP State Management Mechanism</a>\", RFC 6265, DOI 10.17487/RFC6265, April 2011.</td>\n</tr>\n</tbody></table>\n<h1 id=\"rfc.appendix.A\">\n<a href=\"#rfc.appendix.A\">Appendix A.</a> <a href=\"#acknowledgements\" id=\"acknowledgements\">Acknowledgements</a>\n</h1>\n<p id=\"rfc.section.A.p.1\">This document owes much to Adam Barth&#8217;s <a href=\"#I-D.abarth-cake\" class=\"xref\">[I-D.abarth-cake]</a> and <a href=\"#RFC6265\" class=\"xref\">[RFC6265]</a>.</p>\n<h1 id=\"rfc.appendix.B\">\n<a href=\"#rfc.appendix.B\">Appendix B.</a> <a href=\"#changes\" id=\"changes\">Changes</a>\n</h1>\n<p><em>RFC Editor: Please remove this section before publication.</em></p>\n<p></p>\n\n<ul>\n<li>-01 <ul>\n<li>General editorial cleanup.</li>\n<li>Explanation of <samp>NotifyHostHTTPStateReset(origin)</samp> algorithm in <a href=\"#notify-reset\" class=\"xref\">Section 8.1</a>.</li>\n</ul>\n</li>\n<li>-00 <ul><li>This document was created.</li></ul>\n</li>\n</ul>\n<h1 id=\"rfc.authors\"><a href=\"#rfc.authors\">Author's Address</a></h1>\n<div class=\"avoidbreak\">\n  <address class=\"vcard\">\n\t<span class=\"vcardline\">\n\t  <span class=\"fn\">Mike West</span> \n\t  <span class=\"n hidden\">\n\t\t<span class=\"family-name\">West</span>\n\t  </span>\n\t</span>\n\t<span class=\"org vcardline\">Google</span>\n\t<span class=\"adr\">\n\t  \n\t  <span class=\"vcardline\">\n\t\t<span class=\"locality\"></span> \n\t\t<span class=\"region\"></span>\n\t\t<span class=\"code\"></span>\n\t  </span>\n\t  <span class=\"country-name vcardline\"></span>\n\t</span>\n\t<span class=\"vcardline\">EMail: <a href=\"mailto:mkwst@google.com\">mkwst@google.com</a></span>\n\n<span class=\"vcardline\">URI: <a href=\"https://www.mikewest.org/\">https://www.mikewest.org/</a></span>\n\n  </address>\n</div>\n\n</body>\n</html>\n","oembed":false,"readabilityObject":{"title":"HTTP State Tokens","content":"<div id=\"readability-page-1\" class=\"page\">\n\n  \n\n  <p>HTTP State Tokens<br>\n  <span>draft-west-http-state-tokens-latest</span></p>\n  \n  <h2 id=\"rfc.abstract\"><a href=\"#rfc.abstract\">Abstract</a></h2>\n<p>This document describes a mechanism which allows HTTP servers to maintain stateful sessions with HTTP user agents. It aims to address some of the security and privacy considerations which have been identified in existing state management mechanisms, providing developers with a well-lit path towards our current understanding of best practice.</p>\n<h2 id=\"rfc.status\"><a href=\"#rfc.status\">Status of This Memo</a></h2>\n<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>\n<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>\n<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as \"work in progress.\"</p>\n<p>This Internet-Draft will expire on October 3, 2019.</p>\n<h2 id=\"rfc.copyrightnotice\"><a href=\"#rfc.copyrightnotice\">Copyright Notice</a></h2>\n<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>\n<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>\n\n  \n  <hr>\n  <h2 id=\"rfc.toc\"><a href=\"#rfc.toc\">Table of Contents</a></h2>\n  <ul>\n\n  \t<li>1.   <a href=\"#rfc.section.1\">Introduction</a>\n</li>\n<ul><li>1.1.   <a href=\"#rfc.section.1.1\">Wait. Don’t we already have cookies?</a>\n</li>\n<li>1.2.   <a href=\"#rfc.section.1.2\">No. Really. We have cookies today. Why do we need this new thing?</a>\n</li>\n<li>1.3.   <a href=\"#rfc.section.1.3\">Examples</a>\n</li>\n</ul><li>2.   <a href=\"#rfc.section.2\">Conventions</a>\n</li>\n<ul><li>2.1.   <a href=\"#rfc.section.2.1\">Conformance</a>\n</li>\n<li>2.2.   <a href=\"#rfc.section.2.2\">Syntax</a>\n</li>\n</ul><li>3.   <a href=\"#rfc.section.3\">Infrastructure</a>\n</li>\n<ul><li>3.1.   <a href=\"#rfc.section.3.1\">HTTP State Tokens</a>\n</li>\n<li>3.2.   <a href=\"#rfc.section.3.2\">Requests and Responses</a>\n</li>\n<li>3.3.   <a href=\"#rfc.section.3.3\">Token Storage</a>\n</li>\n</ul><li>4.   <a href=\"#rfc.section.4\">Syntax</a>\n</li>\n<ul><li>4.1.   <a href=\"#rfc.section.4.1\">The ‘Sec-Http-State’ HTTP Header Field</a>\n</li>\n<li>4.2.   <a href=\"#rfc.section.4.2\">The ‘Sec-Http-State-Options’ HTTP Header Field</a>\n</li>\n</ul><li>5.   <a href=\"#rfc.section.5\">Delivering HTTP State Tokens</a>\n</li>\n<ul><li>5.1.   <a href=\"#rfc.section.5.1\">Attach HTTP State Tokens to a request</a>\n</li>\n<li>5.2.   <a href=\"#rfc.section.5.2\">Generate a request’s signature</a>\n</li>\n</ul><li>6.   <a href=\"#rfc.section.6\">Configuring HTTP State Tokens</a>\n</li>\n<li>7.   <a href=\"#rfc.section.7\">Security and Privacy Considerations</a>\n</li>\n<ul><li>7.1.   <a href=\"#rfc.section.7.1\">Confidentiality and Integrity</a>\n</li>\n<li>7.2.   <a href=\"#rfc.section.7.2\">Signed Sessions</a>\n</li>\n<li>7.3.   <a href=\"#rfc.section.7.3\">User Control</a>\n</li>\n<li>7.4.   <a href=\"#rfc.section.7.4\">Lifetime</a>\n</li>\n<li>7.5.   <a href=\"#rfc.section.7.5\">Ambient Authority and Cross-Site Delivery</a>\n</li>\n</ul><li>8.   <a href=\"#rfc.section.8\">Implementation Considerations</a>\n</li>\n<ul><li>8.1.   <a href=\"#rfc.section.8.1\">Notifying developers on token reset</a>\n</li>\n</ul><li>9.   <a href=\"#rfc.section.9\">IANA Considerations</a>\n</li>\n<ul><li>9.1.   <a href=\"#rfc.section.9.1\">Header Field Registry</a>\n</li>\n</ul><li>10.   <a href=\"#rfc.references\">References</a>\n</li>\n<ul><li>10.1.   <a href=\"#rfc.references.1\">Normative References</a>\n</li>\n<li>10.2.   <a href=\"#rfc.references.2\">Informative References</a>\n</li>\n</ul><li>Appendix A.   <a href=\"#rfc.appendix.A\">Acknowledgements</a>\n</li>\n<li>Appendix B.   <a href=\"#rfc.appendix.B\">Changes</a>\n</li>\n<li><a href=\"#rfc.authors\">Author's Address</a>\n</li>\n\n\n  </ul>\n\n  <h2 id=\"rfc.section.1\">\n<a href=\"#rfc.section.1\">1.</a> <a href=\"#introduction\" id=\"introduction\">Introduction</a>\n</h2>\n<p id=\"rfc.section.1.p.1\">This document defines a state-management mechanism for HTTP that allows clients to create and persist origin-bound session identifiers that can be delivered to servers in order to enable stateful interaction. In a nutshell, each user agent will generate a single token per secure origin, and will deliver it as a <samp>Sec-Http-State</samp> structured header along with requests to that origin (defined in <a href=\"#sec-http-state\">Section 4.1</a> and <a href=\"#delivery\">Section 5</a>).</p>\n<p id=\"rfc.section.1.p.2\">Servers can configure this token’s characteristics via a <samp>Sec-Http-State-Options</samp> response header (defined in <a href=\"#sec-http-state-options\">Section 4.2</a> and <a href=\"#config\">Section 6</a>).</p>\n<p id=\"rfc.section.1.p.3\">That’s it.</p>\n<h2 id=\"rfc.section.1.1\">\n<a href=\"#rfc.section.1.1\">1.1.</a> <a href=\"#wait-dont-we-already-have-cookies\" id=\"wait-dont-we-already-have-cookies\">Wait. Don’t we already have cookies?</a>\n</h2>\n<p id=\"rfc.section.1.1.p.1\">Cookies <a href=\"#RFC6265\">[RFC6265]</a> are indeed a pervasive HTTP state management mechanism in the status quo, and they enable practically everything interesting on the web today. That said, cookies have some issues: they’re hard to use securely, they add substantial weight to users’ outgoing requests, and they enable tracking users’ activity across the web in potentially surprising ways.</p>\n<p id=\"rfc.section.1.1.p.2\">The mechanism proposed in this document aims at a more minimal and opinionated construct which takes inspiration from some of cookies’ optional characteristics. In particular:</p>\n\n\n<ol>\n<li>The client controls the token’s value, not the server.</li>\n<li>The token will only be available to the network layer, not to JavaScript (including network-like JavaScript, such as Service Workers).</li>\n<li>The user agent will generate only one token per origin, and will only expose the token to the origin for which it was generated.</li>\n<li>Tokens will not be generated for, or delivered to, non-secure origins.</li>\n<li>By default, token delivery and configuration is constrained to same-site requests.</li>\n<li>Each token persists for one hour after generation by default. This default expiration time can be overwritten by servers, and tokens can be reset at any time by servers, users, or user agents.</li>\n</ol>\n<p id=\"rfc.section.1.1.p.4\">These distinctions might not be appropriate for all use cases, but seem like a reasonable set of defaults. For folks for whom these defaults aren’t good enough, we’ll provide developers with a few control points that can be triggered via a <samp>Sec-HTTP-State-Options</samp> HTTP response header, described in <a href=\"#sec-http-state-options\">Section 4.2</a>.</p>\n<h2 id=\"rfc.section.1.2\">\n<a href=\"#rfc.section.1.2\">1.2.</a> <a href=\"#no-really-we-have-cookies-today-why-do-we-need-this-new-thing\" id=\"no-really-we-have-cookies-today-why-do-we-need-this-new-thing\">No. Really. We have cookies today. Why do we need this new thing?</a>\n</h2>\n<p id=\"rfc.section.1.2.p.1\">We do have cookies. And we’ve defined a number of extensions to cookies to blunt some of their sharper edges: the <samp>HttpOnly</samp> attribute, the <samp>Secure</samp> attribute, <samp>SameSite</samp>, prefixes like <samp>__Host-</samp> and <samp>__Secure-</samp>, and so on. It’s reasonable to suggest that pushing developers towards these existing flags on our existing state management primitive is the right way forward.</p>\n<p id=\"rfc.section.1.2.p.2\">A counterpoint is that we’re collectively pretty bad at helping developers understand the risks that might lead them to adopt The Good Cookie Syntax(tm) above. Adoption of these features has been quite slow. The <samp>Secure</samp> flag, for example, has been around since at least 1997 <a href=\"#RFC2109\">[RFC2109]</a>, and is hovering around 9% adoption based on data gathered from Chrome’s telemetry in March, 2019. In that dataset, cookies’ other properties are set as follows:</p>\n\n\n<ul>\n<li>~6.8% of cookies are set with <samp>HttpOnly</samp>.</li>\n<li>~5.5% are set with <samp>Secure</samp>.</li>\n<li>~3.1% are set with <samp>HttpOnly; Secure</samp>.</li>\n<li>~0.06% are set with <samp>SameSite=*; Secure</samp>.</li>\n<li>~0.05% are set with <samp>SameSite=*</samp>.</li>\n<li>~0.03% are set with <samp>HttpOnly; Secure; SameSite=*</samp>.</li>\n<li>~0.006% are set with <samp>SameSite=*; HttpOnly</samp>.</li>\n<li>~0.005% are set with a <samp>__Secure-</samp> prefix.</li>\n<li>~0.01% are set with a <samp>__Host-</samp> prefix.</li>\n</ul>\n<p id=\"rfc.section.1.2.p.4\">In total:</p>\n\n\n<ul>\n<li>~9.9% of cookies are marked as <samp>HttpOnly</samp>.</li>\n<li>~8.8% of cookies are marked as <samp>Secure</samp>.</li>\n<li>~0.1% of cookies are marked as <samp>SameSite</samp>.</li>\n<li>~84.2% of cookies use none of these features.</li>\n</ul>\n<p id=\"rfc.section.1.2.p.6\">This document’s underlying assumption is that it’s going to be easier to teach developers about a crazy new thing that’s secure by default than it would be to convince them to change their <samp>Set-Cookie</samp> headers to be more like <samp>__Host-name=value; HttpOnly; Secure; SameSite=Lax; Path=/</samp>. A new thing resets expectations in a way that vastly exceeds the impact of explanations about the the four attributes that must be used, the one attribute that must not be used, and the weird naming convention that ought to be adopted.</p>\n<h2 id=\"rfc.section.1.3\">\n<a href=\"#rfc.section.1.3\">1.3.</a> <a href=\"#examples\" id=\"examples\">Examples</a>\n</h2>\n<p id=\"rfc.section.1.3.p.1\">User agents can deliver HTTP state tokens to a server in a <samp>Sec-Http-State</samp> header. For example, if a user agent has generated a token bound to <samp>https://example.com/</samp> whose base64 encoding is <samp>hB2RfWaGyNk60sjHze5DzGYjSnL7tRF2HWSBx6J1o4k=</samp> (<a href=\"#RFC4648\">[RFC4648]</a>, Section 4), then it would generate the following header when delivering the token along with requests to <samp>https://example.com/</samp>:</p>\n<pre>Sec-Http-State: token=*hB2RfWaGyNk60sjHze5DzGYjSnL7tRF2HWSBx6J1o4k*\n</pre>\n<p id=\"rfc.section.1.3.p.2\">The server can control certain aspects of the token’s delivery by responding to requests with a <samp>Sec-Http-State-Options</samp> header:</p>\n<pre>Sec-Http-State-Options: max-age=3600, key=*b7kuUkp...lkRioC2=*\n</pre>\n<h2 id=\"rfc.section.2\">\n<a href=\"#rfc.section.2\">2.</a> <a href=\"#conventions\" id=\"conventions\">Conventions</a>\n</h2>\n<h2 id=\"rfc.section.2.1\">\n<a href=\"#rfc.section.2.1\">2.1.</a> <a href=\"#conformance\" id=\"conformance\">Conformance</a>\n</h2>\n<p id=\"rfc.section.2.1.p.1\">The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP&nbsp;14 <a href=\"#RFC2119\">[RFC2119]</a> <a href=\"#RFC8174\">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>\n<h2 id=\"rfc.section.2.2\">\n<a href=\"#rfc.section.2.2\">2.2.</a> <a href=\"#syntax\" id=\"syntax\">Syntax</a>\n</h2>\n<p id=\"rfc.section.2.2.p.1\">This document defines two Structured Headers <a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>. In doing so it relies upon the Augmented Backus-Naur Form (ABNF) notation of <a href=\"#RFC5234\">[RFC5234]</a> and the OWS rule from <a href=\"#RFC7230\">[RFC7230]</a>.</p>\n<h2 id=\"rfc.section.3\">\n<a href=\"#rfc.section.3\">3.</a> <a href=\"#infrastructure\" id=\"infrastructure\">Infrastructure</a>\n</h2>\n\n<p id=\"rfc.section.3.1.p.1\">An HTTP State Token holds a session identifier which allows a user agent to maintain a stateful session with a specific origin, along with associated metadata:</p>\n\n\n<ul>\n<li>\n<samp>creation</samp> is a timestamp representing the point in time when the token was created.</li>\n<li>\n<samp>delivery</samp> specifies the initiating contexts from which the token can be delivered. It is an enum of either <samp>same-origin</samp>, <samp>same-site</samp>, or <samp>cross-site</samp>. Unless otherwise specified, its value is <samp>same-site</samp>.</li>\n<li>\n<samp>key</samp> is a server-provided key which can be used to sign requests with which the token is delivered. It is either null, or contains up to 256-bits of binary data. Unless otherwise specified, its value is null.</li>\n<li>\n<samp>max-age</samp> is a number representing the token’s lifetime in seconds. Unless otherwise specified, its value is <samp>3600</samp> (1 hour).</li>\n<li>\n<samp>value</samp> is the token’s value (surprising, right?). It contains up to 256-bits of binary data.</li>\n</ul>\n<p id=\"rfc.section.3.1.p.3\">An HTTP State Token is said to be “expired” if its <samp>creation</samp> timestamp plus <samp>max-age</samp> seconds is in the past.</p>\n<h2 id=\"rfc.section.3.2\">\n<a href=\"#rfc.section.3.2\">3.2.</a> <a href=\"#requests-and-responses\" id=\"requests-and-responses\">Requests and Responses</a>\n</h2>\n<p id=\"rfc.section.3.2.p.1\">This document relies upon the definitions of “request” and “response” found in <a href=\"#Fetch\">[Fetch]</a>.</p>\n<p id=\"rfc.section.3.2.p.2\">A request’s delivery scope is <samp>same-origin</samp> if the request’s initiator and target are exactly the same origin, <samp>same-site</samp> if the request’s initiator and target are not same-origin but share a registrable domain (e.g. <samp>https://www.example.com/</samp> and <samp>https://not-www.example.com/</samp>), and <samp>cross-site</samp> otherwise. The following algorithm spells this relationship out more formally:</p>\n\n\n<ol>\n<li>If the request was generated by the user agent as a response to direct user interaction with the user agent (e.g. the user typed an address into the agent’s address bar, clicked a bookmark, or etc.), return <samp>same-origin</samp>.</li>\n<li>Let <samp>request-origin</samp> be the request’s <samp>origin</samp>, and <samp>target-origin</samp> be the request’s <samp>URL</samp>’s <samp>origin</samp>.</li>\n<li>If <samp>request-origin</samp> is same-origin with <samp>target-origin</samp>, return <samp>same-origin</samp>.</li>\n<li>If <samp>request-origin</samp>’s registrable domain is the same as <samp>target-origin</samp>’s registrable domain, return <samp>same-site</samp>.</li>\n<li>Return <samp>cross-site</samp>.</li>\n</ol>\n<h2 id=\"rfc.section.3.3\">\n<a href=\"#rfc.section.3.3\">3.3.</a> <a href=\"#token-storage\" id=\"token-storage\">Token Storage</a>\n</h2>\n<p id=\"rfc.section.3.3.p.1\">User agents MUST keep a list of all the unexpired HTTP State Tokens which have been created. For the purposes of this document, we’ll assume that user agents keep this list in the form of a map whose keys are origins, and whose values are HTTP State Tokens.</p>\n<p id=\"rfc.section.3.3.p.2\">This map exposes three functions:</p>\n\n\n<ul>\n<li>An HTTP State Token can be stored for a given origin. If the origin already exists in the map, the entry’s value will be overwritten with the new HTTP State Token.</li>\n<li>An origin’s HTTP State Token can be retrieved. If the origin does not exist in the map, <samp>null</samp> will be returned instead.</li>\n<li>An origin (along with its HTTP State Token) can be deleted from the map.</li>\n</ul>\n<p id=\"rfc.section.3.3.p.4\">The map is initially empty.</p>\n<h2 id=\"rfc.section.3.3.1\">\n<a href=\"#rfc.section.3.3.1\">3.3.1.</a> <a href=\"#generate\" id=\"generate\">Generate an HTTP State Token for an origin</a>\n</h2>\n<p id=\"rfc.section.3.3.1.p.1\">The user agent MUST generate a new HTTP State Token for an origin using an algorithm equivalent to the following:</p>\n\n\n<ol>\n<li>Delete <samp>origin</samp> from the user agent’s token store.</li>\n<li>Let <samp>token</samp> be a newly created HTTP State Token with its properties set as follows:  <ul>\n<li>\n<samp>creation</samp>: The current time.</li>\n<li>\n<samp>delivery</samp>: <samp>same-site</samp>\n</li>\n<li>\n<samp>key</samp>: null</li>\n<li>\n<samp>max-age</samp>: 3600</li>\n<li>\n<samp>value</samp>: 256 cryptographically random bits.</li>\n</ul>\n</li>\n<li>Store <samp>token</samp> in the user agent’s token store for <samp>origin</samp>.</li>\n<li>If the user agent has defined a <samp>NotifyHostHTTPStateReset(origin)</samp> algorithm, call it with <samp>origin</samp> (see <a href=\"#notify-reset\">Section 8.1</a> for more context on this step).</li>\n<li>Return <samp>token</samp>.</li>\n</ol>\n<h2 id=\"rfc.section.4\">\n<a href=\"#rfc.section.4\">4.</a> <a href=\"#syntax-1\" id=\"syntax-1\">Syntax</a>\n</h2>\n<h2 id=\"rfc.section.4.1\">\n<a href=\"#rfc.section.4.1\">4.1.</a> <a href=\"#sec-http-state\" id=\"sec-http-state\">The ‘Sec-Http-State’ HTTP Header Field</a>\n</h2>\n<p id=\"rfc.section.4.1.p.1\">The <samp>Sec-Http-State</samp> HTTP header field allows user agents to deliver HTTP state tokens to servers as part of an HTTP request.</p>\n<p><samp>Sec-Http-State</samp> is a Structured Header <a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>. Its value MUST be a dictionary (<a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.1). Its ABNF is:</p>\n<pre>Sec-Http-State = sh-dictionary\n</pre>\n<p id=\"rfc.section.4.1.p.3\">The dictionary MUST contain:</p>\n\n\n<ul><li>Exactly one member whose key is <samp>token</samp>, and whose value is binary content (<a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.9) that encodes the HTTP state token’s value for the origin to which the header is delivered.  <p> If the <samp>token</samp> member contains more than 256 bits of binary content, the member MUST be ignored.</p></li></ul>\n<p id=\"rfc.section.4.1.p.5\">The dictionary MAY contain:</p>\n\n\n<ul><li>Exactly one member whose key is <samp>sig</samp>, and whose value is binary content (<a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.9) that encodes a signature over the token and the request which contains it, using a key previously delivered by the server. This mechanism is described in <a href=\"#sign\">Section 5.2</a>.  <p> If the <samp>sig</samp> member contains more than 256 bits of binary content, the member MUST be ignored.</p></li></ul>\n<p id=\"rfc.section.4.1.p.7\">The <samp>Sec-Http-State</samp> header is parsed per the algorithm in Section 4.2 of <a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>. Servers MUST ignore the header if parsing fails, or if the parsed header does not contain a member whose key is <samp>token</samp>.</p>\n<p id=\"rfc.section.4.1.p.8\">User agents will attach a <samp>Sec-Http-State</samp> header to outgoing requests according to the processing rules described in <a href=\"#delivery\">Section 5</a>.</p>\n<h2 id=\"rfc.section.4.2\">\n<a href=\"#rfc.section.4.2\">4.2.</a> <a href=\"#sec-http-state-options\" id=\"sec-http-state-options\">The ‘Sec-Http-State-Options’ HTTP Header Field</a>\n</h2>\n<p id=\"rfc.section.4.2.p.1\">The <samp>Sec-Http-State-Options</samp> HTTP header field allows servers to deliver configuration information to user agents as part of an HTTP response.</p>\n<p><samp>Sec-Http-State-Options</samp> is a Structured Header <a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>. Its value MUST be a dictionary (<a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.1). Its ABNF is:</p>\n<pre>Sec-Http-State-Options = sh-dictionary\n</pre>\n<p id=\"rfc.section.4.2.p.3\">The <samp>Sec-Http-State-Options</samp> header is parsed per the algorithm in Section 4.2 of <a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>. User agents MUST ignore the header if parsing fails.</p>\n<p id=\"rfc.section.4.2.p.4\">The dictionary MAY contain:</p>\n\n\n<ul>\n<li>Exactly one member whose key is <samp>key</samp>, and whose value is binary content (<a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.10) that encodes an key which can be used to generate a signature over outgoing requests.</li>\n<li>Exactly one member whose key is <samp>delivery</samp>, and whose value is one of the following tokens (<a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.9): <samp>same-origin</samp>, <samp>same-site</samp>, or <samp>cross-site</samp>.  <p> If the <samp>delivery</samp> member contains an unknown identifier, the member MUST be ignored.</p></li>\n<li>Exactly one member whose key is <samp>max-age</samp>, and whose value is an integer (<a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>, Section 3.6) representing the server’s desired lifetime for its HTTP State Token.  <p> If the <samp>max-age</samp> member contains anything other than a positive integer, the member MUST be ignored.</p></li>\n</ul>\n<p id=\"rfc.section.4.2.p.6\">User agents will process the <samp>Sec-Http-State-Options</samp> header on incoming responses according to the processing rules described in <a href=\"#config\">Section 6</a>.</p>\n<h2 id=\"rfc.section.4.2.1\">\n<a href=\"#rfc.section.4.2.1\">4.2.1.</a> <a href=\"#examples-1\" id=\"examples-1\">Examples</a>\n</h2>\n<h2 id=\"rfc.section.4.2.1.1\">\n<a href=\"#rfc.section.4.2.1.1\">4.2.1.1.</a> <a href=\"#cross-site-delivery\" id=\"cross-site-delivery\">Cross-Site Delivery</a>\n</h2>\n<p id=\"rfc.section.4.2.1.1.p.1\">Some servers will require access to their tokens from cross-site contexts (perhaps to support authenticated activity or single-sign on, etc). These servers can request a <samp>cross-site</samp> delivery option by delivering the following header:</p>\n<pre>Sec-Http-State-Options: delivery=cross-site, ...\n</pre>\n<h2 id=\"rfc.section.4.2.1.2\">\n<a href=\"#rfc.section.4.2.1.2\">4.2.1.2.</a> <a href=\"#token-lifetime\" id=\"token-lifetime\">Token Lifetime</a>\n</h2>\n<p id=\"rfc.section.4.2.1.2.p.1\">Other servers might want their sessions to persist for more than an hour. These servers can request a more reasonable token lifetime lifetime by by delivering the following header:</p>\n<pre>Sec-Http-State-Options: max-age=2592000, ...\n</pre>\n<p id=\"rfc.section.4.2.1.2.p.2\">Servers may also wish to explicitly trigger the token’s expiration (upon signout, for instance).  Setting a <samp>max-age</samp> of <samp>0</samp> does the trick:</p>\n<pre>Sec-Http-State-Options: max-age=0, ...\n</pre>\n<h2 id=\"rfc.section.4.2.1.3\">\n<a href=\"#rfc.section.4.2.1.3\">4.2.1.3.</a> <a href=\"#token-provenance\" id=\"token-provenance\">Token Provenance</a>\n</h2>\n<p id=\"rfc.section.4.2.1.3.p.1\">For some servers, the client-generated token will be enough to maintain state. They can treat it as an opaque session identifier, and bind the user’s state to it server-side. Other servers will require additional assurance that they can trust the token’s provenance. To that end, servers can generate a unique key, associate it with the session identifier on the server, and deliver it to the client via an HTTP response header:</p>\n<pre>Sec-Http-State-Options: key=*ZH0GxtBMWA...nJudhZ8dtz*, ...\n</pre>\n<p id=\"rfc.section.4.2.1.3.p.2\">Clients will store that key, and use it to generate a signature over some set of data that mitigates the risk of token capture:</p>\n<pre>Sec-HTTP-State:\n    token=*J6BRKa...MonM*,\n    sig=*(HMAC-SHA256(key, token+metadata))*\n</pre>\n<p id=\"rfc.section.4.2.1.3.p.3\">Note: This part in particular is not fully baked, and we need to do some more work to flesh out the threat model (see also Token Binding). Look at it as an area to explore, not a solidly thought-out solution.</p>\n<h2 id=\"rfc.section.5\">\n<a href=\"#rfc.section.5\">5.</a> <a href=\"#delivery\" id=\"delivery\">Delivering HTTP State Tokens</a>\n</h2>\n<p id=\"rfc.section.5.p.1\">User agents deliver HTTP state tokens to servers by appending a <samp>Sec-Http-State</samp> header field to outgoing requests.</p>\n<p id=\"rfc.section.5.p.2\">This specification provides algorithms which are called at the appropriate points in <a href=\"#Fetch\">[Fetch]</a> in order to attach <samp>Sec-Http-State</samp> headers to outgoing requests, and to ensure that <samp>Sec-Http-State-Options</samp> headers are correctly processed.</p>\n<h2 id=\"rfc.section.5.1\">\n<a href=\"#rfc.section.5.1\">5.1.</a> <a href=\"#attach\" id=\"attach\">Attach HTTP State Tokens to a request</a>\n</h2>\n<p id=\"rfc.section.5.1.p.1\">The user agent can attach HTTP State Tokens to a given request using an algorithm equivalent to the following. This algorithm is intended to execute as the request is being sent out over the network (after Service Worker processing), perhaps after the <samp>Cookie</samp> header is handled in step 5.17.1 of Section 4.5 of <a href=\"#Fetch\">[Fetch]</a>, describing the “HTTP-network-or-cache fetch” algorithm:</p>\n\n\n<ol>\n<li>If the user agent is configured to suppress explicit identifiers for the request, or if the request’s URL is not <em>a priori</em> authenticated <a href=\"#Mixed-Content\">[Mixed-Content]</a>, then skip the remaining steps in this algorithm, and return without modifying the request.</li>\n<li>Let <samp>target-origin</samp> be the origin of <samp>request</samp>’s current URL.</li>\n<li>Let <samp>request-token</samp> be the result of retrieving origin’s token from the user agent’s token store, or <samp>null</samp> if no such token exists.</li>\n<li>If <samp>request-token</samp> is expired, clear the user agent’s token store for <samp>target-origin</samp>, and set <samp>request-token</samp> to <samp>null</samp>.</li>\n<li>If <samp>request-token</samp> is <samp>null</samp>, then:  <ol>\n<li>If <samp>request</samp>’s delivery scope is <samp>cross-site</samp>, return without modifying the request.      <p> Note: As the default <samp>delivery</samp> for HTTP State Tokens is <samp>same-site</samp>, we return early rather than generating a token for a cross-site request.</p></li>\n<li>Set <samp>request-token</samp> to the result of generating an HTTP State Token for <samp>target-origin</samp>, as defined in <a href=\"#generate\">Section 3.3.1</a>.</li>\n</ol>\n</li>\n<li>Return without modifying the request if either of the following statements are true:  <ul>\n<li>\n<samp>request-token</samp>’s <samp>delivery</samp> is <samp>same-origin</samp>, and <samp>request</samp>’s delivery scope is not <samp>same-origin</samp>.</li>\n<li>\n<samp>request-token</samp>’s <samp>delivery</samp> is <samp>same-site</samp>, and <samp>request</samp>’s delivery scope is neither <samp>same-origin</samp> nor <samp>same-site</samp>.</li>\n</ul>\n</li>\n<li>Let <samp>serialized-value</samp> be the base64 encoding (<a href=\"#RFC4648\">[RFC4648]</a>, Section 4) of <samp>request-token</samp>’s value.</li>\n<li>Insert a member into <samp>header-value</samp> whose key is <samp>token</samp> and whose value is <samp>serialized-value</samp>.</li>\n<li>If <samp>request-token</samp>’s <samp>key</samp> is not null, then insert a member into <samp>header-value</samp> whose key is <samp>sig</samp>, and whose value is the result of executing <a href=\"#sign\">Section 5.2</a> on request, <samp>serialized-value</samp>, and <samp>request-token</samp>’s <samp>key</samp>.</li>\n<li>Append a header to <samp>request</samp>’s header list whose name is <samp>Sec-Http-State</samp>, and whose value is the result of serializing <samp>header-value</samp> (<a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>, Section 4.1).</li>\n</ol>\n<h2 id=\"rfc.section.5.2\">\n<a href=\"#rfc.section.5.2\">5.2.</a> <a href=\"#sign\" id=\"sign\">Generate a request’s signature</a>\n</h2>\n<p id=\"rfc.section.5.2.p.1\">If the origin server provides a <samp>key</samp>, the user agent will use it to sign any outgoing requests which target that origin and include an HTTP State Token. Note that the signature is produced before adding the <samp>Sec-Http-State</samp> header to the request.</p>\n<p id=\"rfc.section.5.2.p.2\">Given a request, a base64-encoded token value, and a key:</p>\n\n\n<ol>\n<li>Let <samp>cbor-request</samp> be the result of building a CBOR representation <a href=\"#RFC7409\">[RFC7409]</a> of the given request, as specified in the first element of the array described in Section 3.2 of <a href=\"#I-D.yasskin-http-origin-signed-responses\">[I-D.yasskin-http-origin-signed-responses]</a>.</li>\n<li>Add an item to <samp>cbor-request</samp> which maps the byte string ‘:token’ to the byte string containing the given base64-encoded token value.</li>\n<li>Return the result of computing HMAC-SHA256 <a href=\"#RFC2104\">[RFC2104]</a> over the canonical CBOR serialization of <samp>cbor-request</samp> (Section 3.4 of <a href=\"#I-D.yasskin-http-origin-signed-responses\">[I-D.yasskin-http-origin-signed-responses]</a>), using the given <samp>key</samp>.</li>\n</ol>\n<h2 id=\"rfc.section.5.2.1\">\n<a href=\"#rfc.section.5.2.1\">5.2.1.</a> <a href=\"#example\" id=\"example\">Example</a>\n</h2>\n<p id=\"rfc.section.5.2.1.p.1\">The following request:</p>\n<pre>GET / HTTP/1.1\nHost: example.com\nAccept: */*\n</pre>\n<p id=\"rfc.section.5.2.1.p.2\">results in the following CBOR representation (represented using the extended diagnostic notation from Appendix G of <a href=\"#I-D.ietf-cbor-cddl\">[I-D.ietf-cbor-cddl]</a>):</p>\n<pre>{\n  ':method': 'GET',\n  ':token': 'hB2RfWaGyNk60sjHze5DzGYjSnL7tRF2HWSBx6J1o4k='\n  ':url': 'https://example.com/',\n  'accept': '*/*',\n}\n</pre>\n<h2 id=\"rfc.section.6\">\n<a href=\"#rfc.section.6\">6.</a> <a href=\"#config\" id=\"config\">Configuring HTTP State Tokens</a>\n</h2>\n<p id=\"rfc.section.6.p.1\">Servers configure the HTTP State Token representing a given users’ state by appending a <samp>Sec-Http-State-Options</samp> header field to outgoing responses.</p>\n<p id=\"rfc.section.6.p.2\">User agents MUST process this header on a given response as per the following algorithm, which is intended to be called after the <samp>Set-Cookie</samp> header is handled in step 11.4 of Section 4.6 of <a href=\"#Fetch\">[Fetch]</a>, which defines the “HTTP-network fetch” algorithm.</p>\n\n\n<ol>\n<li>Let <samp>response-origin</samp> be the origin of response’s URL.</li>\n<li>If the response’s URL is not <em>a priori</em> authenticated <a href=\"#Mixed-Content\">[Mixed-Content]</a>, return without altering <samp>response-origin</samp>’s HTTP State Token.</li>\n<li>Let <samp>token</samp> be the result of retrieving <samp>response-origin</samp>’s token from the user agent’s token store, or <samp>null</samp> if no such token exists.</li>\n<li>If <samp>token</samp> is expired, clear the user agent’s token store for <samp>response-origin</samp>, and set <samp>token</samp> to <samp>null</samp>.</li>\n<li>If <samp>token</samp> is <samp>null</samp>, then:  <ol>\n<li>If <samp>request</samp>’s delivery scope is <samp>cross-site</samp>, return without modifying the request.      <p> Note: As the default <samp>delivery</samp> for HTTP State Tokens is <samp>same-site</samp>, we return early rather than generating a token for a cross-site request.</p></li>\n<li>Set <samp>token</samp> to the result of generating an HTTP State Token for <samp>target-origin</samp>, as defined in <a href=\"#generate\">Section 3.3.1</a>.</li>\n</ol>\n</li>\n<li>If the response’s header list contains <samp>Sec-Http-State-Options</samp>, then:  <ol>\n<li>Let <samp>header</samp> be the result of getting response’s <samp>Sec-Http-State-Options</samp> header, and parsing parsing it per the algorithm in Section 4.2 of <a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>.</li>\n<li>Return without altering <samp>response-origin</samp>’s HTTP State Token if any of the following conditions hold:      <ul>\n<li>Parsing the header results in failure.</li>\n<li>\n<samp>header</samp> has a member named <samp>key</samp> whose value is not a byte sequence (Section 3.10 of <a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>)</li>\n<li>\n<samp>header</samp> has a member named <samp>delivery</samp> whose value is not one of the following tokens (Section 3.9 of <a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>): “same-origin”, “same-site”, and “cross-site”.</li>\n<li>\n<samp>header</samp> has a member named <samp>max-age</samp> whose value is not a positive integer (Section 3.6 of <a href=\"#I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</a>).</li>\n</ul>\n</li>\n<li>If <samp>header</samp> has a member named <samp>key</samp>, set <samp>token</samp>’s <samp>key</samp> to the member’s value.</li>\n<li>If <samp>header</samp> has a member named <samp>delivery</samp>, set <samp>token</samp>’s <samp>delivery</samp> to the member’s value.</li>\n<li>If <samp>header</samp> has a member named <samp>max-age</samp>:      <ol><li>If the member’s value is <samp>0</samp>, generate a new HTTP State Token for <samp>response-origin</samp> as defined in <a href=\"#generate\">Section 3.3.1</a>.          <p> Otherwise, set <samp>token</samp>’s <samp>max-age</samp> to the member’s value.</p></li></ol>\n<p> Note that </p>\n<samp>max-age</samp> is processed last, meaning that any other options specified alongside <samp>max-age=0</samp> will be de facto ignored as a new token is generated, replacing the old.</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"rfc.section.7\">\n<a href=\"#rfc.section.7\">7.</a> <a href=\"#security-and-privacy-considerations\" id=\"security-and-privacy-considerations\">Security and Privacy Considerations</a>\n</h2>\n<p id=\"rfc.section.7.p.1\">HTTP State Tokens aim to mitigate some of the security and privacy drawbacks that decades of implementation experience with cookies have laid bare. It would be worthwhile to skim through the privacy considerations (Section 7 of <a href=\"#RFC6265\">[RFC6265]</a>) and security considerations (Section 8 of <a href=\"#RFC6265\">[RFC6265]</a>) of that existing state management mechanism, as it forms a foundation upon which this document builds.</p>\n<h2 id=\"rfc.section.7.1\">\n<a href=\"#rfc.section.7.1\">7.1.</a> <a href=\"#confidentiality-and-integrity\" id=\"confidentiality-and-integrity\">Confidentiality and Integrity</a>\n</h2>\n<p id=\"rfc.section.7.1.p.1\">HTTP State Tokens improve upon cookies’ weak confidentiality/integrity guarantees (see Sections 8.3, 8.5, 8.6, and 8.7 of <a href=\"#RFC6265\">[RFC6265]</a>) in several ways:</p>\n\n\n<ol>\n<li>User agents MUST require secure channels (such as TLS) for delivery and configuration of HTTP State Tokens. User agents cannot be induced to deliver an origin’s tokens across channels visible to (and modifiable by) network attackers, nor can an attack on DNS cause tokens to be revealed (as any server to which the user could be directed will also need to authenticate itself, which is presumably difficult).</li>\n<li>HTTP State Tokens are mapped to origins, matching developers expectations for client-side data generally. This ensures that tokens are isolated by host and port: code running on <samp>https://bar.example.com/</samp> cannot alter state on <samp>https://foo.example.com/</samp> without the latter’s cooperation, and that the same applies to <samp>https://example.com:8000/</samp> and <samp>https://example.com:80/</samp>.  <p> Note that this origin binding means that there are no path restrictions for tokens. Servers relying upon these tokens for state management SHOULD NOT run mutually distrusting services on different paths of the same origin.</p></li>\n<li>User agents MUST NOT expose HTTP State Tokens to non-HTTP APIs which are web-accessible, thereby reducing the risk of accidental exposure via cross-site scripting attack.  <p> Further, the <samp>Sec-</samp> prefix on both <samp>Sec-HTTP-State</samp> and <samp>Sec-HTTP-State-Options</samp> ensures that both are considered “forbidden header names” by <a href=\"#Fetch\">[Fetch]</a>. The latter should also be treated as a “forbidden response header”.</p></li>\n</ol>\n<h2 id=\"rfc.section.7.2\">\n<a href=\"#rfc.section.7.2\">7.2.</a> <a href=\"#signed-sessions\" id=\"signed-sessions\">Signed Sessions</a>\n</h2>\n<p id=\"rfc.section.7.2.p.1\">HTTP State Tokens embrace the session identifier pattern discussed in Section 8.4 of <a href=\"#RFC6265\">[RFC6265]</a> by requiring that the client control the token’s value, setting it to a fixed-length, random byte sequence. The client’s control mitigates the risk of sensitive information being stored in the token directly, and the token’s length makes it unlikely to be easily guessed.</p>\n<p id=\"rfc.section.7.2.p.2\">Some servers will be interested in proving the token’s provenance over time, which they do today by storing cookies with signed values. Since storing a signed value directly is impossible in a client-controlled world, servers can instead store a <samp>key</samp>, which is used to sign outgoing requests.  Since this key is never exposed directly to the web, it provides a reasonable guarantee of client stability over time which a server can rely upon when making risk judgements.</p>\n<h2 id=\"rfc.section.7.3\">\n<a href=\"#rfc.section.7.3\">7.3.</a> <a href=\"#user-control\" id=\"user-control\">User Control</a>\n</h2>\n<p id=\"rfc.section.7.3.p.1\">User agents MUST provide users with the ability to control the creation and distribution of HTTP State Tokens, just as they do for cookies today. This certainly means providing controls over first- vs third-party distribution, control over the origins which can store state, control over the state presented to origins, visibility into the state of the user agent’s token store, and etc.</p>\n<p id=\"rfc.section.7.3.p.2\">Further, this document grants user agents wide latitude to experiment with various distribution policies and limitations. The capabilities offered by <samp>delivery</samp> and <samp>max-age</samp> should be considered upper bounds on distribution, within which user agents are free to roam.</p>\n<h2 id=\"rfc.section.7.4\">\n<a href=\"#rfc.section.7.4\">7.4.</a> <a href=\"#lifetime\" id=\"lifetime\">Lifetime</a>\n</h2>\n<p id=\"rfc.section.7.4.p.1\">By default, HTTP State Tokens live for an hour, which is a compromise between the reasonable desire of servers to maintain state across a given user’s session, and the privacy risks associated with long-lived tokens stored on a user’s disk.</p>\n<p id=\"rfc.section.7.4.p.2\">Servers that desire a longer session lifetime can explicitly request an extension, which the browser can choose to act on.</p>\n<h2 id=\"rfc.section.7.5\">\n<a href=\"#rfc.section.7.5\">7.5.</a> \n</h2>\n<p id=\"rfc.section.7.5.p.1\">HTTP State Tokens, like cookies, provide a form of ambient authority (see Section 8.2 of <a href=\"#RFC6265\">[RFC6265]</a>). By default, this authority is limited to requests initiated by same-site actors, which serves as a reasonable mitigation against some classes of attack (e.g. <samp>https://evil.com/</samp> making authenticated requests to <samp>https://example.com/</samp>).</p>\n<p id=\"rfc.section.7.5.p.2\">Servers that desire to interact in an authenticated manner in cross-site contexts are required to opt-into doing so by delivering an appropriate <samp>delivery</samp> value in a <samp>Sec-HTTP-State-Options</samp> response header. Servers which choose to do so SHOULD take reasonable precautions, implementing CSRF tokens for sensitive actions, and taking stock of the context from which a given request is initiated (by examining incoming <samp>Referrer</samp>, <samp>Origin</samp>, and <samp>Sec-Fetch-Site</samp> headers).</p>\n<p id=\"rfc.section.7.5.p.3\">Further, tokens can only be created in same-origin or same-site contexts, which means that cross-site identifier would only be available after the relevant origin was visited in a same-site context, and explicitly declared its tokens as being deliverable cross-site (at which point the user agent is empowered to make some decisions about how to handle that declaration).</p>\n<h2 id=\"rfc.section.8\">\n<a href=\"#rfc.section.8\">8.</a> <a href=\"#implementation-considerations\" id=\"implementation-considerations\">Implementation Considerations</a>\n</h2>\n<h2 id=\"rfc.section.8.1\">\n<a href=\"#rfc.section.8.1\">8.1.</a> <a href=\"#notify-reset\" id=\"notify-reset\">Notifying developers on token reset</a>\n</h2>\n<p id=\"rfc.section.8.1.p.1\">Step 4 of the token generation algorithm (<a href=\"#generate\">Section 3.3.1</a>) recognizes that user agents may wish to notify an origin’s developers that HTTP state has been reset in order to enable cleanup of state stored client-side. Embedding environments are encouraged to define an implementation of the <samp>NotifyHostHTTPStateReset(origin)</samp> algorithm that’s appropriate for the environment.</p>\n<p id=\"rfc.section.8.1.p.2\">For example, HTML may wish to enable developers to respond to token generation by posting a message to a specially-named <samp>BroadcastChannel</samp> for the to enable this kind of work:</p>\n<pre>let resetChannel = new BroadcastChannel('http-state-reset'));\nresetChannel.onmessage = e =&gt; { /* Do exciting cleanup here. */ };\n</pre>\n<p id=\"rfc.section.8.1.p.3\">This algorithm could take something like the following form:</p>\n<p id=\"rfc.section.8.1.p.4\">TODO(mkwst): Write a reasonable implementation of this once I have internet again.</p>\n<h2 id=\"rfc.section.9\">\n<a href=\"#rfc.section.9\">9.</a> <a href=\"#iana-considerations\" id=\"iana-considerations\">IANA Considerations</a>\n</h2>\n<h2 id=\"rfc.section.9.1\">\n<a href=\"#rfc.section.9.1\">9.1.</a> <a href=\"#header-field-registry\" id=\"header-field-registry\">Header Field Registry</a>\n</h2>\n<p id=\"rfc.section.9.1.p.1\">This document registers the <samp>Sec-Http-State</samp> and <samp>Sec-Http-State-Options</samp> header fields in the “Permanent Message Header Field Names” registry located at <a href=\"https://www.iana.org/assignments/message-headers\">https://www.iana.org/assignments/message-headers</a>.</p>\n<h2 id=\"rfc.section.9.1.1\">\n<a href=\"#rfc.section.9.1.1\">9.1.1.</a> <a href=\"#sec-http-state-header-field\" id=\"sec-http-state-header-field\">Sec-Http-State Header Field</a>\n</h2>\n\n\n<dl>\n<dt>Header field name:</dt>\n<dd>Sec-Http-State</dd>\n<dt>Applicable protocol:</dt>\n<dd>http</dd>\n<dt>Status:</dt>\n<dd>experimental</dd>\n<dt>Author/Change controller:</dt>\n<dd>IETF</dd>\n<dt>Specification document(s):</dt>\n<dd>This document (see <a href=\"#sec-http-state\">Section 4.1</a>)</dd>\n<dt>Related information:</dt>\n<dd>(empty)</dd>\n</dl>\n<h2 id=\"rfc.section.9.1.2\">\n<a href=\"#rfc.section.9.1.2\">9.1.2.</a> <a href=\"#sec-http-state-options-header-field\" id=\"sec-http-state-options-header-field\">Sec-Http-State-Options Header Field</a>\n</h2>\n\n\n<dl>\n<dt>Header field name:</dt>\n<dd>Sec-Http-State-Options</dd>\n<dt>Applicable protocol:</dt>\n<dd>http</dd>\n<dt>Status:</dt>\n<dd>experimental</dd>\n<dt>Author/Change controller:</dt>\n<dd>IETF</dd>\n<dt>Specification document(s):</dt>\n<dd>This document (see <a href=\"#sec-http-state-options\">Section 4.2</a>)</dd>\n<dt>Related information:</dt>\n<dd>(empty)</dd>\n</dl>\n<h2 id=\"rfc.references\">\n<a href=\"#rfc.references\">10.</a> References</h2>\n<h2 id=\"rfc.references.1\">\n<a href=\"#rfc.references.1\">10.1.</a> Normative References</h2>\n<table><tbody>\n<tr>\n<td><b id=\"Fetch\">[Fetch]</b></td>\n<td>\n<a title=\"Mozilla\">van Kesteren, A.</a>, \"<a href=\"https://fetch.spec.whatwg.org/\">Fetch</a>\", n.d..</td>\n</tr>\n<tr>\n<td><b id=\"I-D.ietf-httpbis-header-structure\">[I-D.ietf-httpbis-header-structure]</b></td>\n<td>\n<a>Nottingham, M.</a> and <a>P. Kamp</a>, \"<a href=\"https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-09\">Structured Headers for HTTP</a>\", Internet-Draft draft-ietf-httpbis-header-structure-09, December 2018.</td>\n</tr>\n<tr>\n<td><b id=\"I-D.yasskin-http-origin-signed-responses\">[I-D.yasskin-http-origin-signed-responses]</b></td>\n<td>\n<a>Yasskin, J.</a>, \"<a href=\"https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-05\">Signed HTTP Exchanges</a>\", Internet-Draft draft-yasskin-http-origin-signed-responses-05, January 2019.</td>\n</tr>\n<tr>\n<td><b id=\"Mixed-Content\">[Mixed-Content]</b></td>\n<td>\n<a title=\"Google\">West, M.</a>, \"<a href=\"https://w3c.github.io/webappsec-mixed-content/\">Mixed Content</a>\", n.d..</td>\n</tr>\n<tr>\n<td><b id=\"RFC2104\">[RFC2104]</b></td>\n<td>\n<a>Krawczyk, H.</a>, <a>Bellare, M.</a> and <a>R. Canetti</a>, \"<a href=\"https://tools.ietf.org/html/rfc2104\">HMAC: Keyed-Hashing for Message Authentication</a>\", RFC 2104, DOI 10.17487/RFC2104, February 1997.</td>\n</tr>\n<tr>\n<td><b id=\"RFC2109\">[RFC2109]</b></td>\n<td>\n<a>Kristol, D.</a> and <a>L. Montulli</a>, \"<a href=\"https://tools.ietf.org/html/rfc2109\">HTTP State Management Mechanism</a>\", RFC 2109, DOI 10.17487/RFC2109, February 1997.</td>\n</tr>\n<tr>\n<td><b id=\"RFC2119\">[RFC2119]</b></td>\n<td>\n<a>Bradner, S.</a>, \"<a href=\"https://tools.ietf.org/html/rfc2119\">Key words for use in RFCs to Indicate Requirement Levels</a>\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>\n</tr>\n<tr>\n<td><b id=\"RFC4648\">[RFC4648]</b></td>\n<td>\n<a>Josefsson, S.</a>, \"<a href=\"https://tools.ietf.org/html/rfc4648\">The Base16, Base32, and Base64 Data Encodings</a>\", RFC 4648, DOI 10.17487/RFC4648, October 2006.</td>\n</tr>\n<tr>\n<td><b id=\"RFC5234\">[RFC5234]</b></td>\n<td>\n<a>Crocker, D.</a> and <a>P. Overell</a>, \"<a href=\"https://tools.ietf.org/html/rfc5234\">Augmented BNF for Syntax Specifications: ABNF</a>\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>\n</tr>\n<tr>\n<td><b id=\"RFC7230\">[RFC7230]</b></td>\n<td>\n<a>Fielding, R.</a> and <a>J. Reschke</a>, \"<a href=\"https://tools.ietf.org/html/rfc7230\">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>\", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>\n</tr>\n<tr>\n<td><b id=\"RFC7409\">[RFC7409]</b></td>\n<td>\n<a>Haleplidis, E.</a> and <a>J. Halpern</a>, \"<a href=\"https://tools.ietf.org/html/rfc7409\">Forwarding and Control Element Separation (ForCES) Packet Parallelization</a>\", RFC 7409, DOI 10.17487/RFC7409, November 2014.</td>\n</tr>\n<tr>\n<td><b id=\"RFC8174\">[RFC8174]</b></td>\n<td>\n<a>Leiba, B.</a>, \"<a href=\"https://tools.ietf.org/html/rfc8174\">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>\n</tr>\n</tbody></table>\n<h2 id=\"rfc.references.2\">\n<a href=\"#rfc.references.2\">10.2.</a> Informative References</h2>\n<table><tbody>\n<tr>\n<td><b id=\"I-D.abarth-cake\">[I-D.abarth-cake]</b></td>\n<td>\n<a>Barth, A.</a>, \"<a href=\"https://tools.ietf.org/html/draft-abarth-cake-01\">Origin Cookies</a>\", Internet-Draft draft-abarth-cake-01, March 2011.</td>\n</tr>\n<tr>\n<td><b id=\"I-D.ietf-cbor-cddl\">[I-D.ietf-cbor-cddl]</b></td>\n<td>\n<a>Birkholz, H.</a>, <a>Vigano, C.</a> and <a>C. Bormann</a>, \"<a href=\"https://tools.ietf.org/html/draft-ietf-cbor-cddl-08\">Concise data definition language (CDDL): a notational convention to express CBOR and JSON data structures</a>\", Internet-Draft draft-ietf-cbor-cddl-08, March 2019.</td>\n</tr>\n<tr>\n<td><b id=\"RFC6265\">[RFC6265]</b></td>\n<td>\n<a>Barth, A.</a>, \"<a href=\"https://tools.ietf.org/html/rfc6265\">HTTP State Management Mechanism</a>\", RFC 6265, DOI 10.17487/RFC6265, April 2011.</td>\n</tr>\n</tbody></table>\n<h2 id=\"rfc.appendix.A\">\n<a href=\"#rfc.appendix.A\">Appendix A.</a> <a href=\"#acknowledgements\" id=\"acknowledgements\">Acknowledgements</a>\n</h2>\n<p id=\"rfc.section.A.p.1\">This document owes much to Adam Barth’s <a href=\"#I-D.abarth-cake\">[I-D.abarth-cake]</a> and <a href=\"#RFC6265\">[RFC6265]</a>.</p>\n<h2 id=\"rfc.appendix.B\">\n<a href=\"#rfc.appendix.B\">Appendix B.</a> <a href=\"#changes\" id=\"changes\">Changes</a>\n</h2>\n<p><em>RFC Editor: Please remove this section before publication.</em></p>\n\n\n<ul>\n<li>-01 <ul>\n<li>General editorial cleanup.</li>\n<li>Explanation of <samp>NotifyHostHTTPStateReset(origin)</samp> algorithm in <a href=\"#notify-reset\">Section 8.1</a>.</li>\n</ul>\n</li>\n<li>-00 <ul><li>This document was created.</li></ul>\n</li>\n</ul>\n<h2 id=\"rfc.authors\"><a href=\"#rfc.authors\">Author's Address</a></h2>\n<p>\n  <address>\n\t<span>\n\t  <span>Mike West</span> \n\t  <span>\n\t\t<span>West</span>\n\t  </span>\n\t</span>\n\t<span>Google</span>\n\t<span>\n\t  \n\t  <span>\n\t\t<span></span> \n\t\t<span></span>\n\t\t<span></span>\n\t  </span>\n\t  <span></span>\n\t</span>\n\t<span>EMail: <a href=\"mailto:mkwst@google.com\">mkwst@google.com</a></span>\n\n<span>URI: <a href=\"https://www.mikewest.org/\">https://www.mikewest.org/</a></span>\n\n  </address>\n</p>\n\n\n\n</div>","textContent":"\n\n  \n\n  HTTP State Tokens\n  draft-west-http-state-tokens-latest\n  \n  Abstract\nThis document describes a mechanism which allows HTTP servers to maintain stateful sessions with HTTP user agents. It aims to address some of the security and privacy considerations which have been identified in existing state management mechanisms, providing developers with a well-lit path towards our current understanding of best practice.\nStatus of This Memo\nThis Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.\nInternet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.\nInternet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as \"work in progress.\"\nThis Internet-Draft will expire on October 3, 2019.\nCopyright Notice\nCopyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.\nThis document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.\n\n  \n  \n  Table of Contents\n  \n\n  \t1.   Introduction\n\n1.1.   Wait. Don’t we already have cookies?\n\n1.2.   No. Really. We have cookies today. Why do we need this new thing?\n\n1.3.   Examples\n\n2.   Conventions\n\n2.1.   Conformance\n\n2.2.   Syntax\n\n3.   Infrastructure\n\n3.1.   HTTP State Tokens\n\n3.2.   Requests and Responses\n\n3.3.   Token Storage\n\n4.   Syntax\n\n4.1.   The ‘Sec-Http-State’ HTTP Header Field\n\n4.2.   The ‘Sec-Http-State-Options’ HTTP Header Field\n\n5.   Delivering HTTP State Tokens\n\n5.1.   Attach HTTP State Tokens to a request\n\n5.2.   Generate a request’s signature\n\n6.   Configuring HTTP State Tokens\n\n7.   Security and Privacy Considerations\n\n7.1.   Confidentiality and Integrity\n\n7.2.   Signed Sessions\n\n7.3.   User Control\n\n7.4.   Lifetime\n\n7.5.   Ambient Authority and Cross-Site Delivery\n\n8.   Implementation Considerations\n\n8.1.   Notifying developers on token reset\n\n9.   IANA Considerations\n\n9.1.   Header Field Registry\n\n10.   References\n\n10.1.   Normative References\n\n10.2.   Informative References\n\nAppendix A.   Acknowledgements\n\nAppendix B.   Changes\n\nAuthor's Address\n\n\n\n  \n\n  \n1. Introduction\n\nThis document defines a state-management mechanism for HTTP that allows clients to create and persist origin-bound session identifiers that can be delivered to servers in order to enable stateful interaction. In a nutshell, each user agent will generate a single token per secure origin, and will deliver it as a Sec-Http-State structured header along with requests to that origin (defined in Section 4.1 and Section 5).\nServers can configure this token’s characteristics via a Sec-Http-State-Options response header (defined in Section 4.2 and Section 6).\nThat’s it.\n\n1.1. Wait. Don’t we already have cookies?\n\nCookies [RFC6265] are indeed a pervasive HTTP state management mechanism in the status quo, and they enable practically everything interesting on the web today. That said, cookies have some issues: they’re hard to use securely, they add substantial weight to users’ outgoing requests, and they enable tracking users’ activity across the web in potentially surprising ways.\nThe mechanism proposed in this document aims at a more minimal and opinionated construct which takes inspiration from some of cookies’ optional characteristics. In particular:\n\n\n\nThe client controls the token’s value, not the server.\nThe token will only be available to the network layer, not to JavaScript (including network-like JavaScript, such as Service Workers).\nThe user agent will generate only one token per origin, and will only expose the token to the origin for which it was generated.\nTokens will not be generated for, or delivered to, non-secure origins.\nBy default, token delivery and configuration is constrained to same-site requests.\nEach token persists for one hour after generation by default. This default expiration time can be overwritten by servers, and tokens can be reset at any time by servers, users, or user agents.\n\nThese distinctions might not be appropriate for all use cases, but seem like a reasonable set of defaults. For folks for whom these defaults aren’t good enough, we’ll provide developers with a few control points that can be triggered via a Sec-HTTP-State-Options HTTP response header, described in Section 4.2.\n\n1.2. No. Really. We have cookies today. Why do we need this new thing?\n\nWe do have cookies. And we’ve defined a number of extensions to cookies to blunt some of their sharper edges: the HttpOnly attribute, the Secure attribute, SameSite, prefixes like __Host- and __Secure-, and so on. It’s reasonable to suggest that pushing developers towards these existing flags on our existing state management primitive is the right way forward.\nA counterpoint is that we’re collectively pretty bad at helping developers understand the risks that might lead them to adopt The Good Cookie Syntax(tm) above. Adoption of these features has been quite slow. The Secure flag, for example, has been around since at least 1997 [RFC2109], and is hovering around 9% adoption based on data gathered from Chrome’s telemetry in March, 2019. In that dataset, cookies’ other properties are set as follows:\n\n\n\n~6.8% of cookies are set with HttpOnly.\n~5.5% are set with Secure.\n~3.1% are set with HttpOnly; Secure.\n~0.06% are set with SameSite=*; Secure.\n~0.05% are set with SameSite=*.\n~0.03% are set with HttpOnly; Secure; SameSite=*.\n~0.006% are set with SameSite=*; HttpOnly.\n~0.005% are set with a __Secure- prefix.\n~0.01% are set with a __Host- prefix.\n\nIn total:\n\n\n\n~9.9% of cookies are marked as HttpOnly.\n~8.8% of cookies are marked as Secure.\n~0.1% of cookies are marked as SameSite.\n~84.2% of cookies use none of these features.\n\nThis document’s underlying assumption is that it’s going to be easier to teach developers about a crazy new thing that’s secure by default than it would be to convince them to change their Set-Cookie headers to be more like __Host-name=value; HttpOnly; Secure; SameSite=Lax; Path=/. A new thing resets expectations in a way that vastly exceeds the impact of explanations about the the four attributes that must be used, the one attribute that must not be used, and the weird naming convention that ought to be adopted.\n\n1.3. Examples\n\nUser agents can deliver HTTP state tokens to a server in a Sec-Http-State header. For example, if a user agent has generated a token bound to https://example.com/ whose base64 encoding is hB2RfWaGyNk60sjHze5DzGYjSnL7tRF2HWSBx6J1o4k= ([RFC4648], Section 4), then it would generate the following header when delivering the token along with requests to https://example.com/:\nSec-Http-State: token=*hB2RfWaGyNk60sjHze5DzGYjSnL7tRF2HWSBx6J1o4k*\n\nThe server can control certain aspects of the token’s delivery by responding to requests with a Sec-Http-State-Options header:\nSec-Http-State-Options: max-age=3600, key=*b7kuUkp...lkRioC2=*\n\n\n2. Conventions\n\n\n2.1. Conformance\n\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.\n\n2.2. Syntax\n\nThis document defines two Structured Headers [I-D.ietf-httpbis-header-structure]. In doing so it relies upon the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] and the OWS rule from [RFC7230].\n\n3. Infrastructure\n\n\nAn HTTP State Token holds a session identifier which allows a user agent to maintain a stateful session with a specific origin, along with associated metadata:\n\n\n\n\ncreation is a timestamp representing the point in time when the token was created.\n\ndelivery specifies the initiating contexts from which the token can be delivered. It is an enum of either same-origin, same-site, or cross-site. Unless otherwise specified, its value is same-site.\n\nkey is a server-provided key which can be used to sign requests with which the token is delivered. It is either null, or contains up to 256-bits of binary data. Unless otherwise specified, its value is null.\n\nmax-age is a number representing the token’s lifetime in seconds. Unless otherwise specified, its value is 3600 (1 hour).\n\nvalue is the token’s value (surprising, right?). It contains up to 256-bits of binary data.\n\nAn HTTP State Token is said to be “expired” if its creation timestamp plus max-age seconds is in the past.\n\n3.2. Requests and Responses\n\nThis document relies upon the definitions of “request” and “response” found in [Fetch].\nA request’s delivery scope is same-origin if the request’s initiator and target are exactly the same origin, same-site if the request’s initiator and target are not same-origin but share a registrable domain (e.g. https://www.example.com/ and https://not-www.example.com/), and cross-site otherwise. The following algorithm spells this relationship out more formally:\n\n\n\nIf the request was generated by the user agent as a response to direct user interaction with the user agent (e.g. the user typed an address into the agent’s address bar, clicked a bookmark, or etc.), return same-origin.\nLet request-origin be the request’s origin, and target-origin be the request’s URL’s origin.\nIf request-origin is same-origin with target-origin, return same-origin.\nIf request-origin’s registrable domain is the same as target-origin’s registrable domain, return same-site.\nReturn cross-site.\n\n\n3.3. Token Storage\n\nUser agents MUST keep a list of all the unexpired HTTP State Tokens which have been created. For the purposes of this document, we’ll assume that user agents keep this list in the form of a map whose keys are origins, and whose values are HTTP State Tokens.\nThis map exposes three functions:\n\n\n\nAn HTTP State Token can be stored for a given origin. If the origin already exists in the map, the entry’s value will be overwritten with the new HTTP State Token.\nAn origin’s HTTP State Token can be retrieved. If the origin does not exist in the map, null will be returned instead.\nAn origin (along with its HTTP State Token) can be deleted from the map.\n\nThe map is initially empty.\n\n3.3.1. Generate an HTTP State Token for an origin\n\nThe user agent MUST generate a new HTTP State Token for an origin using an algorithm equivalent to the following:\n\n\n\nDelete origin from the user agent’s token store.\nLet token be a newly created HTTP State Token with its properties set as follows:  \n\ncreation: The current time.\n\ndelivery: same-site\n\n\nkey: null\n\nmax-age: 3600\n\nvalue: 256 cryptographically random bits.\n\n\nStore token in the user agent’s token store for origin.\nIf the user agent has defined a NotifyHostHTTPStateReset(origin) algorithm, call it with origin (see Section 8.1 for more context on this step).\nReturn token.\n\n\n4. Syntax\n\n\n4.1. The ‘Sec-Http-State’ HTTP Header Field\n\nThe Sec-Http-State HTTP header field allows user agents to deliver HTTP state tokens to servers as part of an HTTP request.\nSec-Http-State is a Structured Header [I-D.ietf-httpbis-header-structure]. Its value MUST be a dictionary ([I-D.ietf-httpbis-header-structure], Section 3.1). Its ABNF is:\nSec-Http-State = sh-dictionary\n\nThe dictionary MUST contain:\n\n\nExactly one member whose key is token, and whose value is binary content ([I-D.ietf-httpbis-header-structure], Section 3.9) that encodes the HTTP state token’s value for the origin to which the header is delivered.   If the token member contains more than 256 bits of binary content, the member MUST be ignored.\nThe dictionary MAY contain:\n\n\nExactly one member whose key is sig, and whose value is binary content ([I-D.ietf-httpbis-header-structure], Section 3.9) that encodes a signature over the token and the request which contains it, using a key previously delivered by the server. This mechanism is described in Section 5.2.   If the sig member contains more than 256 bits of binary content, the member MUST be ignored.\nThe Sec-Http-State header is parsed per the algorithm in Section 4.2 of [I-D.ietf-httpbis-header-structure]. Servers MUST ignore the header if parsing fails, or if the parsed header does not contain a member whose key is token.\nUser agents will attach a Sec-Http-State header to outgoing requests according to the processing rules described in Section 5.\n\n4.2. The ‘Sec-Http-State-Options’ HTTP Header Field\n\nThe Sec-Http-State-Options HTTP header field allows servers to deliver configuration information to user agents as part of an HTTP response.\nSec-Http-State-Options is a Structured Header [I-D.ietf-httpbis-header-structure]. Its value MUST be a dictionary ([I-D.ietf-httpbis-header-structure], Section 3.1). Its ABNF is:\nSec-Http-State-Options = sh-dictionary\n\nThe Sec-Http-State-Options header is parsed per the algorithm in Section 4.2 of [I-D.ietf-httpbis-header-structure]. User agents MUST ignore the header if parsing fails.\nThe dictionary MAY contain:\n\n\n\nExactly one member whose key is key, and whose value is binary content ([I-D.ietf-httpbis-header-structure], Section 3.10) that encodes an key which can be used to generate a signature over outgoing requests.\nExactly one member whose key is delivery, and whose value is one of the following tokens ([I-D.ietf-httpbis-header-structure], Section 3.9): same-origin, same-site, or cross-site.   If the delivery member contains an unknown identifier, the member MUST be ignored.\nExactly one member whose key is max-age, and whose value is an integer ([I-D.ietf-httpbis-header-structure], Section 3.6) representing the server’s desired lifetime for its HTTP State Token.   If the max-age member contains anything other than a positive integer, the member MUST be ignored.\n\nUser agents will process the Sec-Http-State-Options header on incoming responses according to the processing rules described in Section 6.\n\n4.2.1. Examples\n\n\n4.2.1.1. Cross-Site Delivery\n\nSome servers will require access to their tokens from cross-site contexts (perhaps to support authenticated activity or single-sign on, etc). These servers can request a cross-site delivery option by delivering the following header:\nSec-Http-State-Options: delivery=cross-site, ...\n\n\n4.2.1.2. Token Lifetime\n\nOther servers might want their sessions to persist for more than an hour. These servers can request a more reasonable token lifetime lifetime by by delivering the following header:\nSec-Http-State-Options: max-age=2592000, ...\n\nServers may also wish to explicitly trigger the token’s expiration (upon signout, for instance).  Setting a max-age of 0 does the trick:\nSec-Http-State-Options: max-age=0, ...\n\n\n4.2.1.3. Token Provenance\n\nFor some servers, the client-generated token will be enough to maintain state. They can treat it as an opaque session identifier, and bind the user’s state to it server-side. Other servers will require additional assurance that they can trust the token’s provenance. To that end, servers can generate a unique key, associate it with the session identifier on the server, and deliver it to the client via an HTTP response header:\nSec-Http-State-Options: key=*ZH0GxtBMWA...nJudhZ8dtz*, ...\n\nClients will store that key, and use it to generate a signature over some set of data that mitigates the risk of token capture:\nSec-HTTP-State:\n    token=*J6BRKa...MonM*,\n    sig=*(HMAC-SHA256(key, token+metadata))*\n\nNote: This part in particular is not fully baked, and we need to do some more work to flesh out the threat model (see also Token Binding). Look at it as an area to explore, not a solidly thought-out solution.\n\n5. Delivering HTTP State Tokens\n\nUser agents deliver HTTP state tokens to servers by appending a Sec-Http-State header field to outgoing requests.\nThis specification provides algorithms which are called at the appropriate points in [Fetch] in order to attach Sec-Http-State headers to outgoing requests, and to ensure that Sec-Http-State-Options headers are correctly processed.\n\n5.1. Attach HTTP State Tokens to a request\n\nThe user agent can attach HTTP State Tokens to a given request using an algorithm equivalent to the following. This algorithm is intended to execute as the request is being sent out over the network (after Service Worker processing), perhaps after the Cookie header is handled in step 5.17.1 of Section 4.5 of [Fetch], describing the “HTTP-network-or-cache fetch” algorithm:\n\n\n\nIf the user agent is configured to suppress explicit identifiers for the request, or if the request’s URL is not a priori authenticated [Mixed-Content], then skip the remaining steps in this algorithm, and return without modifying the request.\nLet target-origin be the origin of request’s current URL.\nLet request-token be the result of retrieving origin’s token from the user agent’s token store, or null if no such token exists.\nIf request-token is expired, clear the user agent’s token store for target-origin, and set request-token to null.\nIf request-token is null, then:  \nIf request’s delivery scope is cross-site, return without modifying the request.       Note: As the default delivery for HTTP State Tokens is same-site, we return early rather than generating a token for a cross-site request.\nSet request-token to the result of generating an HTTP State Token for target-origin, as defined in Section 3.3.1.\n\n\nReturn without modifying the request if either of the following statements are true:  \n\nrequest-token’s delivery is same-origin, and request’s delivery scope is not same-origin.\n\nrequest-token’s delivery is same-site, and request’s delivery scope is neither same-origin nor same-site.\n\n\nLet serialized-value be the base64 encoding ([RFC4648], Section 4) of request-token’s value.\nInsert a member into header-value whose key is token and whose value is serialized-value.\nIf request-token’s key is not null, then insert a member into header-value whose key is sig, and whose value is the result of executing Section 5.2 on request, serialized-value, and request-token’s key.\nAppend a header to request’s header list whose name is Sec-Http-State, and whose value is the result of serializing header-value ([I-D.ietf-httpbis-header-structure], Section 4.1).\n\n\n5.2. Generate a request’s signature\n\nIf the origin server provides a key, the user agent will use it to sign any outgoing requests which target that origin and include an HTTP State Token. Note that the signature is produced before adding the Sec-Http-State header to the request.\nGiven a request, a base64-encoded token value, and a key:\n\n\n\nLet cbor-request be the result of building a CBOR representation [RFC7409] of the given request, as specified in the first element of the array described in Section 3.2 of [I-D.yasskin-http-origin-signed-responses].\nAdd an item to cbor-request which maps the byte string ‘:token’ to the byte string containing the given base64-encoded token value.\nReturn the result of computing HMAC-SHA256 [RFC2104] over the canonical CBOR serialization of cbor-request (Section 3.4 of [I-D.yasskin-http-origin-signed-responses]), using the given key.\n\n\n5.2.1. Example\n\nThe following request:\nGET / HTTP/1.1\nHost: example.com\nAccept: */*\n\nresults in the following CBOR representation (represented using the extended diagnostic notation from Appendix G of [I-D.ietf-cbor-cddl]):\n{\n  ':method': 'GET',\n  ':token': 'hB2RfWaGyNk60sjHze5DzGYjSnL7tRF2HWSBx6J1o4k='\n  ':url': 'https://example.com/',\n  'accept': '*/*',\n}\n\n\n6. Configuring HTTP State Tokens\n\nServers configure the HTTP State Token representing a given users’ state by appending a Sec-Http-State-Options header field to outgoing responses.\nUser agents MUST process this header on a given response as per the following algorithm, which is intended to be called after the Set-Cookie header is handled in step 11.4 of Section 4.6 of [Fetch], which defines the “HTTP-network fetch” algorithm.\n\n\n\nLet response-origin be the origin of response’s URL.\nIf the response’s URL is not a priori authenticated [Mixed-Content], return without altering response-origin’s HTTP State Token.\nLet token be the result of retrieving response-origin’s token from the user agent’s token store, or null if no such token exists.\nIf token is expired, clear the user agent’s token store for response-origin, and set token to null.\nIf token is null, then:  \nIf request’s delivery scope is cross-site, return without modifying the request.       Note: As the default delivery for HTTP State Tokens is same-site, we return early rather than generating a token for a cross-site request.\nSet token to the result of generating an HTTP State Token for target-origin, as defined in Section 3.3.1.\n\n\nIf the response’s header list contains Sec-Http-State-Options, then:  \nLet header be the result of getting response’s Sec-Http-State-Options header, and parsing parsing it per the algorithm in Section 4.2 of [I-D.ietf-httpbis-header-structure].\nReturn without altering response-origin’s HTTP State Token if any of the following conditions hold:      \nParsing the header results in failure.\n\nheader has a member named key whose value is not a byte sequence (Section 3.10 of [I-D.ietf-httpbis-header-structure])\n\nheader has a member named delivery whose value is not one of the following tokens (Section 3.9 of [I-D.ietf-httpbis-header-structure]): “same-origin”, “same-site”, and “cross-site”.\n\nheader has a member named max-age whose value is not a positive integer (Section 3.6 of [I-D.ietf-httpbis-header-structure]).\n\n\nIf header has a member named key, set token’s key to the member’s value.\nIf header has a member named delivery, set token’s delivery to the member’s value.\nIf header has a member named max-age:      If the member’s value is 0, generate a new HTTP State Token for response-origin as defined in Section 3.3.1.           Otherwise, set token’s max-age to the member’s value.\n Note that \nmax-age is processed last, meaning that any other options specified alongside max-age=0 will be de facto ignored as a new token is generated, replacing the old.\n\n\n\n\n7. Security and Privacy Considerations\n\nHTTP State Tokens aim to mitigate some of the security and privacy drawbacks that decades of implementation experience with cookies have laid bare. It would be worthwhile to skim through the privacy considerations (Section 7 of [RFC6265]) and security considerations (Section 8 of [RFC6265]) of that existing state management mechanism, as it forms a foundation upon which this document builds.\n\n7.1. Confidentiality and Integrity\n\nHTTP State Tokens improve upon cookies’ weak confidentiality/integrity guarantees (see Sections 8.3, 8.5, 8.6, and 8.7 of [RFC6265]) in several ways:\n\n\n\nUser agents MUST require secure channels (such as TLS) for delivery and configuration of HTTP State Tokens. User agents cannot be induced to deliver an origin’s tokens across channels visible to (and modifiable by) network attackers, nor can an attack on DNS cause tokens to be revealed (as any server to which the user could be directed will also need to authenticate itself, which is presumably difficult).\nHTTP State Tokens are mapped to origins, matching developers expectations for client-side data generally. This ensures that tokens are isolated by host and port: code running on https://bar.example.com/ cannot alter state on https://foo.example.com/ without the latter’s cooperation, and that the same applies to https://example.com:8000/ and https://example.com:80/.   Note that this origin binding means that there are no path restrictions for tokens. Servers relying upon these tokens for state management SHOULD NOT run mutually distrusting services on different paths of the same origin.\nUser agents MUST NOT expose HTTP State Tokens to non-HTTP APIs which are web-accessible, thereby reducing the risk of accidental exposure via cross-site scripting attack.   Further, the Sec- prefix on both Sec-HTTP-State and Sec-HTTP-State-Options ensures that both are considered “forbidden header names” by [Fetch]. The latter should also be treated as a “forbidden response header”.\n\n\n7.2. Signed Sessions\n\nHTTP State Tokens embrace the session identifier pattern discussed in Section 8.4 of [RFC6265] by requiring that the client control the token’s value, setting it to a fixed-length, random byte sequence. The client’s control mitigates the risk of sensitive information being stored in the token directly, and the token’s length makes it unlikely to be easily guessed.\nSome servers will be interested in proving the token’s provenance over time, which they do today by storing cookies with signed values. Since storing a signed value directly is impossible in a client-controlled world, servers can instead store a key, which is used to sign outgoing requests.  Since this key is never exposed directly to the web, it provides a reasonable guarantee of client stability over time which a server can rely upon when making risk judgements.\n\n7.3. User Control\n\nUser agents MUST provide users with the ability to control the creation and distribution of HTTP State Tokens, just as they do for cookies today. This certainly means providing controls over first- vs third-party distribution, control over the origins which can store state, control over the state presented to origins, visibility into the state of the user agent’s token store, and etc.\nFurther, this document grants user agents wide latitude to experiment with various distribution policies and limitations. The capabilities offered by delivery and max-age should be considered upper bounds on distribution, within which user agents are free to roam.\n\n7.4. Lifetime\n\nBy default, HTTP State Tokens live for an hour, which is a compromise between the reasonable desire of servers to maintain state across a given user’s session, and the privacy risks associated with long-lived tokens stored on a user’s disk.\nServers that desire a longer session lifetime can explicitly request an extension, which the browser can choose to act on.\n\n7.5. \n\nHTTP State Tokens, like cookies, provide a form of ambient authority (see Section 8.2 of [RFC6265]). By default, this authority is limited to requests initiated by same-site actors, which serves as a reasonable mitigation against some classes of attack (e.g. https://evil.com/ making authenticated requests to https://example.com/).\nServers that desire to interact in an authenticated manner in cross-site contexts are required to opt-into doing so by delivering an appropriate delivery value in a Sec-HTTP-State-Options response header. Servers which choose to do so SHOULD take reasonable precautions, implementing CSRF tokens for sensitive actions, and taking stock of the context from which a given request is initiated (by examining incoming Referrer, Origin, and Sec-Fetch-Site headers).\nFurther, tokens can only be created in same-origin or same-site contexts, which means that cross-site identifier would only be available after the relevant origin was visited in a same-site context, and explicitly declared its tokens as being deliverable cross-site (at which point the user agent is empowered to make some decisions about how to handle that declaration).\n\n8. Implementation Considerations\n\n\n8.1. Notifying developers on token reset\n\nStep 4 of the token generation algorithm (Section 3.3.1) recognizes that user agents may wish to notify an origin’s developers that HTTP state has been reset in order to enable cleanup of state stored client-side. Embedding environments are encouraged to define an implementation of the NotifyHostHTTPStateReset(origin) algorithm that’s appropriate for the environment.\nFor example, HTML may wish to enable developers to respond to token generation by posting a message to a specially-named BroadcastChannel for the to enable this kind of work:\nlet resetChannel = new BroadcastChannel('http-state-reset'));\nresetChannel.onmessage = e => { /* Do exciting cleanup here. */ };\n\nThis algorithm could take something like the following form:\nTODO(mkwst): Write a reasonable implementation of this once I have internet again.\n\n9. IANA Considerations\n\n\n9.1. Header Field Registry\n\nThis document registers the Sec-Http-State and Sec-Http-State-Options header fields in the “Permanent Message Header Field Names” registry located at https://www.iana.org/assignments/message-headers.\n\n9.1.1. Sec-Http-State Header Field\n\n\n\n\nHeader field name:\nSec-Http-State\nApplicable protocol:\nhttp\nStatus:\nexperimental\nAuthor/Change controller:\nIETF\nSpecification document(s):\nThis document (see Section 4.1)\nRelated information:\n(empty)\n\n\n9.1.2. Sec-Http-State-Options Header Field\n\n\n\n\nHeader field name:\nSec-Http-State-Options\nApplicable protocol:\nhttp\nStatus:\nexperimental\nAuthor/Change controller:\nIETF\nSpecification document(s):\nThis document (see Section 4.2)\nRelated information:\n(empty)\n\n\n10. References\n\n10.1. Normative References\n\n\n[Fetch]\n\nvan Kesteren, A., \"Fetch\", n.d..\n\n\n[I-D.ietf-httpbis-header-structure]\n\nNottingham, M. and P. Kamp, \"Structured Headers for HTTP\", Internet-Draft draft-ietf-httpbis-header-structure-09, December 2018.\n\n\n[I-D.yasskin-http-origin-signed-responses]\n\nYasskin, J., \"Signed HTTP Exchanges\", Internet-Draft draft-yasskin-http-origin-signed-responses-05, January 2019.\n\n\n[Mixed-Content]\n\nWest, M., \"Mixed Content\", n.d..\n\n\n[RFC2104]\n\nKrawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997.\n\n\n[RFC2109]\n\nKristol, D. and L. Montulli, \"HTTP State Management Mechanism\", RFC 2109, DOI 10.17487/RFC2109, February 1997.\n\n\n[RFC2119]\n\nBradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.\n\n\n[RFC4648]\n\nJosefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006.\n\n\n[RFC5234]\n\nCrocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.\n\n\n[RFC7230]\n\nFielding, R. and J. Reschke, \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014.\n\n\n[RFC7409]\n\nHaleplidis, E. and J. Halpern, \"Forwarding and Control Element Separation (ForCES) Packet Parallelization\", RFC 7409, DOI 10.17487/RFC7409, November 2014.\n\n\n[RFC8174]\n\nLeiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.\n\n\n\n10.2. Informative References\n\n\n[I-D.abarth-cake]\n\nBarth, A., \"Origin Cookies\", Internet-Draft draft-abarth-cake-01, March 2011.\n\n\n[I-D.ietf-cbor-cddl]\n\nBirkholz, H., Vigano, C. and C. Bormann, \"Concise data definition language (CDDL): a notational convention to express CBOR and JSON data structures\", Internet-Draft draft-ietf-cbor-cddl-08, March 2019.\n\n\n[RFC6265]\n\nBarth, A., \"HTTP State Management Mechanism\", RFC 6265, DOI 10.17487/RFC6265, April 2011.\n\n\n\nAppendix A. Acknowledgements\n\nThis document owes much to Adam Barth’s [I-D.abarth-cake] and [RFC6265].\n\nAppendix B. Changes\n\nRFC Editor: Please remove this section before publication.\n\n\n\n-01 \nGeneral editorial cleanup.\nExplanation of NotifyHostHTTPStateReset(origin) algorithm in Section 8.1.\n\n\n-00 This document was created.\n\n\nAuthor's Address\n\n  \n\t\n\t  Mike West \n\t  \n\t\tWest\n\t  \n\t\n\tGoogle\n\t\n\t  \n\t  \n\t\t \n\t\t\n\t\t\n\t  \n\t  \n\t\n\tEMail: mkwst@google.com\n\nURI: https://www.mikewest.org/\n\n  \n\n\n\n\n","length":31924,"excerpt":"This document describes a mechanism which allows HTTP servers to maintain stateful sessions with HTTP user agents. It aims to address some of the security and privacy considerations which have been identified in existing state management mechanisms, providing developers with a well-lit path towards our current understanding of best practice.","byline":"Ambient Authority and Cross-Site Delivery","dir":null,"siteName":null,"lang":"en"},"finalizedMeta":{"title":"HTTP State Tokens","description":"This document describes a mechanism which allows HTTP servers to maintain stateful sessions with HTTP user agents. It aims to address some of the security and privacy considerations which have been identified in existing state management mechanisms, providing developers with a well-lit path towards our current understanding of best practice.","author":false,"creator":"","publisher":false,"date":"2022-04-05T17:38:39.672Z","topics":[]},"jsonLd":{"@type":false,"headline":false,"description":false,"image":[],"mainEntityOfPage":{"@type":false,"@id":false},"datePublished":false,"dateModified":false,"isAccessibleForFree":false,"isPartOf":{"@type":[],"name":false,"productID":false},"discussionUrl":false,"license":false,"author":{"@type":false,"name":false,"description":false,"sameAs":false,"image":{"@type":false,"url":false},"givenName":false,"familyName":false,"alternateName":false,"publishingPrinciples":false},"publisher":{"@type":false,"name":false,"description":false,"sameAs":false,"logo":{"@type":false,"url":false},"publishingPrinciples":false},"editor":{"@type":false,"name":false,"description":false,"sameAs":false,"image":{"@type":false,"url":false},"givenName":false,"familyName":false,"alternateName":false,"publishingPrinciples":false}},"twitterObj":false,"status":200,"metadata":{"author":false,"title":"HTTP State Tokens","description":"This document describes a mechanism which allows HTTP servers to maintain stateful sessions with HTTP user agents. It aims to address some of the security and privacy considerations which have been identified in existing state management mechanisms, providing developers with a well-lit path towards our current understanding of best practice.","canonical":"https://mikewest.github.io/http-state-tokens/draft-west-http-state-tokens.html","keywords":[],"image":false,"firstParagraph":"HTTP State Tokens\n  draft-west-http-state-tokens-latest"},"dublinCore":{},"opengraph":{"title":false,"description":false,"url":false,"site_name":false,"locale":false,"type":false,"typeObject":{"published_time":false,"modified_time":false,"author":false,"publisher":false,"section":false,"tag":[]},"image":false},"twitter":{"site":false,"description":false,"card":false,"creator":false,"title":false,"image":false},"archivedData":{"link":false,"wayback":false}}}