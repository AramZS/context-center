{"initialLink":"https://educatedguesswork.org/posts/messaging-e2e/","sanitizedLink":"https://educatedguesswork.org/posts/messaging-e2e/","finalLink":"https://educatedguesswork.org/posts/messaging-e2e/","htmlEmbed":"<script>window.contexterSetup=window.contexterSetup||function(){window.contexterSetupComplete=!0;class ContexterLink extends HTMLAnchorElement{constructor(){super()}connectedCallback(){this.setAttribute(\"target\",\"_blank\")}}customElements.define(\"contexter-link\",ContexterLink,{extends:\"a\"}),customElements.define(\"contexter-inner\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__inner\"}}),customElements.define(\"contexter-thumbnail\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__thumbnail\"}}),customElements.define(\"contexter-byline\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__byline\"}}),customElements.define(\"contexter-keywordset\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__keywordset\"}}),customElements.define(\"contexter-linkset\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__linkset\"}}),customElements.define(\"contexter-meta\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__meta\"}}),customElements.define(\"contexter-summary\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"p-summary entry-summary\"}}),customElements.define(\"contexter-box-head\",class extends HTMLElement{constructor(){super()}connectedCallback(){this.className=\"contexter-box__head\"}}),customElements.define(\"contexter-box-inner\",class extends HTMLElement{constructor(){super()}connectedCallback(){}});class ContexterBox extends HTMLElement{constructor(){super(),this.first=!0,this.shadow=this.attachShadow({mode:\"open\"})}connectedCallback(){if(this.first){this.first=!1;var style=document.createElement(\"style\"),lightDomStyle=(style.innerHTML=`:host {--background: #f5f6f7;--border: darkblue;--blue: #0000ee;--font-color: black;--inner-border: black;font-family: Franklin,Arial,Helvetica,sans-serif;font-size: 14px;background: var(--background);width: 600px;color: var(--font-color);min-height: 90px;display: block;padding: 8px;border: 1px solid var(--border);cursor: pointer;box-sizing: border-box;margin: 6px;contain: content;margin: 6px auto;}// can only select top-level nodes with slotted::slotted(*) {max-width: 100%;display:block;}::slotted([slot=thumbnail]) {max-width: 100%;display:block;}::slotted([slot=header]) {width: 100%;font-size: 1.25rem;font-weight: bold;display:block;margin-bottom: 6px;}::slotted([slot=author]) {max-width: 50%;font-size: 12px;display:inline-block;float: left;}::slotted([slot=time]) {max-width: 50%;font-size: 12px;display:inline-block;float: right;}::slotted([slot=summary]) {width: 100%;margin-top: 6px;padding: 10px 2px;border-top: 1px solid var(--inner-border);font-size: 15px;display:inline-block;margin-bottom: 6px;}contexter-meta {height: auto;margin-bottom: 4px;width: 100%;display: grid;position: relative;min-height: 16px;grid-template-columns: repeat(2, 1fr);}::slotted([slot=keywords]) {width: 80%;padding: 2px 4px;border-top: 1px solid var(--inner-border);font-size: 11px;display: block;float: right;font-style: italic;text-align: right;grid-column: 2/2;grid-row: 1;align-self: end;justify-self: end;}::slotted([slot=keywords]):empty {border-top: 0px solid var(--inner-border);}::slotted([slot=archive-link]) {font-size: 1em;display: inline;}::slotted([slot=archive-link])::after {content: \"|\";display: inline;color: var(--font-color);text-decoration: none;margin: 0 .5em;}::slotted([slot=read-link]) {font-size: 1em;display: inline;}contexter-linkset {width: 80%;padding: 2px 4px;font-size: 13px;float: left;font-weight: bold;grid-row: 1;grid-column: 1/2;align-self: end;justify-self: start;}/* Extra small devices (phones, 600px and down) */@media only screen and (max-width: 600px) {:host {width: 310px;}}/* Small devices (portrait tablets and large phones, 600px and up) */@media only screen and (min-width: 600px) {...}/* Medium devices (landscape tablets, 768px and up) */@media only screen and (min-width: 768px) {...}/* Large devices (laptops/desktops, 992px and up) */@media only screen and (min-width: 992px) {...}/* Extra large devices (large laptops and desktops, 1200px and up) */@media only screen and (min-width: 1200px) {...}@media (prefers-color-scheme: dark){:host {--background: #354150;--border: #1f2b37;--blue: #55b0ff;--font-color: #ffffff;--inner-border: #787a7c;background: var(--background);border: 1px solid var(--border)}}`,document.createElement(\"style\"));lightDomStyle.innerHTML=`contexter-box {contain: content;}contexter-box .read-link {font-weight: bold;}contexter-box a {color: #0000ee;}contexter-box img {width: 100%;border: 0;padding: 0;margin: 0;}/* Extra small devices (phones, 600px and down) */@media only screen and (max-width: 600px) {...}/* Small devices (portrait tablets and large phones, 600px and up) */@media only screen and (min-width: 600px) {...}/* Medium devices (landscape tablets, 768px and up) */@media only screen and (min-width: 768px) {...}/* Large devices (laptops/desktops, 992px and up) */@media only screen and (min-width: 992px) {...}/* Extra large devices (large laptops and desktops, 1200px and up) */@media only screen and (min-width: 1200px) {...}@media (prefers-color-scheme: dark){contexter-box a {color: #55b0ff;}}`,this.appendChild(lightDomStyle),this.shadow.appendChild(style);const innerContainer=document.createElement(\"contexter-box-inner\"),innerSlotThumbnail=(this.shadow.appendChild(innerContainer),document.createElement(\"slot\")),innerSlotHeader=(innerSlotThumbnail.name=\"thumbnail\",innerContainer.appendChild(innerSlotThumbnail),document.createElement(\"slot\")),innerSlotAuthor=(innerSlotHeader.name=\"header\",innerContainer.appendChild(innerSlotHeader),document.createElement(\"slot\")),innerSlotTime=(innerSlotAuthor.name=\"author\",innerContainer.appendChild(innerSlotAuthor),document.createElement(\"slot\")),innerSlotSummary=(innerSlotTime.name=\"time\",innerContainer.appendChild(innerSlotTime),document.createElement(\"slot\")),metaContainer=(innerSlotSummary.name=\"summary\",innerContainer.appendChild(innerSlotSummary),document.createElement(\"contexter-meta\")),innerSlotInfo=(innerContainer.appendChild(metaContainer),document.createElement(\"slot\")),linkContainer=(innerSlotInfo.name=\"keywords\",metaContainer.appendChild(innerSlotInfo),document.createElement(\"contexter-linkset\")),innerSlotArchiveLink=(metaContainer.appendChild(linkContainer),document.createElement(\"slot\")),innerSlotReadLink=(innerSlotArchiveLink.name=\"archive-link\",linkContainer.appendChild(innerSlotArchiveLink),document.createElement(\"slot\"));innerSlotReadLink.name=\"read-link\",linkContainer.appendChild(innerSlotReadLink),this.className=\"contexter-box\",this.onclick=e=>{if(!e.target.className.includes(\"read-link\")&&!e.target.className.includes(\"title-link\")){const mainLinks=this.querySelectorAll(\"a.main-link\");mainLinks[0].click()}}}}}customElements.define(\"contexter-box\",ContexterBox)},window.contexterSetupComplete||window.contexterSetup();</script><contexter-box class=\"link-card h-entry hentry\" itemscope=\"\" itemtype=\"https://schema.org/CreativeWork\"><contexter-thumbnail class=\"thumbnail\" slot=\"thumbnail\"></contexter-thumbnail><contexter-box-head slot=\"header\" class=\"p-name entry-title\" itemprop=\"headline\"><contexter-box-head slot=\"header\" class=\"p-name entry-title\" itemprop=\"headline\"><a is=\"contexter-link\" href=\"https://educatedguesswork.org/posts/messaging-e2e/\" itemprop=\"url\">End-to-End Encryption and Messaging Interoperability</a></contexter-box-head></contexter-box-head><contexter-byline class=\"p-author author\" slot=\"author\"><span class=\"p-name byline\" rel=\"author\" itemprop=\"author\">@ekr____</span></contexter-byline><time class=\"dt-published published\" slot=\"time\" itemprop=\"datePublished\" datetime=\"2022-08-23T17:34:13.720Z\">7/23/2022</time><contexter-summary class=\"p-summary entry-summary\" itemprop=\"abstract\" slot=\"summary\"><p>The news the the EUwill require that messaging companies provideinteroperabilityhas gotten a lot of attention, both positive(matrix.org)and negative (AlexStamos,Alec Muffett, SteveBellovin),as detailed in thisWiredarticle (see also this ISOCwhite paper). At a high level,I'm more positive on the idea of interoperability for messaging systemsthan some others are, but it's certainly not a trivial problem andat least some of the EU timelines seem pretty unreasonable. Read onfor more.</p></contexter-summary><contexter-keywordset itemprop=\"keywords\" slot=\"keywords\"></contexter-keywordset><a href=\"https://web.archive.org/web/20220602011351/https://educatedguesswork.org/posts/messaging-e2e/\" is=\"contexter-link\" target=\"_blank\" rel=\"timemap\" class=\"read-link archive-link\" itemprop=\"archivedAt\" slot=\"archive-link\">Archived</a><a is=\"contexter-link\" href=\"https://educatedguesswork.org/posts/messaging-e2e/\" class=\"read-link main-link\" itemprop=\"sameAs\" slot=\"read-link\">Read</a></contexter-box>","linkId":"8283fcc91aacfb07c1a235dbf4208ee8ff260f7a","data":{"originalLink":"https://educatedguesswork.org/posts/messaging-e2e/","sanitizedLink":"https://educatedguesswork.org/posts/messaging-e2e/","canonical":"https://educatedguesswork.org/posts/messaging-e2e/","htmlText":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>End-to-End Encryption and Messaging Interoperability</title>\n    <meta name=\"description\" content=\"\">\n\n    <meta name=\"twitter:card\" content=\"summary\" />\n    <meta name=\"twitter:creator\" content=\"@ekr____\" />\n    <meta property=\"og:title\" content=\"End-to-End Encryption and Messaging Interoperability\" />\n    \n    <meta property=\"og:type\" content=\"article\" />\n\n    <link rel=\"stylesheet\" href=\"/css/prism-base16-monokai.dark.css\">\n    <link rel=\"stylesheet\" href=\"/css/index.css\">\n    <link rel=\"alternate\" href=\"/feed/feed.xml\" type=\"application/atom+xml\" title=\"Educated Guesswork\">\n    <link rel=\"alternate\" href=\"/feed/feed.json\" type=\"application/json\" title=\"Educated Guesswork\">\n  </head>\n  <body>\n      <header>\n        <div class=\"wrapper\">\n          <h1 class=\"nav-title\"><a href=\"/\">Educated Guesswork</a></h1>\n          <ul class=\"nav\">\n            <li class=\"nav-item\"><a  href=\"/posts/\">Archive</a></li>\n            <li class=\"nav-item\"><a  href=\"/about/\">About Me</a></li>\n            <li class=\"nav-item desktop-only\"><a href=\"mailto:ekr@rtfm.com\">Contact</a></li>\n            <li class=\"nav-item desktop-only\"><a href=\"https://twitter.com/ekr____\">Follow on Twitter</a></li>\n            <li class=\"nav-item highlight\"><a href=\"/subscribe\">Subscribe</a></li>\n          </ul>\n        </div>\n      </header>\n        <div class=\"wrapper\">\n          <main class=\"tmpl-post\">\n            \n<div class=\"grid\">\n  <div class=\"grid-main\">\n    <article>\n        <h1>End-to-End Encryption and Messaging Interoperability</h1>\n        <p class=\"dateline\">Posted by <a target=\"_blank\" href=\"https://twitter.com/ekr____\">ekr</a> on 07 Apr 2022</p>\n\n        <p>The <a href=\"https://www.europarl.europa.eu/news/en/press-room/20220315IPR25504/deal-on-digital-markets-act-ensuring-fair-competition-and-more-choice-for-users\">news</a> the the EU\nwill <a href=\"https://www.ianbrown.tech/wp-content/uploads/2022/03/Final-DMA-interoperability-text.pdf\">require that messaging companies provide\ninteroperability</a>\nhas gotten a lot of attention, both positive\n(<a href=\"https://matrix.org/blog/2022/03/25/interoperability-without-sacrificing-privacy-matrix-and-the-dma\">matrix.org</a>)\nand negative (<a href=\"https://twitter.com/alexstamos/status/1507145126006587411\">Alex\nStamos</a>,\n<a href=\"https://alecmuffett.com/article/16037\">Alec Muffett</a>, <a href=\"https://twitter.com/SteveBellovin/status/1507375010054348805\">Steve\nBellovin</a>),\nas detailed in this\n<a href=\"https://www.wired.com/story/dma-interoperability-messaging-imessage-whatsapp/\">Wired</a>\narticle (see also this <a href=\"https://www.internetsociety.org/wp-content/uploads/2022/03/ISOC-EU-DMA-interoperability-encrypted-messaging-20220311.pdf\">ISOC</a>\nwhite paper). At a high level,\nI'm more positive on the idea of interoperability for messaging systems\nthan some others are, but it's certainly not a trivial problem and\nat least some of the EU timelines seem pretty unreasonable. Read on\nfor more.</p>\n<h2 id=\"critiques\">Critiques <a class=\"direct-link\" href=\"#critiques\">#</a></h2>\n<p>At a high level, there seem to be three broad critiques of messaging system\ninteroperability:</p>\n<ol>\n<li>It will weaken security, for instance by requiring decryption\nand re-encryption at system boundaries or by creating\nconfusion about user identities.</li>\n<li>It will hold back innovation by forcing messages to be\nsent using only features that are common to all systems.</li>\n<li>It will make abuse (especially spam) worse.</li>\n</ol>\n<p>It's useful to keep these in mind throughout the rest of the discussion.</p>\n<p>Before covering messaging, however, it's helpful look at an existing\nsystem that has had interoperability for a long, where we can see the\nresulting dynamics: e-mail.</p>\n<h2 id=\"an-interoperable-system%3A-e-mail\">An Interoperable System: E-mail <a class=\"direct-link\" href=\"#an-interoperable-system%3A-e-mail\">#</a></h2>\n<p>E-mail has the\nopposite problem from messaging: where messaging consists of a number\nof independent islands of encrypted messaging with no way to talk\nbetween them, email is a globally interoperable system that—despite\na number of attempts—doesn't have anything like universal encryption.<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n<p>E-mail operates on a hub-and-spoke model in which every user is\nassociated with a given mail domain, represented by a domain\nname (e.g., <code>example.com</code>) as shown below:</p>\n<p><img src=\"/img/email.drawio.png\" alt=\"Email architecture\"></p>\n<div class=\"callout\">\n<h4 id=\"telephone-addressing\">Telephone Addressing <a class=\"direct-link\" href=\"#telephone-addressing\">#</a></h4>\n<p>Telephone numbers actually are <em>hierarchically structured</em> but don't map 1-1 with providers.</p>\n<p>The basic structure of a phone number is given by the <a href=\"https://en.wikipedia.org/w/index.php?title=E.164&amp;oldid=1073189249\">E.164 standard</a> and consists of a country code followed by a subscriber number,\nwith the structure of the subscriber number being defined by the country\ncode. For instance, in the <a href=\"https://en.wikipedia.org/w/index.php?title=North_American_Numbering_Plan&amp;oldid=1075584876\">North American Numbering Plan</a>, identified by country code 1, numbers\nlook like: <code>415.555.1111</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Description</th>\n<th>Digits</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Numbering plan area (aka area code)</td>\n<td>3</td>\n<td><code>415</code></td>\n</tr>\n<tr>\n<td>Central office prefix</td>\n<td>3</td>\n<td><code>555</code></td>\n</tr>\n<tr>\n<td>Line number, denoting subscriber</td>\n<td>4</td>\n<td><code>1111</code></td>\n</tr>\n</tbody>\n</table>\n<p>I don't know too much about the non-North American setting, so the remainder of\nthis aside is about North America.\nUntil 1984, North American telephony was basically monopolized by\nthe <a href=\"https://en.wikipedia.org/w/index.php?title=Bell_System&amp;oldid=1080354068\">Bell System</a>. In\nthat system, the number hierarchy was geographic, with the area codes\nand central office prefixes corresponding to geographic regions and\nspecific switches and the line number corresponding to lines on a given\nswitch. However, with the advent of local number competition following\nthe breakup of the Bell System and then mobile telephony, things started\nto get more complicated.</p>\n<p>Initially, central offices were controlled by a single carrier and\nso the phone number could be used straightforwardly for routing.\nHowever, subsequently the US required carriers\nto provide <a href=\"https://en.wikipedia.org/w/index.php?title=Local_number_portability&amp;oldid=1077125532\">Local Number Portability</a>, which allowed you to take your number from carrier to carrier.\nThus, even if you were originally assigned a number out of Verizon's\nblock, you could &quot;port&quot; it to T-Mobile, which means that this kind of hierarchical\nrouting no longer works. Instead, there's basically a giant—well,\nnot so giant, given that there are only 10 billion possible numbers—database\nthat indicates which carrier has responsibility for each number.</p>\n</div>\n<p>E-mail addresses are hierarchically assigned, which means that if your\nmail service is <code>example.com</code>, then your address will end in\n<code>@example.com</code>, as in <code>alice@example.com</code>.\nIt's helpful to work through an example here. For instance, here is\nwhat happens when Alice (<code>alice@hotmail.com</code>) wants to send a message to Bob (<code>bob@gmail.com</code>):</p>\n<ol>\n<li>\n<p>First, she transmits the message to her mail server\nover a protocol called the <em><a href=\"https://en.wikipedia.org/w/index.php?title=Simple_Mail_Transfer_Protocol&amp;oldid=1079015503\">Simple Mail Transfer Protocol (SMTP)</a></em>,\nalong with the addressing information for <code>bob@gmail.com</code>.</p>\n</li>\n<li>\n<p>The sending mail server looks up the receiving\ndomain name—in this case <code>gmail.com</code>—in the DNS\nto get the server associated with it.<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup> It then connects to that server—again over\nSMTP—and transfers the message, along with the\naddressing information <code>bob@gmail.com</code>.</p>\n</li>\n<li>\n<p>Assuming that <code>bob@gmail.com</code> is actually a valid user on\nthe receiving server, that server stores the message somewhere\n(on disk, in a database, whatever) and waits for Bob to\ncome pick it up.</p>\n</li>\n<li>\n<p>Finally, Bob connects to his mail server (historically over\na protocol called <em><a href=\"https://en.wikipedia.org/w/index.php?title=Internet_Message_Access_Protocol&amp;oldid=1071482084\">Internet Message Access Protocol (IMAP)</a></em>)\nand retrieves any new messages.</p>\n</li>\n</ol>\n<p>This structure has a number of important properties:</p>\n<h4 id=\"addresses\">Addresses <a class=\"direct-link\" href=\"#addresses\">#</a></h4>\n<p>Because addresses are <em>scoped</em> by the mail domain they are\nassociated with, it's possible to immediately know where\na given message should be delivered just by looking at the\n<em>right-hand side (RHS)</em> of the address, namely the stuff\nafter the <code>@</code>-sign. That tells you which domain an\naddress is associated with. This is in contrast to addresses\non most popular services (e.g., Twitter), which are <em>unqualified</em>:\nif all I have is the identifier <code>ekr____</code> I don't know if\nthat corresponds to Twitter, Github, or LinkedIn..<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup></p>\n<p>Conversely, the fact that names are hierarchical means that\ntwo people can have the same <em>left-hand side (LHS)</em> as long as the RHS is\ndifferent (and vice versa). So, <code>bob@gmail.com</code> and <code>bob@hotmail.com</code>\nare totally distinct addresses and quite likely belong to different\npeople. This is of course true with Twitter handles and the\nlike, but because they are <em>unqualified</em>, the bare address\nisn't enough to tell you who is who. This becomes a real issue\nwhen you want to import identities from another namespace,\nfor example, when your address for messaging is actually your\ntelephone number.</p>\n<p>Finally, it means that the semantics of the LHS\nare opaque to the other end. For instance, if you had your\nown mail domain (for instance <code>your-lastname.name</code>) you\nmight have every address that ends in <code>@your-lastname.name</code>\ndelivered into the same mailbox. Another example is that\nGmail allows you to create new addresses by adding a plus sign\nto the end of your actual address, so <code>example@gmail.com</code>\nand <code>example+newsletter@example.com</code> go to the same place.\nThis is a useful trick to let you sort your email by giving\ndifferent addresses to each sender.</p>\n<div class=\"callout\">\n<h4 id=\"hosted-domains\">Hosted Domains <a class=\"direct-link\" href=\"#hosted-domains\">#</a></h4>\n<p>Although mail is scoped by domain, as a practical matter\nmany domains are actually hosted by the same service.\nFor instance, Gmail allows you to host your &quot;custom domain&quot;\non Gmail (that is how <code>rtfm.com</code> works), but your\naddress can still have your domain in it rather than\n<code>gmail.com</code>. It's also possible to have your mail\ndelivered to service A and have most of your accounts\nthere but send mail from service B. This is useful if you\nwant to send bulk email using a service like <a href=\"https://www.mailgun.com/\">Mailgun</a>.</p>\n</div>\n<h4 id=\"interoperability\">Interoperability <a class=\"direct-link\" href=\"#interoperability\">#</a></h4>\n<p>Because SMTP and IMAP are standardized, any mail endpoint\ncan talk to any other mail endpoint. If you own <code>example.com</code>\nand want to send and receive mail there, all you have to do\nis stand up a server—or more likely, use an existing\nhosting server—set up the right DNS records, and\nyou're good to go. Similarly, most mail services will provide IMAP\nservice and so you can use any number of clients\n(the built in mail client on your Mac, <a href=\"https://en.wikipedia.org/w/index.php?title=Mozilla_Thunderbird&amp;oldid=1074344985\">Thunderbird</a>, etc.) to\nread your mail.</p>\n<p>Conversely, nothing says that a mail system has\nto have a separate client at all. For instance, instead\nof having people use IMAP to read their email you can just\nput up a Web front end that accesses it directly and, tada,\nyou have Gmail. Or, as is common, you can both have a Web interface\n<em>and</em> an IMAP interface. As long as you properly speak SMTP, everything\nwill work fine and the other end doesn't even need to know how\nyou have everything set up; it's just a matter of having the\nright protocol interfaces. In particular, it doesn't matter to\nthe receiver how the sender talks to their mail server\nand it doesn't matter to the sender how the receiver\ntalks to their mail server. All that's required is that\nthe servers speak SMTP to each other.</p>\n<p>This is in contrast to most messaging systems, which are basically\nsilos that don't interoperate with each other.</p>\n<h3 id=\"extensibility\">Extensibility <a class=\"direct-link\" href=\"#extensibility\">#</a></h3>\n<p>The cost of interoperable protocols is a limited range of\nformat extensibility. The format of the emails is standardized using a\nformat called\n<a href=\"https://en.wikipedia.org/w/index.php?title=MIME&amp;oldid=1080291535\">MIME</a>,\nand if you send a compliant MIME message the receiver should be able\nto process it, at least to figure out what the type of\nthe message is.</p>\n<p>Identifying the type of the message is only the first\nstep. Suppose that you want to introduce a new\nmail feature, say <a href=\"https://apps.apple.com/us/app/memoji/id1526384700\">memoji</a>\nin emails. Even if you write a new standard for it and Alice\nadds it to her email client, what happens if Bob hasn't upgraded?\nIdeally, the client would get some clear message that something\nwas wrong, and yet would still see the part that was\ninterpretable, but this doesn't always work.\nDepending on exactly how the new feature is designed, it either\nmight not work properly—for instance, the memoji might\nbe replaced with  some unknown character like �—\n(for a long time, emails from Outlook would <a href=\"https://www.bleepingcomputer.com/news/microsoft/after-seven-years-microsoft-is-finally-fixing-the-j-email-bug/\">render\nthe :) emoji to &quot;J&quot; on non-outlook systems</a>)\nor the message might just not be readable at all (though hopefully\nyou wouldn't design a feature like that).\nAt the end of the day, this kind of mismatch can create\na pretty degraded experience and change the meaning of the message.</p>\n<p>The converse of this property however, is that\nemail <em>processing</em> is highly extensible. Because mail formats\nare open and standardized, any client that speaks the\nprotocol will work. I gave the example of Webmail before,\nbut this also means that if you want to\nuse a mail client which offers some new feature—automatic\nemail summarization say—that's your business.\nBy contrast, most messaging systems are closed and so\nyou're limited to the features supported by the official\nclient.</p>\n<h3 id=\"security%3F\">Security? <a class=\"direct-link\" href=\"#security%3F\">#</a></h3>\n<p>Like many things on the Internet, the e-mail system was designed\nbefore modern encryption and so initially everything was in\nthe clear. This allowed for a broad range of attacks:</p>\n<ol>\n<li>\n<p>Anyone on the connection between you and the mail server\nor between mail servers could read or modify your messages.</p>\n</li>\n<li>\n<p>Senders weren't authenticated and so it was trivial to\nforge messages that appeared to come from someone else.</p>\n</li>\n<li>\n<p>If your mail server was compromised, then it could read\nyour messages in transit or change them.</p>\n</li>\n</ol>\n<p>Some of these issues have been gradually sort-of addressed\nwith partial solutions such as TLS encrypting the traffic\nbetween you and the mail server, TLS encrypting\nthe traffic between the mail servers, and server-based\nsigning mechanisms like <a href=\"https://en.wikipedia.org/w/index.php?title=DomainKeys_Identified_Mail&amp;oldid=1080414793\">DKIM</a>. However, they're incompletely\napplied (for instance, the client-server connection\nis generally strongly authenticated but the server-server\nconnection often is not) and still don't provide any protection\nagainst a malicious or compromised mail server. For that\nyou need <em>end-to-end encryption</em> (E2EE), in which the\nmessages are encrypted (and authenticated) between the\nsending and receiving endpoints.</p>\n<p>There have been quite a few attempts to provide end-to-end encryption\nfor e-mail (PGP, S/MIME, etc.) but I think it's fair to describe them\nas having largely failed. This isn't to say that there isn't any encrypted\nmail but it's a fairly small fraction of overall traffic. The\nreasons for the failure of encrypted email are complicated, but\nthere were a number of deployment problems that most likely\ncontributed.</p>\n<h4 id=\"key-management\">Key Management <a class=\"direct-link\" href=\"#key-management\">#</a></h4>\n<p>Like any cryptographic system, encrypted email depends on\nknowing the cryptographic keys of the people you are talking to.\nIn e-mail, you use keys in two ways:</p>\n<ol>\n<li>You sign your messages in order to authenticate them</li>\n<li>People who want to send you secure messages need to encrypt them to your\nkey.</li>\n</ol>\n<p>It's technically possible to just start sending people messages with\nunauthenticated\nkeys, for instance by signing all of your messages and expecting\npeople to remember that this is your key (this is often called <em><a href=\"https://en.wikipedia.org/w/index.php?title=Trust_on_first_use&amp;oldid=1052198040\">trust\non first use\n(TOFU)</a></em>).\nOnce they have received a message from you, they can use your key to\nencrypt the return message. Obviously, TOFU is susceptible\nto attack if the that attacker is the first person to send you\na message pretending to be someone else, which makes the system\nless than ideal, especially for interactions with people you don't\ntalk to frequently.  If my bank sends me a signed message, then I want\nto know it's my bank right away. It's also a problem if you want to\nsend an encrypted message to someone you have never talked to\nbefore. What you really want is some system that lets you find out\nwhat people's keys are, which means solving two problems:</p>\n<ul>\n<li>\n<p>You need to somehow associate your key(s) with\nyour email address.</p>\n</li>\n<li>\n<p>You need some way to look up people's keys so that\nyou can send them encrypted messages.</p>\n</li>\n</ul>\n<p>Deploying the infrastructure for both of these has proven to be\nquite challenging. The basic problem is that there was\nnever a good way to automatically issue the credentials.\nThis meant that people had to go to a lot of effort to\nget credentials, which of course meant that most\npeople didn't get them. On the other side of the equation,\nthere was never really a great way to discover\npeople's credentials, which meant that you couldn't\nsend encrypted email to new people. It's in principle\npossible to build mechanisms for this (<a href=\"https://datatracker.ietf.org/doc/rfc8555/\">ACME</a>\nand <a href=\"https://webfinger.net/\">WebFinger</a>\nrespectively are examples of the kind of thing I'm talking\nabout), but we have the usual deployment\n<a href=\"#network-effects\">network effect</a> problems.</p>\n<h4 id=\"confusing-semantics\">Confusing Semantics <a class=\"direct-link\" href=\"#confusing-semantics\">#</a></h4>\n<p>In addition to the keying problems, the fact that email encryption was\nadded after the fact to an established system has resulted in some\nconfusing semantics.</p>\n<p>For example, the major extension point in e-mail is via the message\n<em>body</em>. As noted above, the bodies use an extensible message format\ncalled MIME. However the message subject line isn't extensible.\nThis means that the subject line that appears in\nthe email isn't either encrypted or authenticated. It's of course\npossible to have an inner subject line inside the encryption envelope,\nbut it's an obvious challenge for users to understand that they can\ntrust the body but not the subject.</p>\n<p>Second, because some messages are protected and some are not,\nyou need some way to indicate to the user which are which.\nThis kind of indicator is a notorious source of confusion,\nespecially in a situation where most messages are\nunprotected, because you don't want a big scary warning for\nnearly every message. But this also reduces the incentive for people\nto use secure e-mail, especially to send signed\ne-mail: if recipients don't notice or care whether\nmessages are signed, then signing them doesn't add\na lot of value, as an attacker can just impersonate you\nwith the recipient being none the wiser.</p>\n<h4 id=\"network-effects\">Network Effects <a class=\"direct-link\" href=\"#network-effects\">#</a></h4>\n<p>All of this should be a familiar story to EG readers: you\nhave a situation where it's inconvenient for people to do\nsomething—in this case, deploy encryption—and\nthere's not much benefit to doing it. In these cases, you get the expected result which is\nlimited or minimal deployment. By contrast, most modern messaging systems\nwere either built with E2EE from the start or underwent\nsome mass upgrade that enabled it for everyone, rather\nthan relying on people to do it themselves.</p>\n<h2 id=\"messaging-systems\">Messaging Systems <a class=\"direct-link\" href=\"#messaging-systems\">#</a></h2>\n<p>Modern messaging systems have addressed these issues by making\nencryption both mandatory and automatic. This is comparatively\neasy because the messaging service is (usually) vertically integrated:\nall—or nearly all—users have clients which are provided\nby the service operator and can be updated as desired. The\nservice operator also provides message routing and identity.\nThis kind of uniform integrated system has a number of operational\nadvantages:</p>\n<ul>\n<li>\n<p>The service can automatically issue credentials based on the\nuser's account information, thus ensuring that every user\nhas a credential. They can also run a directory which makes\nit easy for any client to learn the credentials for every\nother client.</p>\n</li>\n<li>\n<p>When the service wants to add a new feature it can automatically\nupgrade everyone's client to support it. This means that they\ndon't need to deal with massive heterogeneity of client functionality\nfor very long, and can eventually just refuse to support older\nclients.<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup></p>\n</li>\n<li>\n<p>Spam and other kinds of abuse are easier to handle because\nall messages are authenticated by a user in the system. Of\ncourse, if you have a single central point where all\nmessages are handled, and no end-to-end encryption, then content\nfiltering is more difficult.</p>\n</li>\n</ul>\n<p>Of course, many of these advantages depend on having a closed system:\nif a significant fraction of people use third party clients to talk to\nsuch a system then you can no longer update the clients whenever\nyou want to, which makes central extensibility much more difficult.\nIn other words, you're trading off user control and extensibility for users\nfor control and extensibility by the system operator. This is in\nstark contrast to the design of the Web, which is dominated by\nthe principle of end-user control as documented in\nthe <a href=\"https://www.w3.org/TR/html-design-principles/#priority-of-constituencies\">HTML Priority of Constituencies</a>\nand the <a href=\"https://webvision.mozilla.org/full/#usercontrol\">Mozilla Web Vision</a>.</p>\n<p>Another consequence of a closed system is a lack of universal connectivity:\nwith e-mail—or telephony—you can contact anyone no matter\nwhich service provider they are on. In fact, you don't even have to\nthink about it: you just e-mail (or dial). Messaging, however, is different:\nif I want to send a message to someone on WhatsApp, I need to have\na WhatsApp account myself. And because people choose different messaging\nsystems, this means that it's now common to have accounts on a variety\nof messaging systems (I myself use three regular messaging systems, plus\ncountless Slacks).</p>\n<p>All of this creates a set of market dynamics dominated by network\neffects\n(<a href=\"https://en.wikipedia.org/w/index.php?title=Metcalfe%27s_law&amp;oldid=1071685522\">Metcalfe's Law</a>)\nand getting big: if you have a lot of users, then people have\na strong incentive to join so they can talk to their friends. Conversely,\nif you are a new entrant into the market it is hard to break in\nbecause your early users don't have that many people to talk to.\nThis is probably why we see a lot of regional variation in which\napps are popular, because people want to use whatever app their\nfriends use. Unsurprisingly, this produces some fairly lopsided\nmarket numbers, with Meta controlling two of the top three\nmessaging platforms (WhatsApp and Facebook Messenger):</p>\n<p><img src=\"https://www.messengerpeople.com/wp-content/uploads/2021/05/most-popular-global-mobile-messaging-apps-2021.png\" alt=\"Messaging platforms\"></p>\n<p>This brings us to the topic of interoperability: if it were possible\nfor anyone to start a new messenger app that could still talk to\nWhatsApp and Messenger users, then this would remove a big barrier\nto entry into the market. I don't want to sound too optimistic here:\neven in a nominally open system like e-mail, we still see a huge\n<a href=\"https://blog.shuttlecloud.com/the-most-popular-email-providers-in-the-u-s-a/\">amount of market concentration</a>\non the big mail systems like Gmail, Outlook, and Yahoo. This isn't\ntoo surprising: it's a lot of work to run a good mail system\nand so we'd expect well-funded players to dominate. However,\nit's also quite possible to use one of the smaller services\nlike <a href=\"https://www.fastmail.com/\">Fastmail</a>, <a href=\"https://protonmail.com/\">ProtonMail</a>,\nor <a href=\"https://www.dreamhost.com/\">DreamHost</a> or even run your own server,\nwhereas there's really no way to run your own WhatsApp server.</p>\n<h2 id=\"technical-interoperability-for-messenging\">Technical Interoperability for Messenging <a class=\"direct-link\" href=\"#technical-interoperability-for-messenging\">#</a></h2>\n<p>The details of what the DMA will actually require are extraordinarily\nsketchy; as I understand it they would need to be filled out\nby some regulatory agency. However, broadly speaking, there seem to be two options for providing\ninteroperability, as <a href=\"https://www.internetsociety.org/wp-content/uploads/2022/03/ISOC-EU-DMA-interoperability-encrypted-messaging-20220311.pdf\">laid out by ISOC</a>:</p>\n<ol>\n<li>Require services to offer stable APIs.</li>\n<li>Require services to actually interoperate over a standardized\nprotocol.</li>\n</ol>\n<p>These require a bit of unpacking.</p>\n<h3 id=\"stable-apis\">Stable APIs <a class=\"direct-link\" href=\"#stable-apis\">#</a></h3>\n<p>The idea behind a stable API is that the service would design and publish interfaces\nthat others could use. There are actually two ways to offer stable APIs:</p>\n<ol>\n<li>\n<p>To <em>clients</em>, allowing someone else's messenger\nclient to work with your service.</p>\n</li>\n<li>\n<p>To <em>services</em>, allowing someone else's messenger service to gateway\nmessages in and out of your service.</p>\n</li>\n</ol>\n<p>The first of this is actually a familiar concept in instant\nmessaging: because there was never a single standardized protocol,\nit was fairly common to have messaging clients, such as\n<a href=\"https://www.trillian.im/\">Trillian</a>,\nwhich would speak multiple protocols but provide a unified interface\nto the user that hid the details. This isn't really a conceptual\nchange in the architecture of the system as it would still be\na monolithic identifier space and the clients would still have\nto conform to whatever rules the service laid out; indeed, some\nservices have open source clients, and so this is already possible\nfor them, though of course third party clients might not\nget upgraded when the official clients do, potentially\nresulting in stability problems.\nThe main result would be some decreased flexibility\nfor the service because they would need to get users of the API\nto update when they wanted to change something that affected\ninteroperability. However, as a practical matter, this probably\nwouldn't have that much of an impact on interoperability\nand market concentration because most people will just use the\nofficial client, and people who don't will be annoyed when\nthe service changes something and breaks them.</p>\n<p>The second version is less familiar, but the idea is presumably that\nWhatsApp would have some published API that would allow\nekrMessage (TM pending!) to gateway messages into and out of\nWhatsApp. As with e-mail, each side would handle messages\naccording to its own rules, with the gateway just\ntransiting messages between the systems.\nThis comes with two main problems:</p>\n<ul>\n<li>\n<p>How do you handle identities? For instance, if ekrMessage\nand WhatsApp both use phone numbers for identities, how\ndo you know which messages stay on WhatsApp and which go\nto ekrMessage?</p>\n</li>\n<li>\n<p>How do you manage different encryption protocols? Currently,\neach messenger has their own encryption protocol; while many\nof these are built along similar lines, they're not necessarily\nidentical. Making this work either requires gatewaying at\nthe provider—thus breaking end-to-end encryption, which\nis extremely undesirable from a security perspective—or\nhaving each client speak multiple encryption protocols,\nas in the multi-protocol client case.</p>\n</li>\n</ul>\n<p>Of course, this would all be a lot easier if there was some\nstandardized protocol that everyone spoke, as with e-mail.\nNote: the difference between a stable API and a standardized protocol isn't\nreally technical so much as social and depends on whether there\nis some standard or just a document published by the service.<sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup></p>\n<h3 id=\"standardized-protocol\">Standardized Protocol <a class=\"direct-link\" href=\"#standardized-protocol\">#</a></h3>\n<p>Having a standardized protocol is not an\nall-or-nothing proposition: there are actually a number of levels at which one might\nhave standardization, with the other levels potentially not\nbeing standardized:</p>\n<ul>\n<li>Key establishment and message encryption</li>\n<li>Use identity</li>\n<li>Message transport</li>\n<li>Message contents and features</li>\n</ul>\n<p>I go into these in some more detail below.</p>\n<h4 id=\"key-establishment-and-message-encryption\">Key Establishment and Message Encryption <a class=\"direct-link\" href=\"#key-establishment-and-message-encryption\">#</a></h4>\n<p>The basic structure of most messaging encryption systems is that\nyou have an identity (e.g., your phone number) which is tied\nto a cryptographic key or keys. When Alice and Bob want to exchange messages,\nthere is some protocol that lets them use their keys to establish a pairwise\n(or groupwise in the case of more than two people) cryptographic\nkey which they then use to encrypt messages.<sup class=\"footnote-ref\"><a href=\"#fn6\" id=\"fnref6\">[6]</a></sup>\nObviously, if Alice and Bob don't speak the same protocol,\nthen they will not be able to establish pairwise keys and will\nnot be able to encrypt messages end-to-end, so this is probably\nthe most important place for everyone to use a common protocol.</p>\n<p>Fortunately, while there are technical differences between the various\nprotocols in use, they're similar enough that it would\nprobably not be prohibitive for everyone to converge on\na common protocol: a number of the existing messenging\nsystems are based on the <a href=\"https://en.wikipedia.org/w/index.php?title=Signal_Protocol&amp;oldid=1062140450\">Signal protocol</a>\nor one of its variants such such as <a href=\"https://wire.com/en/blog/axolotl-proteus-encryption-protocols/\">Proteus</a>\nor <a href=\"https://gitlab.matrix.org/matrix-org/olm/blob/master/docs/megolm.md\">Megolm</a>,\nand the IETF is currently in the final stages of standardizing\na protocol called <a href=\"https://en.wikipedia.org/w/index.php?title=Messaging_Layer_Security&amp;oldid=1076231420\">Messaging Layer Security (MLS)</a> which contains a number of similar concepts but is\nintended to be more optimized for group communication. It's too\nsoon to know how much adoption MLS will get, but the WG has\nhad participation from a number of messenging services such as\nFacebook Messenger, Matrix, Wickr, and Wire (full disclosure: I\nhave also been heavily involved in this effort). It would be a big\nlift for companies to change out their protocols, but, because\nright now they're noninteroperable silos, it's still\ntechnically feasible.</p>\n<h4 id=\"identity\">Identity <a class=\"direct-link\" href=\"#identity\">#</a></h4>\n<p>As I said above, we need to have some notion of user identity. Identity\nis used for two purposes:</p>\n<ol>\n<li>\n<p>By the end-user clients (in an end-to-end system) to\nestablish the keys to use to encrypt a message.</p>\n</li>\n<li>\n<p>By the service to know how to route messages.</p>\n</li>\n</ol>\n<p>Both of these require identifying other people you want\nto exchange messages with.</p>\n<div class=\"callout\">\n<h4 id=\"imessage\">iMessage <a class=\"direct-link\" href=\"#imessage\">#</a></h4>\n<p>iMessage is actually quite an interesting case because the\nApple client is actually two clients in one, containing\nboth an SMS client for talking to non-Apple users (the\ngreen bubble) and\nan iMessage client for talking to Apple users (the blue\nbubble). iMessages are sent over the Internet (&quot;over the top&quot;) and are\nend-to-end encrypted. SMS messages are sent over the\nphone network and are not. However, both categories\nof users have the same type of addresses in the form\nof phone numbers iMessage (which also supports\nemail addresses) and Apple automatically detects the\ncapabilities of the message recipient and sends a message\nof the appropriate type.</p>\n<p>iMessage might be one of the strongest cases for the benefits\nof interoperability because it already <em>interoperates</em>\nwith Android devices, just in the clear over SMS. If iMessage\nwas forced to interoperate and Android played along, then\na large fraction of traffic would suddenly be encrypted.</p>\n</div>\n<p>At a high level, there are two main identity architectures we can have:</p>\n<ul>\n<li>\n<p>Hierarchical naming in which a given identity indicates\nwhich service it is attached to, as in e-mail.</p>\n</li>\n<li>\n<p>A shared namespace in which a given identity could be\nattached to any service (like phone numbers).</p>\n</li>\n</ul>\n<p>With messaging, the situation is even more complicated because\nmultiple messaging services use the same identifier (e.g.,\nWhatsApp and iMessage both use phone numbers) so that means\nthat even in an interoperable system, we'd need to find some way\nto manage that case, which seems like a real open question\n(though of course we already have that problem now when you\ntell someone &quot;I'm 1.415.555.1111 on WhatsApp&quot;, so in the\nworst case scenario, we could just punt the problem to the user.)\nWe also have the potential problem that <code>alice</code> on\nsystem A may be a different person from <code>alice</code> on system B;\nthis shouldn't happen with phone numbers because they are uniquely\nassigned but it happens all the time with user-chosen handles.</p>\n<p>The hierarchical design is obviously easier to manage, but it\nmay be quite hard to retrofit to the existing non-hierarchical\nsystem.<sup class=\"footnote-ref\"><a href=\"#fn7\" id=\"fnref7\">[7]</a></sup>\nOne possible approach is to have a hierarchical system under\nthe hood but have UIs present unqualified namespaces,\ne.g., &quot;Connect with 1.415.555.1111 on WhatsApp&quot; in the UI\nturns into &quot;Connect with <code>1.415.555.1111@whatsapp.com</code> at\nthe protocol layer.&quot;\nThis is likely to work OK if there are a small number of\nmessaging systems but less well if there are hundreds\nbecause the UI gets too cluttered. It's also possible to have a kind\nof hybrid UI like existing e-mail systems do for there\naccounts where you have a chooser for the common systems\nand then people can enter something freeform:</p>\n<p><img src=\"/img/mail-chooser.png\" alt=\"Email account chooser\"></p>\n<p>This brings us to the question of how users learn other\nusers keying material.\nIn a fully distributed/federated world like e-mail, you'd need\nsome sort of analog to the WebPKI in which there was a set of\nagreed up on roots of trust and those roots then somehow were\nable to attest to identities in a uniform manner, no matter\nwhich messaging service people used. This in contrast to the\ncurrent situation where each service runs its own disconnected\nidentity service. If there\nis a totally shared namespace, then this has a lot of the same\nproblems as the WebPKI in which anyone can attest to any name,\nbut if the names are arranged hierarchically—even if\nthat's not visible to the user—then we could potentially\ndodge some of those problems, as only WhatsApp would be able\nto attest to names for <code>@whatsapp.com</code>, etc.<sup class=\"footnote-ref\"><a href=\"#fn8\" id=\"fnref8\">[8]</a></sup></p>\n<p>It's also possible that one could do something less universal:\nif there are only a modest number of messaging services, and you\nhave to make special arrangements to federate between services,\nthen each service could continue to maintain its own identity\nsystem and just publish documentation about how it\nworks, forcing the other systems could implement\nthat. The likely outcome here would be that the big gatekeeper\nsystems would each have something and if you wanted to talk\nto them, you would need to both consume and publish that, which\nis a burden on the smaller systems, but perhaps a bearable one\n(the tricky part is when Alice has accounts on WhatsApp and iMessage\nand wants to talk to someone on ekrMessage: which credentials\ndoes she use for the ekrMessage user?).</p>\n<h4 id=\"message-transport\">Message Transport <a class=\"direct-link\" href=\"#message-transport\">#</a></h4>\n<p>Once we have established keys and are sending messages, we still need some\nway to transport them. There have been attempts to design standardized\nprotocols for this, in particular <a href=\"https://xmpp.org/\">XMPP</a>\nand <a href=\"https://en.wikipedia.org/w/index.php?title=SIMPLE_(instant_messaging_protocol)&amp;oldid=1074023895\">SIMPLE (which is not)</a>,\nbut neither has seen the kind of adoption that would make it the\nobvious choice here.<sup class=\"footnote-ref\"><a href=\"#fn9\" id=\"fnref9\">[9]</a></sup></p>\n<p>As with identity, while it would be convenient to offer something standardized,\nit's probably not a dealbreaker not to have it, as long as services\nare required to offer interoperable APIs for message sending\nand delivery. The good news here is that unlike the cryptographic\npieces, those APIs can largely be handled by the messaging\nservice, rather than the client, so my ekrMessage client just\nneeds to know that a given message is destined for someone on\nWhatsApp and it can route it there.</p>\n<h4 id=\"message-contents-and-features\">Message Contents and Features <a class=\"direct-link\" href=\"#message-contents-and-features\">#</a></h4>\n<p>All of the above is just concerned with getting messages from point\nA to point B, but what people actually care about is the messages\nthemselves. In order for messaging to work properly, when the\nmessages finally get to the recipient, they need to be readable,\nwhich won't work if (say) system A uses ASCII messages\nand system B encodes them as images. Moreover, if system B\nwants to add some new feature, it's a problem if system\nA doesn't have it (<a href=\"#critiques\">critique 2</a>).</p>\n<p>As noted above, this is a sort-of solved problem in e-mail\nin that you can send MIME-encoded messages that describe their\ncontents. But of course, describing the contents doesn't\nhelp if someone sends me a message of type <code>image/avif</code>\nand I don't know how to parse that. The conventional solution\nhere is to have\nsome common format that it's assumed that everyone can read\n(in e-mail this is 7-bit ASCII text). The sender then sends\n<em>two</em> copies of the content bundled in the same message: (1) the &quot;basic&quot;\nversion that everyone should be able to read and (2) the &quot;enhanced&quot;\nversion that only newer clients can read.</p>\n<p>This is a workable, if not ideal, solution, but actually it's\nprobably possible to do quite a bit better. The reason is that\nunlike e-mail, where you send messages to people based\nsolely on their address, in order to send someone an encrypted\nmessage you need their key. When people publish their keys then\ncan also publish other capabilities such as the various media\ntypes they understand, which gives senders some information about\nwhat messages are safe to send (Rohan Mahy has\ndescribed such a <a href=\"https://www.ietf.org/id/draft-mahy-mls-content-neg-00.html\">mechanism</a>\nfor MLS.)\nUnfortunately, it's still possible to get into trouble with\nlarger groups with mixed capabilities, where you probably\nend up having to send a lowest common denominator version.\nThis isn't ideal for ordinary features, but is potentially\nmore problematic for security features, as discussed below.</p>\n<p>As should be clear from the discussion above, any form of\ninteroperability places some limits on the freedom of each service to\nchange their offerings whenever they want. Some of these\ncosts—like using a standardized encryption protocol—are\nrelatively modest, but others may be larger. It's certainly a lot more\nwork to detect the capabilities of every client and carefully craft\nmessages which will work for all of them than it is to just generate\nmessages for one client type which you know works.</p>\n<h2 id=\"security-implications-of-interoperability\">Security Implications of Interoperability <a class=\"direct-link\" href=\"#security-implications-of-interoperability\">#</a></h2>\n<p>As discussed above, if connecting service A and\nservice B requires some kind of bridge that decrypts and reencrypts\nmessages, then this has a pretty negative impact on security (<a href=\"#critiques\">critique 1</a>).\nHowever, it's also possible to have interoperable end-to-end encryption;\nI would also argue that with sufficient care it's even possible to design\nan identity infrastructure that doesn't badly weaken the system as\na whole. However, that isn't to say that there are no security\nimplications of requiring interoperability.</p>\n<p>First, even if you have a common protocol, there may be differences\nin application semantics. For example, when WhatsApp detects\nthat a recipient has changed their keys and so a message is\nundecryptable, it <a href=\"https://www.schneier.com/blog/archives/2017/01/whatsapp_securi.html\">automatically re-sends the message</a>.\nThis is a usability feature but is a difference from Signal, which\ndoes not automatically re-send—even though they use the same protocol as WhatsApp—because Signal is concerned that the new key might be compromised. This is an application\nbehavior and it's of course\nharder to frame the security guarantees of a system where there\nis more than kind of client; in this case, the security decision\nis made by the sender, but in other cases it might not be.</p>\n<p>One case where that's so is that messaging systems\nsupport &quot;disappearing messages&quot; which get automatically deleted\nafter a certain time. This is not a cryptographic feature but\nrather a client side feature and depends on the receiving client\ncomplying with the sender's request to delete the message. Obviously,\nif the remote client doesn't comply, then it's not going to work.\nI'm less sympathetic to this case because this kind of feature\nis mostly an example of hope-based security: even in a closed\nsystem you have <a href=\"/posts/verifying-software\">no way of knowing what software is running on the\nreceiver's computer</a>; it could have been\nhacked or they could have reverse-engineered non-compliant\nsystem (the virtue of standards is that they allow for\ninteroperability without reverse engineering).\nEven if that's not the case, nothing stops them from\ntaking a photo of the screen, or, depending on the system,\na screenshot. This seems like a case where the recipient can\nadvertise its capabilities and you just have to trust them.</p>\n<p>There might also be new security features that would not\nend up in whatever new standardized protocol was settled on,\nsuch as metadata protection or post-quantum security. This isn't\nideal, of course, but standardized protocols do evolve, and it's\npossible for messaging services to use private protocol extensions\nfor groups that just consist of their users on new clients, so\nthis doesn't seem like a fatal objection.</p>\n<p>Probably the most serious problem is spam and abuse (<a href=\"#critiques\">critique 3</a>). As I\nmentioned earlier, this is a much easier problem if you\nhave relationships with all the users and don't need to\naccept messages from arbitrary counterparties. End-to-end\nencryption also presents a problem here because it means\nyou can't do content filtering centrally. I'm not sure how serious\nthis would actually be in practice: a lot of what makes\nemail spam work is that you have to accept email from\nnon-contacts, which is somewhat less of an issue in\nmessaging systems, but this still seems like a\nproblem that needs more work.</p>\n<h2 id=\"critique-recap\">Critique Recap <a class=\"direct-link\" href=\"#critique-recap\">#</a></h2>\n<p>It's probably useful to recap the critiques from the <a href=\"#critiques\">beginning</a> of\nthis post. I don't think they are entirely without merit, but I also believe\nthat interoperability would have real benefits that need to be weighed\nagainst these concerns.</p>\n<h4 id=\"interoperability-will-weaken-security\">Interoperability will weaken security <a class=\"direct-link\" href=\"#interoperability-will-weaken-security\">#</a></h4>\n<p>It's certainly true that there are ways to implement interoperability\nwhich would have a very negative impact on security. However, as I\nargue above, I think it's also possible to implement interoperability\nin ways which would minimize those impacts, in particularly by maintaining\nend-to-end encryption across system boundaries. Clearly, the resulting\nsystem would be more complex, which is bad for security, but having\na common system would provide a single target for analysis and improvement,\nwhich is good.</p>\n<p>It's also important to look at the non-technical picture here: right now users\nlargely choose their messaging systems based on who they want to talk to\nand get whatever security properties those systems have. Interoperability\nwould allow people to choose systems based on security properties—for\ninstance that they have <a href=\"https://github.com/google/keytransparency/\">key transparency</a>\nand <a href=\"https://reproducible-builds.org/\">reproducible builds</a>—while\nstill talking to people who have made other choices. Of course, those\nmixed conversations tend to have the security properties of the weaker\nsystem, but at least it would be easy to also talk to people who had\nmade stronger choices. In addition, we see many cases today where people use\nback to unencrypted channels in order to interoperate (e.g., iMessage falling back to SMS),\nwhich would be improved by end-to-end interoperability.</p>\n<h4 id=\"interoperability-will-hold-back-innovation\">Interoperability will hold back innovation <a class=\"direct-link\" href=\"#interoperability-will-hold-back-innovation\">#</a></h4>\n<p>Here too, the situation is complicated. On the one hand, it's clearly true that\nmessaging services would be less free to innovate than if they were totally\nvertically integrated (although they would still retain substantial freedom).\nOn the other hand, there would be more room for innovation on the clients\nthemselves, something which is currently very difficult. It's worth noting\nthat the Web is one giant mostly interoperable system which is still\nexperiencing plenty of innovation, so I don't think it's a foregone\nconclusion that interoperable systems can't innovate; you just need\nmechanisms to manage compatibility and change.</p>\n<h4 id=\"interoperability-will-make-abuse-worse\">Interoperability will make abuse worse <a class=\"direct-link\" href=\"#interoperability-will-make-abuse-worse\">#</a></h4>\n<p>It does seem likely that interoperability will make abuse worse: if you\nhave to accept messages from basically anyone then reputation and\nsimilar systems become harder, and e-mail abuse (especially spam) is\na serious problem. However, we already see abuse even in monolithic systems,\nso it's also clear that being closed isn't a panacea.\nMoreover, messaging is fundamentally different from e-mail in a number\nof important ways (we'll have authentication from the start, which\nwas a huge problem in e-mail, there is much less expectation that you'll\njust accept messages from anyone, etc.) so it's not clear how much\nworse interoperability will make things.</p>\n<h2 id=\"final-thoughts\">Final Thoughts <a class=\"direct-link\" href=\"#final-thoughts\">#</a></h2>\n<p>As the extremely long writeup above should indicate, this is far\nfrom an easy problem. We have a giant installed base of software\nthat doesn't interoperate and changing that would be difficult\neven if the big players wanted to. Famously, Facebook\nhas been <a href=\"https://screenrant.com/whatsapp-cross-chat-facebook-messenger-instagram-optional-interoperability/\">trying to get Messenger and WhatsApp to interoperate\nin an end-to-end secure fashion for years</a>,\nand it seems likely that they're going to be a lot less excited about\ninteroperating with others. However, that's separate question\nfrom whether it's actually technically possible to do, which,\nas the analysis above suggests, I think it is.\nWith that said, this is also a much harder problem than\nthe EU guidelines seem to contemplate: for instance,\nthey require that basic 1-1 messaging be\navailable within three months, and group messaging within\ntwo years. Given that the MLS standardization process\nis just about complete after <a href=\"https://datatracker.ietf.org/wg/mls/history/\">four years</a>,\ntwo years seems pretty aggressive, and three months seems\nfairly implausible.</p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>\nNote that email frequently has <em>transport</em> encryption where\nmessages are encrypted between users and mail servers\nand between mail servers, but they are generally in the\nclear on the mail server. <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>What it looks up is\n<a href=\"https://en.wikipedia.org/w/index.php?title=MX_record&amp;oldid=1037761196\">mail exchanger (MX) record</a>. <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>\nAnd Alice doesn't even need to know that much. For instance,\nif Gmail suddenly decided to support domains\n<a href=\"/posts/dns-security-blockchain/\">rooted in the blockchain</a>,\nthis would just work transparently for Alice, because\nonly Gmail needs to know which server handles <code>example.eth</code>. <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p>\nOf course, users don't always upgrade instantaneously, so it's\npossible to have some heterogeneity, but it's typically fairly\nshort term, especially because the service provider can\nforce you to update to continue using the service. <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p>\nNote: The difference between\n&quot;APIs&quot; and &quot;protocols&quot; is largely a matter of terminology:\nprotocols are just the rules for what go over the network,\nbut things that run over HTTP are often called &quot;APIs&quot;. <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn6\" class=\"footnote-item\"><p>\nIn many protocols, that pairwise key is itself changed\n(&quot;ratcheted&quot;) frequently. <a href=\"#fnref6\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn7\" class=\"footnote-item\"><p>\nAs an aside, am I just the only person who thinks that\nthe proliferation of these non-hierarchical namespaces\nis a huge regression? I'd much rather be <code>ekr@rtfm.com</code>\neverywhere than <code>ekr</code> on Github and <code>ekr____</code> on\nTwitter. <a href=\"#fnref7\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn8\" class=\"footnote-item\"><p>There\nare also questions about key transparency and the like,\nbut they're largely downstream of these bigger architectural\nquestions. <a href=\"#fnref8\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn9\" class=\"footnote-item\"><p>\nGoogle chat used to offer an XMPP interface but no longer does. <a href=\"#fnref9\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n\n    </article>\n\n    <section class=\"header-line\">\n      <h3>Keep Reading</h3>\n      <ul><li>Next: <a href=\"/posts/lake-sonoma-50/\">Lake Sonoma 50 Race Report</a></li><li>Previous: <a href=\"/posts/www-prefix/\">What&#39;s with the www prefix in www.example.com?</a></li>\n      </ul>\n    </section>\n      \n  </div>\n  <aside class=\"grid-sidebar\">\n\n    <section class=\"box\">\n      <h2>More from Educated Guesswork</h2>\n      <p>Tech, tech policy, and sometimes running by <a href=\"/about\">Eric Rescorla</a>. Subscribe to the newsletter for more like this:</p>\n      <form class=\"inline-form\" action=\"https://educatedguesswork-subscribe.herokuapp.com/subscribe\" method=\"post\">\n  <input type=\"email\" placeholder=\"Your e-mail address...\" id=\"email\" name=\"email\">\n  <button class=\"subscribe-button\">Subscribe</button>\n</form>\n\n\n    </section>\n\n    <section>\n      <h3>Recent Posts</h3>\n\n      \n      <ul reversed class=\"postlist\"}\">\n\n  <li class=\"postlist-item\">\n    <a href=\"/posts/safe-browsing-privacy/\" class=\"postlist-link\">Can we make Safe Browsing safer?</a>\n    <time class=\"postlist-date\" datetime=\"2022-08-16\">16 Aug 2022</time>\n    <span class=\"post-tags\">\n    \n      <a href=\"/tags/networking/\" class=\"post-tag\">networking</a>\n      <a href=\"/tags/security/\" class=\"post-tag\">security</a>\n      <a href=\"/tags/privacy/\" class=\"post-tag\">privacy</a>\n      <a href=\"/tags/pir/\" class=\"post-tag\">pir</a>\n    </span>\n  </li>\n\n  <li class=\"postlist-item\">\n    <a href=\"/posts/messaging-discovery/\" class=\"postlist-link\">Discovery Mechanisms for Messaging and Calling Interoperability</a>\n    <time class=\"postlist-date\" datetime=\"2022-08-04\">04 Aug 2022</time>\n    <span class=\"post-tags\">\n    \n      <a href=\"/tags/encryption/\" class=\"post-tag\">encryption</a>\n      <a href=\"/tags/policy/\" class=\"post-tag\">policy</a>\n      <a href=\"/tags/messaging/\" class=\"post-tag\">messaging</a>\n    </span>\n  </li>\n\n  <li class=\"postlist-item\">\n    <a href=\"/posts/pacifica-foothills/\" class=\"postlist-link\">Pacifica Foothills Race Report</a>\n    <time class=\"postlist-date\" datetime=\"2022-07-25\">25 Jul 2022</time>\n    <span class=\"post-tags\">\n    \n      <a href=\"/tags/running/\" class=\"post-tag\">running</a>\n      <a href=\"/tags/race report/\" class=\"post-tag\">race report</a>\n    </span>\n  </li>\n\n  <li class=\"postlist-item\">\n    <a href=\"/posts/random-audits/\" class=\"postlist-link\">Verifiably selecting taxpayers for random audit</a>\n    <time class=\"postlist-date\" datetime=\"2022-07-11\">11 Jul 2022</time>\n    <span class=\"post-tags\">\n    \n      <a href=\"/tags/privacy/\" class=\"post-tag\">privacy</a>\n      <a href=\"/tags/security/\" class=\"post-tag\">security</a>\n    </span>\n  </li>\n\n  <li class=\"postlist-item\">\n    <a href=\"/posts/tenaya-loop2/\" class=\"postlist-link\">Tenaya Loop Adventure Run 2: Redemption</a>\n    <time class=\"postlist-date\" datetime=\"2022-07-08\">08 Jul 2022</time>\n    <span class=\"post-tags\">\n    \n      <a href=\"/tags/running/\" class=\"post-tag\">running</a>\n      <a href=\"/tags/race report/\" class=\"post-tag\">race report</a>\n    </span>\n  </li>\n\n</ul>\n\n      <p><a href=\"/posts/\">Full archives ...</a></p>\n    </section>\n\n  </aside>\n</div>\n\n<!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{\"token\": \"8950ce09297145caa48662b027542727\"}'></script><!-- End Cloudflare Web Analytics -->\n\n\n          </main>\n        </div>\n\n      <footer>\n        <div class=\"wrapper\">\n          <p>Subscribe to the newsletter for more like this:</p>\n          <form class=\"inline-form\" action=\"https://educatedguesswork-subscribe.herokuapp.com/subscribe\" method=\"post\">\n  <input type=\"email\" placeholder=\"Your e-mail address...\" id=\"email\" name=\"email\">\n  <button class=\"subscribe-button\">Subscribe</button>\n</form>\n\n\n          </div>\n      </footer>\n    </div>\n    <!-- Current page: /posts/messaging-e2e/ -->\n  </body>\n</html>\n","oembed":false,"readabilityObject":{"title":"End-to-End Encryption and Messaging Interoperability","content":"<div id=\"readability-page-1\" class=\"page\"><div>\n          <main>\n            \n<div>\n    <article>\n        \n        \n\n        <p>The <a href=\"https://www.europarl.europa.eu/news/en/press-room/20220315IPR25504/deal-on-digital-markets-act-ensuring-fair-competition-and-more-choice-for-users\">news</a> the the EU\nwill <a href=\"https://www.ianbrown.tech/wp-content/uploads/2022/03/Final-DMA-interoperability-text.pdf\">require that messaging companies provide\ninteroperability</a>\nhas gotten a lot of attention, both positive\n(<a href=\"https://matrix.org/blog/2022/03/25/interoperability-without-sacrificing-privacy-matrix-and-the-dma\">matrix.org</a>)\nand negative (<a href=\"https://twitter.com/alexstamos/status/1507145126006587411\">Alex\nStamos</a>,\n<a href=\"https://alecmuffett.com/article/16037\">Alec Muffett</a>, <a href=\"https://twitter.com/SteveBellovin/status/1507375010054348805\">Steve\nBellovin</a>),\nas detailed in this\n<a href=\"https://www.wired.com/story/dma-interoperability-messaging-imessage-whatsapp/\">Wired</a>\narticle (see also this <a href=\"https://www.internetsociety.org/wp-content/uploads/2022/03/ISOC-EU-DMA-interoperability-encrypted-messaging-20220311.pdf\">ISOC</a>\nwhite paper). At a high level,\nI'm more positive on the idea of interoperability for messaging systems\nthan some others are, but it's certainly not a trivial problem and\nat least some of the EU timelines seem pretty unreasonable. Read on\nfor more.</p>\n<h2 id=\"critiques\">Critiques <a href=\"#critiques\">#</a></h2>\n<p>At a high level, there seem to be three broad critiques of messaging system\ninteroperability:</p>\n<ol>\n<li>It will weaken security, for instance by requiring decryption\nand re-encryption at system boundaries or by creating\nconfusion about user identities.</li>\n<li>It will hold back innovation by forcing messages to be\nsent using only features that are common to all systems.</li>\n<li>It will make abuse (especially spam) worse.</li>\n</ol>\n<p>It's useful to keep these in mind throughout the rest of the discussion.</p>\n<p>Before covering messaging, however, it's helpful look at an existing\nsystem that has had interoperability for a long, where we can see the\nresulting dynamics: e-mail.</p>\n<h2 id=\"an-interoperable-system%3A-e-mail\">An Interoperable System: E-mail <a href=\"#an-interoperable-system%3A-e-mail\">#</a></h2>\n<p>E-mail has the\nopposite problem from messaging: where messaging consists of a number\nof independent islands of encrypted messaging with no way to talk\nbetween them, email is a globally interoperable system that—despite\na number of attempts—doesn't have anything like universal encryption.<sup><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n<p>E-mail operates on a hub-and-spoke model in which every user is\nassociated with a given mail domain, represented by a domain\nname (e.g., <code>example.com</code>) as shown below:</p>\n<p><img src=\"/img/email.drawio.png\" alt=\"Email architecture\"></p>\n<div>\n<h4 id=\"telephone-addressing\">Telephone Addressing <a href=\"#telephone-addressing\">#</a></h4>\n<p>Telephone numbers actually are <em>hierarchically structured</em> but don't map 1-1 with providers.</p>\n<p>The basic structure of a phone number is given by the <a href=\"https://en.wikipedia.org/w/index.php?title=E.164&amp;oldid=1073189249\">E.164 standard</a> and consists of a country code followed by a subscriber number,\nwith the structure of the subscriber number being defined by the country\ncode. For instance, in the <a href=\"https://en.wikipedia.org/w/index.php?title=North_American_Numbering_Plan&amp;oldid=1075584876\">North American Numbering Plan</a>, identified by country code 1, numbers\nlook like: <code>415.555.1111</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Description</th>\n<th>Digits</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Numbering plan area (aka area code)</td>\n<td>3</td>\n<td><code>415</code></td>\n</tr>\n<tr>\n<td>Central office prefix</td>\n<td>3</td>\n<td><code>555</code></td>\n</tr>\n<tr>\n<td>Line number, denoting subscriber</td>\n<td>4</td>\n<td><code>1111</code></td>\n</tr>\n</tbody>\n</table>\n<p>I don't know too much about the non-North American setting, so the remainder of\nthis aside is about North America.\nUntil 1984, North American telephony was basically monopolized by\nthe <a href=\"https://en.wikipedia.org/w/index.php?title=Bell_System&amp;oldid=1080354068\">Bell System</a>. In\nthat system, the number hierarchy was geographic, with the area codes\nand central office prefixes corresponding to geographic regions and\nspecific switches and the line number corresponding to lines on a given\nswitch. However, with the advent of local number competition following\nthe breakup of the Bell System and then mobile telephony, things started\nto get more complicated.</p>\n<p>Initially, central offices were controlled by a single carrier and\nso the phone number could be used straightforwardly for routing.\nHowever, subsequently the US required carriers\nto provide <a href=\"https://en.wikipedia.org/w/index.php?title=Local_number_portability&amp;oldid=1077125532\">Local Number Portability</a>, which allowed you to take your number from carrier to carrier.\nThus, even if you were originally assigned a number out of Verizon's\nblock, you could \"port\" it to T-Mobile, which means that this kind of hierarchical\nrouting no longer works. Instead, there's basically a giant—well,\nnot so giant, given that there are only 10 billion possible numbers—database\nthat indicates which carrier has responsibility for each number.</p>\n</div>\n<p>E-mail addresses are hierarchically assigned, which means that if your\nmail service is <code>example.com</code>, then your address will end in\n<code>@example.com</code>, as in <code>alice@example.com</code>.\nIt's helpful to work through an example here. For instance, here is\nwhat happens when Alice (<code>alice@hotmail.com</code>) wants to send a message to Bob (<code>bob@gmail.com</code>):</p>\n<ol>\n<li>\n<p>First, she transmits the message to her mail server\nover a protocol called the <em><a href=\"https://en.wikipedia.org/w/index.php?title=Simple_Mail_Transfer_Protocol&amp;oldid=1079015503\">Simple Mail Transfer Protocol (SMTP)</a></em>,\nalong with the addressing information for <code>bob@gmail.com</code>.</p>\n</li>\n<li>\n<p>The sending mail server looks up the receiving\ndomain name—in this case <code>gmail.com</code>—in the DNS\nto get the server associated with it.<sup><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup> It then connects to that server—again over\nSMTP—and transfers the message, along with the\naddressing information <code>bob@gmail.com</code>.</p>\n</li>\n<li>\n<p>Assuming that <code>bob@gmail.com</code> is actually a valid user on\nthe receiving server, that server stores the message somewhere\n(on disk, in a database, whatever) and waits for Bob to\ncome pick it up.</p>\n</li>\n<li>\n<p>Finally, Bob connects to his mail server (historically over\na protocol called <em><a href=\"https://en.wikipedia.org/w/index.php?title=Internet_Message_Access_Protocol&amp;oldid=1071482084\">Internet Message Access Protocol (IMAP)</a></em>)\nand retrieves any new messages.</p>\n</li>\n</ol>\n<p>This structure has a number of important properties:</p>\n<h4 id=\"addresses\">Addresses <a href=\"#addresses\">#</a></h4>\n<p>Because addresses are <em>scoped</em> by the mail domain they are\nassociated with, it's possible to immediately know where\na given message should be delivered just by looking at the\n<em>right-hand side (RHS)</em> of the address, namely the stuff\nafter the <code>@</code>-sign. That tells you which domain an\naddress is associated with. This is in contrast to addresses\non most popular services (e.g., Twitter), which are <em>unqualified</em>:\nif all I have is the identifier <code>ekr____</code> I don't know if\nthat corresponds to Twitter, Github, or LinkedIn..<sup><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup></p>\n<p>Conversely, the fact that names are hierarchical means that\ntwo people can have the same <em>left-hand side (LHS)</em> as long as the RHS is\ndifferent (and vice versa). So, <code>bob@gmail.com</code> and <code>bob@hotmail.com</code>\nare totally distinct addresses and quite likely belong to different\npeople. This is of course true with Twitter handles and the\nlike, but because they are <em>unqualified</em>, the bare address\nisn't enough to tell you who is who. This becomes a real issue\nwhen you want to import identities from another namespace,\nfor example, when your address for messaging is actually your\ntelephone number.</p>\n<p>Finally, it means that the semantics of the LHS\nare opaque to the other end. For instance, if you had your\nown mail domain (for instance <code>your-lastname.name</code>) you\nmight have every address that ends in <code>@your-lastname.name</code>\ndelivered into the same mailbox. Another example is that\nGmail allows you to create new addresses by adding a plus sign\nto the end of your actual address, so <code>example@gmail.com</code>\nand <code>example+newsletter@example.com</code> go to the same place.\nThis is a useful trick to let you sort your email by giving\ndifferent addresses to each sender.</p>\n<div>\n<h4 id=\"hosted-domains\">Hosted Domains <a href=\"#hosted-domains\">#</a></h4>\n<p>Although mail is scoped by domain, as a practical matter\nmany domains are actually hosted by the same service.\nFor instance, Gmail allows you to host your \"custom domain\"\non Gmail (that is how <code>rtfm.com</code> works), but your\naddress can still have your domain in it rather than\n<code>gmail.com</code>. It's also possible to have your mail\ndelivered to service A and have most of your accounts\nthere but send mail from service B. This is useful if you\nwant to send bulk email using a service like <a href=\"https://www.mailgun.com/\">Mailgun</a>.</p>\n</div>\n<h4 id=\"interoperability\">Interoperability <a href=\"#interoperability\">#</a></h4>\n<p>Because SMTP and IMAP are standardized, any mail endpoint\ncan talk to any other mail endpoint. If you own <code>example.com</code>\nand want to send and receive mail there, all you have to do\nis stand up a server—or more likely, use an existing\nhosting server—set up the right DNS records, and\nyou're good to go. Similarly, most mail services will provide IMAP\nservice and so you can use any number of clients\n(the built in mail client on your Mac, <a href=\"https://en.wikipedia.org/w/index.php?title=Mozilla_Thunderbird&amp;oldid=1074344985\">Thunderbird</a>, etc.) to\nread your mail.</p>\n<p>Conversely, nothing says that a mail system has\nto have a separate client at all. For instance, instead\nof having people use IMAP to read their email you can just\nput up a Web front end that accesses it directly and, tada,\nyou have Gmail. Or, as is common, you can both have a Web interface\n<em>and</em> an IMAP interface. As long as you properly speak SMTP, everything\nwill work fine and the other end doesn't even need to know how\nyou have everything set up; it's just a matter of having the\nright protocol interfaces. In particular, it doesn't matter to\nthe receiver how the sender talks to their mail server\nand it doesn't matter to the sender how the receiver\ntalks to their mail server. All that's required is that\nthe servers speak SMTP to each other.</p>\n<p>This is in contrast to most messaging systems, which are basically\nsilos that don't interoperate with each other.</p>\n<h3 id=\"extensibility\">Extensibility <a href=\"#extensibility\">#</a></h3>\n<p>The cost of interoperable protocols is a limited range of\nformat extensibility. The format of the emails is standardized using a\nformat called\n<a href=\"https://en.wikipedia.org/w/index.php?title=MIME&amp;oldid=1080291535\">MIME</a>,\nand if you send a compliant MIME message the receiver should be able\nto process it, at least to figure out what the type of\nthe message is.</p>\n<p>Identifying the type of the message is only the first\nstep. Suppose that you want to introduce a new\nmail feature, say <a href=\"https://apps.apple.com/us/app/memoji/id1526384700\">memoji</a>\nin emails. Even if you write a new standard for it and Alice\nadds it to her email client, what happens if Bob hasn't upgraded?\nIdeally, the client would get some clear message that something\nwas wrong, and yet would still see the part that was\ninterpretable, but this doesn't always work.\nDepending on exactly how the new feature is designed, it either\nmight not work properly—for instance, the memoji might\nbe replaced with  some unknown character like �—\n(for a long time, emails from Outlook would <a href=\"https://www.bleepingcomputer.com/news/microsoft/after-seven-years-microsoft-is-finally-fixing-the-j-email-bug/\">render\nthe :) emoji to \"J\" on non-outlook systems</a>)\nor the message might just not be readable at all (though hopefully\nyou wouldn't design a feature like that).\nAt the end of the day, this kind of mismatch can create\na pretty degraded experience and change the meaning of the message.</p>\n<p>The converse of this property however, is that\nemail <em>processing</em> is highly extensible. Because mail formats\nare open and standardized, any client that speaks the\nprotocol will work. I gave the example of Webmail before,\nbut this also means that if you want to\nuse a mail client which offers some new feature—automatic\nemail summarization say—that's your business.\nBy contrast, most messaging systems are closed and so\nyou're limited to the features supported by the official\nclient.</p>\n<h3 id=\"security%3F\">Security? <a href=\"#security%3F\">#</a></h3>\n<p>Like many things on the Internet, the e-mail system was designed\nbefore modern encryption and so initially everything was in\nthe clear. This allowed for a broad range of attacks:</p>\n<ol>\n<li>\n<p>Anyone on the connection between you and the mail server\nor between mail servers could read or modify your messages.</p>\n</li>\n<li>\n<p>Senders weren't authenticated and so it was trivial to\nforge messages that appeared to come from someone else.</p>\n</li>\n<li>\n<p>If your mail server was compromised, then it could read\nyour messages in transit or change them.</p>\n</li>\n</ol>\n<p>Some of these issues have been gradually sort-of addressed\nwith partial solutions such as TLS encrypting the traffic\nbetween you and the mail server, TLS encrypting\nthe traffic between the mail servers, and server-based\nsigning mechanisms like <a href=\"https://en.wikipedia.org/w/index.php?title=DomainKeys_Identified_Mail&amp;oldid=1080414793\">DKIM</a>. However, they're incompletely\napplied (for instance, the client-server connection\nis generally strongly authenticated but the server-server\nconnection often is not) and still don't provide any protection\nagainst a malicious or compromised mail server. For that\nyou need <em>end-to-end encryption</em> (E2EE), in which the\nmessages are encrypted (and authenticated) between the\nsending and receiving endpoints.</p>\n<p>There have been quite a few attempts to provide end-to-end encryption\nfor e-mail (PGP, S/MIME, etc.) but I think it's fair to describe them\nas having largely failed. This isn't to say that there isn't any encrypted\nmail but it's a fairly small fraction of overall traffic. The\nreasons for the failure of encrypted email are complicated, but\nthere were a number of deployment problems that most likely\ncontributed.</p>\n<h4 id=\"key-management\">Key Management <a href=\"#key-management\">#</a></h4>\n<p>Like any cryptographic system, encrypted email depends on\nknowing the cryptographic keys of the people you are talking to.\nIn e-mail, you use keys in two ways:</p>\n<ol>\n<li>You sign your messages in order to authenticate them</li>\n<li>People who want to send you secure messages need to encrypt them to your\nkey.</li>\n</ol>\n<p>It's technically possible to just start sending people messages with\nunauthenticated\nkeys, for instance by signing all of your messages and expecting\npeople to remember that this is your key (this is often called <em><a href=\"https://en.wikipedia.org/w/index.php?title=Trust_on_first_use&amp;oldid=1052198040\">trust\non first use\n(TOFU)</a></em>).\nOnce they have received a message from you, they can use your key to\nencrypt the return message. Obviously, TOFU is susceptible\nto attack if the that attacker is the first person to send you\na message pretending to be someone else, which makes the system\nless than ideal, especially for interactions with people you don't\ntalk to frequently.  If my bank sends me a signed message, then I want\nto know it's my bank right away. It's also a problem if you want to\nsend an encrypted message to someone you have never talked to\nbefore. What you really want is some system that lets you find out\nwhat people's keys are, which means solving two problems:</p>\n<ul>\n<li>\n<p>You need to somehow associate your key(s) with\nyour email address.</p>\n</li>\n<li>\n<p>You need some way to look up people's keys so that\nyou can send them encrypted messages.</p>\n</li>\n</ul>\n<p>Deploying the infrastructure for both of these has proven to be\nquite challenging. The basic problem is that there was\nnever a good way to automatically issue the credentials.\nThis meant that people had to go to a lot of effort to\nget credentials, which of course meant that most\npeople didn't get them. On the other side of the equation,\nthere was never really a great way to discover\npeople's credentials, which meant that you couldn't\nsend encrypted email to new people. It's in principle\npossible to build mechanisms for this (<a href=\"https://datatracker.ietf.org/doc/rfc8555/\">ACME</a>\nand <a href=\"https://webfinger.net/\">WebFinger</a>\nrespectively are examples of the kind of thing I'm talking\nabout), but we have the usual deployment\n<a href=\"#network-effects\">network effect</a> problems.</p>\n<h4 id=\"confusing-semantics\">Confusing Semantics <a href=\"#confusing-semantics\">#</a></h4>\n<p>In addition to the keying problems, the fact that email encryption was\nadded after the fact to an established system has resulted in some\nconfusing semantics.</p>\n<p>For example, the major extension point in e-mail is via the message\n<em>body</em>. As noted above, the bodies use an extensible message format\ncalled MIME. However the message subject line isn't extensible.\nThis means that the subject line that appears in\nthe email isn't either encrypted or authenticated. It's of course\npossible to have an inner subject line inside the encryption envelope,\nbut it's an obvious challenge for users to understand that they can\ntrust the body but not the subject.</p>\n<p>Second, because some messages are protected and some are not,\nyou need some way to indicate to the user which are which.\nThis kind of indicator is a notorious source of confusion,\nespecially in a situation where most messages are\nunprotected, because you don't want a big scary warning for\nnearly every message. But this also reduces the incentive for people\nto use secure e-mail, especially to send signed\ne-mail: if recipients don't notice or care whether\nmessages are signed, then signing them doesn't add\na lot of value, as an attacker can just impersonate you\nwith the recipient being none the wiser.</p>\n<h4 id=\"network-effects\">Network Effects <a href=\"#network-effects\">#</a></h4>\n<p>All of this should be a familiar story to EG readers: you\nhave a situation where it's inconvenient for people to do\nsomething—in this case, deploy encryption—and\nthere's not much benefit to doing it. In these cases, you get the expected result which is\nlimited or minimal deployment. By contrast, most modern messaging systems\nwere either built with E2EE from the start or underwent\nsome mass upgrade that enabled it for everyone, rather\nthan relying on people to do it themselves.</p>\n<h2 id=\"messaging-systems\">Messaging Systems <a href=\"#messaging-systems\">#</a></h2>\n<p>Modern messaging systems have addressed these issues by making\nencryption both mandatory and automatic. This is comparatively\neasy because the messaging service is (usually) vertically integrated:\nall—or nearly all—users have clients which are provided\nby the service operator and can be updated as desired. The\nservice operator also provides message routing and identity.\nThis kind of uniform integrated system has a number of operational\nadvantages:</p>\n<ul>\n<li>\n<p>The service can automatically issue credentials based on the\nuser's account information, thus ensuring that every user\nhas a credential. They can also run a directory which makes\nit easy for any client to learn the credentials for every\nother client.</p>\n</li>\n<li>\n<p>When the service wants to add a new feature it can automatically\nupgrade everyone's client to support it. This means that they\ndon't need to deal with massive heterogeneity of client functionality\nfor very long, and can eventually just refuse to support older\nclients.<sup><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup></p>\n</li>\n<li>\n<p>Spam and other kinds of abuse are easier to handle because\nall messages are authenticated by a user in the system. Of\ncourse, if you have a single central point where all\nmessages are handled, and no end-to-end encryption, then content\nfiltering is more difficult.</p>\n</li>\n</ul>\n<p>Of course, many of these advantages depend on having a closed system:\nif a significant fraction of people use third party clients to talk to\nsuch a system then you can no longer update the clients whenever\nyou want to, which makes central extensibility much more difficult.\nIn other words, you're trading off user control and extensibility for users\nfor control and extensibility by the system operator. This is in\nstark contrast to the design of the Web, which is dominated by\nthe principle of end-user control as documented in\nthe <a href=\"https://www.w3.org/TR/html-design-principles/#priority-of-constituencies\">HTML Priority of Constituencies</a>\nand the <a href=\"https://webvision.mozilla.org/full/#usercontrol\">Mozilla Web Vision</a>.</p>\n<p>Another consequence of a closed system is a lack of universal connectivity:\nwith e-mail—or telephony—you can contact anyone no matter\nwhich service provider they are on. In fact, you don't even have to\nthink about it: you just e-mail (or dial). Messaging, however, is different:\nif I want to send a message to someone on WhatsApp, I need to have\na WhatsApp account myself. And because people choose different messaging\nsystems, this means that it's now common to have accounts on a variety\nof messaging systems (I myself use three regular messaging systems, plus\ncountless Slacks).</p>\n<p>All of this creates a set of market dynamics dominated by network\neffects\n(<a href=\"https://en.wikipedia.org/w/index.php?title=Metcalfe%27s_law&amp;oldid=1071685522\">Metcalfe's Law</a>)\nand getting big: if you have a lot of users, then people have\na strong incentive to join so they can talk to their friends. Conversely,\nif you are a new entrant into the market it is hard to break in\nbecause your early users don't have that many people to talk to.\nThis is probably why we see a lot of regional variation in which\napps are popular, because people want to use whatever app their\nfriends use. Unsurprisingly, this produces some fairly lopsided\nmarket numbers, with Meta controlling two of the top three\nmessaging platforms (WhatsApp and Facebook Messenger):</p>\n<p><img src=\"https://www.messengerpeople.com/wp-content/uploads/2021/05/most-popular-global-mobile-messaging-apps-2021.png\" alt=\"Messaging platforms\"></p>\n<p>This brings us to the topic of interoperability: if it were possible\nfor anyone to start a new messenger app that could still talk to\nWhatsApp and Messenger users, then this would remove a big barrier\nto entry into the market. I don't want to sound too optimistic here:\neven in a nominally open system like e-mail, we still see a huge\n<a href=\"https://blog.shuttlecloud.com/the-most-popular-email-providers-in-the-u-s-a/\">amount of market concentration</a>\non the big mail systems like Gmail, Outlook, and Yahoo. This isn't\ntoo surprising: it's a lot of work to run a good mail system\nand so we'd expect well-funded players to dominate. However,\nit's also quite possible to use one of the smaller services\nlike <a href=\"https://www.fastmail.com/\">Fastmail</a>, <a href=\"https://protonmail.com/\">ProtonMail</a>,\nor <a href=\"https://www.dreamhost.com/\">DreamHost</a> or even run your own server,\nwhereas there's really no way to run your own WhatsApp server.</p>\n<h2 id=\"technical-interoperability-for-messenging\">Technical Interoperability for Messenging <a href=\"#technical-interoperability-for-messenging\">#</a></h2>\n<p>The details of what the DMA will actually require are extraordinarily\nsketchy; as I understand it they would need to be filled out\nby some regulatory agency. However, broadly speaking, there seem to be two options for providing\ninteroperability, as <a href=\"https://www.internetsociety.org/wp-content/uploads/2022/03/ISOC-EU-DMA-interoperability-encrypted-messaging-20220311.pdf\">laid out by ISOC</a>:</p>\n<ol>\n<li>Require services to offer stable APIs.</li>\n<li>Require services to actually interoperate over a standardized\nprotocol.</li>\n</ol>\n<p>These require a bit of unpacking.</p>\n<h3 id=\"stable-apis\">Stable APIs <a href=\"#stable-apis\">#</a></h3>\n<p>The idea behind a stable API is that the service would design and publish interfaces\nthat others could use. There are actually two ways to offer stable APIs:</p>\n<ol>\n<li>\n<p>To <em>clients</em>, allowing someone else's messenger\nclient to work with your service.</p>\n</li>\n<li>\n<p>To <em>services</em>, allowing someone else's messenger service to gateway\nmessages in and out of your service.</p>\n</li>\n</ol>\n<p>The first of this is actually a familiar concept in instant\nmessaging: because there was never a single standardized protocol,\nit was fairly common to have messaging clients, such as\n<a href=\"https://www.trillian.im/\">Trillian</a>,\nwhich would speak multiple protocols but provide a unified interface\nto the user that hid the details. This isn't really a conceptual\nchange in the architecture of the system as it would still be\na monolithic identifier space and the clients would still have\nto conform to whatever rules the service laid out; indeed, some\nservices have open source clients, and so this is already possible\nfor them, though of course third party clients might not\nget upgraded when the official clients do, potentially\nresulting in stability problems.\nThe main result would be some decreased flexibility\nfor the service because they would need to get users of the API\nto update when they wanted to change something that affected\ninteroperability. However, as a practical matter, this probably\nwouldn't have that much of an impact on interoperability\nand market concentration because most people will just use the\nofficial client, and people who don't will be annoyed when\nthe service changes something and breaks them.</p>\n<p>The second version is less familiar, but the idea is presumably that\nWhatsApp would have some published API that would allow\nekrMessage (TM pending!) to gateway messages into and out of\nWhatsApp. As with e-mail, each side would handle messages\naccording to its own rules, with the gateway just\ntransiting messages between the systems.\nThis comes with two main problems:</p>\n<ul>\n<li>\n<p>How do you handle identities? For instance, if ekrMessage\nand WhatsApp both use phone numbers for identities, how\ndo you know which messages stay on WhatsApp and which go\nto ekrMessage?</p>\n</li>\n<li>\n<p>How do you manage different encryption protocols? Currently,\neach messenger has their own encryption protocol; while many\nof these are built along similar lines, they're not necessarily\nidentical. Making this work either requires gatewaying at\nthe provider—thus breaking end-to-end encryption, which\nis extremely undesirable from a security perspective—or\nhaving each client speak multiple encryption protocols,\nas in the multi-protocol client case.</p>\n</li>\n</ul>\n<p>Of course, this would all be a lot easier if there was some\nstandardized protocol that everyone spoke, as with e-mail.\nNote: the difference between a stable API and a standardized protocol isn't\nreally technical so much as social and depends on whether there\nis some standard or just a document published by the service.<sup><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup></p>\n<h3 id=\"standardized-protocol\">Standardized Protocol <a href=\"#standardized-protocol\">#</a></h3>\n<p>Having a standardized protocol is not an\nall-or-nothing proposition: there are actually a number of levels at which one might\nhave standardization, with the other levels potentially not\nbeing standardized:</p>\n<ul>\n<li>Key establishment and message encryption</li>\n<li>Use identity</li>\n<li>Message transport</li>\n<li>Message contents and features</li>\n</ul>\n<p>I go into these in some more detail below.</p>\n<h4 id=\"key-establishment-and-message-encryption\">Key Establishment and Message Encryption <a href=\"#key-establishment-and-message-encryption\">#</a></h4>\n<p>The basic structure of most messaging encryption systems is that\nyou have an identity (e.g., your phone number) which is tied\nto a cryptographic key or keys. When Alice and Bob want to exchange messages,\nthere is some protocol that lets them use their keys to establish a pairwise\n(or groupwise in the case of more than two people) cryptographic\nkey which they then use to encrypt messages.<sup><a href=\"#fn6\" id=\"fnref6\">[6]</a></sup>\nObviously, if Alice and Bob don't speak the same protocol,\nthen they will not be able to establish pairwise keys and will\nnot be able to encrypt messages end-to-end, so this is probably\nthe most important place for everyone to use a common protocol.</p>\n<p>Fortunately, while there are technical differences between the various\nprotocols in use, they're similar enough that it would\nprobably not be prohibitive for everyone to converge on\na common protocol: a number of the existing messenging\nsystems are based on the <a href=\"https://en.wikipedia.org/w/index.php?title=Signal_Protocol&amp;oldid=1062140450\">Signal protocol</a>\nor one of its variants such such as <a href=\"https://wire.com/en/blog/axolotl-proteus-encryption-protocols/\">Proteus</a>\nor <a href=\"https://gitlab.matrix.org/matrix-org/olm/blob/master/docs/megolm.md\">Megolm</a>,\nand the IETF is currently in the final stages of standardizing\na protocol called <a href=\"https://en.wikipedia.org/w/index.php?title=Messaging_Layer_Security&amp;oldid=1076231420\">Messaging Layer Security (MLS)</a> which contains a number of similar concepts but is\nintended to be more optimized for group communication. It's too\nsoon to know how much adoption MLS will get, but the WG has\nhad participation from a number of messenging services such as\nFacebook Messenger, Matrix, Wickr, and Wire (full disclosure: I\nhave also been heavily involved in this effort). It would be a big\nlift for companies to change out their protocols, but, because\nright now they're noninteroperable silos, it's still\ntechnically feasible.</p>\n<h4 id=\"identity\">Identity <a href=\"#identity\">#</a></h4>\n<p>As I said above, we need to have some notion of user identity. Identity\nis used for two purposes:</p>\n<ol>\n<li>\n<p>By the end-user clients (in an end-to-end system) to\nestablish the keys to use to encrypt a message.</p>\n</li>\n<li>\n<p>By the service to know how to route messages.</p>\n</li>\n</ol>\n<p>Both of these require identifying other people you want\nto exchange messages with.</p>\n<div>\n<h4 id=\"imessage\">iMessage <a href=\"#imessage\">#</a></h4>\n<p>iMessage is actually quite an interesting case because the\nApple client is actually two clients in one, containing\nboth an SMS client for talking to non-Apple users (the\ngreen bubble) and\nan iMessage client for talking to Apple users (the blue\nbubble). iMessages are sent over the Internet (\"over the top\") and are\nend-to-end encrypted. SMS messages are sent over the\nphone network and are not. However, both categories\nof users have the same type of addresses in the form\nof phone numbers iMessage (which also supports\nemail addresses) and Apple automatically detects the\ncapabilities of the message recipient and sends a message\nof the appropriate type.</p>\n<p>iMessage might be one of the strongest cases for the benefits\nof interoperability because it already <em>interoperates</em>\nwith Android devices, just in the clear over SMS. If iMessage\nwas forced to interoperate and Android played along, then\na large fraction of traffic would suddenly be encrypted.</p>\n</div>\n<p>At a high level, there are two main identity architectures we can have:</p>\n<ul>\n<li>\n<p>Hierarchical naming in which a given identity indicates\nwhich service it is attached to, as in e-mail.</p>\n</li>\n<li>\n<p>A shared namespace in which a given identity could be\nattached to any service (like phone numbers).</p>\n</li>\n</ul>\n<p>With messaging, the situation is even more complicated because\nmultiple messaging services use the same identifier (e.g.,\nWhatsApp and iMessage both use phone numbers) so that means\nthat even in an interoperable system, we'd need to find some way\nto manage that case, which seems like a real open question\n(though of course we already have that problem now when you\ntell someone \"I'm 1.415.555.1111 on WhatsApp\", so in the\nworst case scenario, we could just punt the problem to the user.)\nWe also have the potential problem that <code>alice</code> on\nsystem A may be a different person from <code>alice</code> on system B;\nthis shouldn't happen with phone numbers because they are uniquely\nassigned but it happens all the time with user-chosen handles.</p>\n<p>The hierarchical design is obviously easier to manage, but it\nmay be quite hard to retrofit to the existing non-hierarchical\nsystem.<sup><a href=\"#fn7\" id=\"fnref7\">[7]</a></sup>\nOne possible approach is to have a hierarchical system under\nthe hood but have UIs present unqualified namespaces,\ne.g., \"Connect with 1.415.555.1111 on WhatsApp\" in the UI\nturns into \"Connect with <code>1.415.555.1111@whatsapp.com</code> at\nthe protocol layer.\"\nThis is likely to work OK if there are a small number of\nmessaging systems but less well if there are hundreds\nbecause the UI gets too cluttered. It's also possible to have a kind\nof hybrid UI like existing e-mail systems do for there\naccounts where you have a chooser for the common systems\nand then people can enter something freeform:</p>\n<p><img src=\"/img/mail-chooser.png\" alt=\"Email account chooser\"></p>\n<p>This brings us to the question of how users learn other\nusers keying material.\nIn a fully distributed/federated world like e-mail, you'd need\nsome sort of analog to the WebPKI in which there was a set of\nagreed up on roots of trust and those roots then somehow were\nable to attest to identities in a uniform manner, no matter\nwhich messaging service people used. This in contrast to the\ncurrent situation where each service runs its own disconnected\nidentity service. If there\nis a totally shared namespace, then this has a lot of the same\nproblems as the WebPKI in which anyone can attest to any name,\nbut if the names are arranged hierarchically—even if\nthat's not visible to the user—then we could potentially\ndodge some of those problems, as only WhatsApp would be able\nto attest to names for <code>@whatsapp.com</code>, etc.<sup><a href=\"#fn8\" id=\"fnref8\">[8]</a></sup></p>\n<p>It's also possible that one could do something less universal:\nif there are only a modest number of messaging services, and you\nhave to make special arrangements to federate between services,\nthen each service could continue to maintain its own identity\nsystem and just publish documentation about how it\nworks, forcing the other systems could implement\nthat. The likely outcome here would be that the big gatekeeper\nsystems would each have something and if you wanted to talk\nto them, you would need to both consume and publish that, which\nis a burden on the smaller systems, but perhaps a bearable one\n(the tricky part is when Alice has accounts on WhatsApp and iMessage\nand wants to talk to someone on ekrMessage: which credentials\ndoes she use for the ekrMessage user?).</p>\n<h4 id=\"message-transport\">Message Transport <a href=\"#message-transport\">#</a></h4>\n<p>Once we have established keys and are sending messages, we still need some\nway to transport them. There have been attempts to design standardized\nprotocols for this, in particular <a href=\"https://xmpp.org/\">XMPP</a>\nand <a href=\"https://en.wikipedia.org/w/index.php?title=SIMPLE_(instant_messaging_protocol)&amp;oldid=1074023895\">SIMPLE (which is not)</a>,\nbut neither has seen the kind of adoption that would make it the\nobvious choice here.<sup><a href=\"#fn9\" id=\"fnref9\">[9]</a></sup></p>\n<p>As with identity, while it would be convenient to offer something standardized,\nit's probably not a dealbreaker not to have it, as long as services\nare required to offer interoperable APIs for message sending\nand delivery. The good news here is that unlike the cryptographic\npieces, those APIs can largely be handled by the messaging\nservice, rather than the client, so my ekrMessage client just\nneeds to know that a given message is destined for someone on\nWhatsApp and it can route it there.</p>\n<h4 id=\"message-contents-and-features\">Message Contents and Features <a href=\"#message-contents-and-features\">#</a></h4>\n<p>All of the above is just concerned with getting messages from point\nA to point B, but what people actually care about is the messages\nthemselves. In order for messaging to work properly, when the\nmessages finally get to the recipient, they need to be readable,\nwhich won't work if (say) system A uses ASCII messages\nand system B encodes them as images. Moreover, if system B\nwants to add some new feature, it's a problem if system\nA doesn't have it (<a href=\"#critiques\">critique 2</a>).</p>\n<p>As noted above, this is a sort-of solved problem in e-mail\nin that you can send MIME-encoded messages that describe their\ncontents. But of course, describing the contents doesn't\nhelp if someone sends me a message of type <code>image/avif</code>\nand I don't know how to parse that. The conventional solution\nhere is to have\nsome common format that it's assumed that everyone can read\n(in e-mail this is 7-bit ASCII text). The sender then sends\n<em>two</em> copies of the content bundled in the same message: (1) the \"basic\"\nversion that everyone should be able to read and (2) the \"enhanced\"\nversion that only newer clients can read.</p>\n<p>This is a workable, if not ideal, solution, but actually it's\nprobably possible to do quite a bit better. The reason is that\nunlike e-mail, where you send messages to people based\nsolely on their address, in order to send someone an encrypted\nmessage you need their key. When people publish their keys then\ncan also publish other capabilities such as the various media\ntypes they understand, which gives senders some information about\nwhat messages are safe to send (Rohan Mahy has\ndescribed such a <a href=\"https://www.ietf.org/id/draft-mahy-mls-content-neg-00.html\">mechanism</a>\nfor MLS.)\nUnfortunately, it's still possible to get into trouble with\nlarger groups with mixed capabilities, where you probably\nend up having to send a lowest common denominator version.\nThis isn't ideal for ordinary features, but is potentially\nmore problematic for security features, as discussed below.</p>\n<p>As should be clear from the discussion above, any form of\ninteroperability places some limits on the freedom of each service to\nchange their offerings whenever they want. Some of these\ncosts—like using a standardized encryption protocol—are\nrelatively modest, but others may be larger. It's certainly a lot more\nwork to detect the capabilities of every client and carefully craft\nmessages which will work for all of them than it is to just generate\nmessages for one client type which you know works.</p>\n<h2 id=\"security-implications-of-interoperability\">Security Implications of Interoperability <a href=\"#security-implications-of-interoperability\">#</a></h2>\n<p>As discussed above, if connecting service A and\nservice B requires some kind of bridge that decrypts and reencrypts\nmessages, then this has a pretty negative impact on security (<a href=\"#critiques\">critique 1</a>).\nHowever, it's also possible to have interoperable end-to-end encryption;\nI would also argue that with sufficient care it's even possible to design\nan identity infrastructure that doesn't badly weaken the system as\na whole. However, that isn't to say that there are no security\nimplications of requiring interoperability.</p>\n<p>First, even if you have a common protocol, there may be differences\nin application semantics. For example, when WhatsApp detects\nthat a recipient has changed their keys and so a message is\nundecryptable, it <a href=\"https://www.schneier.com/blog/archives/2017/01/whatsapp_securi.html\">automatically re-sends the message</a>.\nThis is a usability feature but is a difference from Signal, which\ndoes not automatically re-send—even though they use the same protocol as WhatsApp—because Signal is concerned that the new key might be compromised. This is an application\nbehavior and it's of course\nharder to frame the security guarantees of a system where there\nis more than kind of client; in this case, the security decision\nis made by the sender, but in other cases it might not be.</p>\n<p>One case where that's so is that messaging systems\nsupport \"disappearing messages\" which get automatically deleted\nafter a certain time. This is not a cryptographic feature but\nrather a client side feature and depends on the receiving client\ncomplying with the sender's request to delete the message. Obviously,\nif the remote client doesn't comply, then it's not going to work.\nI'm less sympathetic to this case because this kind of feature\nis mostly an example of hope-based security: even in a closed\nsystem you have <a href=\"/posts/verifying-software\">no way of knowing what software is running on the\nreceiver's computer</a>; it could have been\nhacked or they could have reverse-engineered non-compliant\nsystem (the virtue of standards is that they allow for\ninteroperability without reverse engineering).\nEven if that's not the case, nothing stops them from\ntaking a photo of the screen, or, depending on the system,\na screenshot. This seems like a case where the recipient can\nadvertise its capabilities and you just have to trust them.</p>\n<p>There might also be new security features that would not\nend up in whatever new standardized protocol was settled on,\nsuch as metadata protection or post-quantum security. This isn't\nideal, of course, but standardized protocols do evolve, and it's\npossible for messaging services to use private protocol extensions\nfor groups that just consist of their users on new clients, so\nthis doesn't seem like a fatal objection.</p>\n<p>Probably the most serious problem is spam and abuse (<a href=\"#critiques\">critique 3</a>). As I\nmentioned earlier, this is a much easier problem if you\nhave relationships with all the users and don't need to\naccept messages from arbitrary counterparties. End-to-end\nencryption also presents a problem here because it means\nyou can't do content filtering centrally. I'm not sure how serious\nthis would actually be in practice: a lot of what makes\nemail spam work is that you have to accept email from\nnon-contacts, which is somewhat less of an issue in\nmessaging systems, but this still seems like a\nproblem that needs more work.</p>\n<h2 id=\"critique-recap\">Critique Recap <a href=\"#critique-recap\">#</a></h2>\n<p>It's probably useful to recap the critiques from the <a href=\"#critiques\">beginning</a> of\nthis post. I don't think they are entirely without merit, but I also believe\nthat interoperability would have real benefits that need to be weighed\nagainst these concerns.</p>\n<h4 id=\"interoperability-will-weaken-security\">Interoperability will weaken security <a href=\"#interoperability-will-weaken-security\">#</a></h4>\n<p>It's certainly true that there are ways to implement interoperability\nwhich would have a very negative impact on security. However, as I\nargue above, I think it's also possible to implement interoperability\nin ways which would minimize those impacts, in particularly by maintaining\nend-to-end encryption across system boundaries. Clearly, the resulting\nsystem would be more complex, which is bad for security, but having\na common system would provide a single target for analysis and improvement,\nwhich is good.</p>\n<p>It's also important to look at the non-technical picture here: right now users\nlargely choose their messaging systems based on who they want to talk to\nand get whatever security properties those systems have. Interoperability\nwould allow people to choose systems based on security properties—for\ninstance that they have <a href=\"https://github.com/google/keytransparency/\">key transparency</a>\nand <a href=\"https://reproducible-builds.org/\">reproducible builds</a>—while\nstill talking to people who have made other choices. Of course, those\nmixed conversations tend to have the security properties of the weaker\nsystem, but at least it would be easy to also talk to people who had\nmade stronger choices. In addition, we see many cases today where people use\nback to unencrypted channels in order to interoperate (e.g., iMessage falling back to SMS),\nwhich would be improved by end-to-end interoperability.</p>\n<h4 id=\"interoperability-will-hold-back-innovation\">Interoperability will hold back innovation <a href=\"#interoperability-will-hold-back-innovation\">#</a></h4>\n<p>Here too, the situation is complicated. On the one hand, it's clearly true that\nmessaging services would be less free to innovate than if they were totally\nvertically integrated (although they would still retain substantial freedom).\nOn the other hand, there would be more room for innovation on the clients\nthemselves, something which is currently very difficult. It's worth noting\nthat the Web is one giant mostly interoperable system which is still\nexperiencing plenty of innovation, so I don't think it's a foregone\nconclusion that interoperable systems can't innovate; you just need\nmechanisms to manage compatibility and change.</p>\n<h4 id=\"interoperability-will-make-abuse-worse\">Interoperability will make abuse worse <a href=\"#interoperability-will-make-abuse-worse\">#</a></h4>\n<p>It does seem likely that interoperability will make abuse worse: if you\nhave to accept messages from basically anyone then reputation and\nsimilar systems become harder, and e-mail abuse (especially spam) is\na serious problem. However, we already see abuse even in monolithic systems,\nso it's also clear that being closed isn't a panacea.\nMoreover, messaging is fundamentally different from e-mail in a number\nof important ways (we'll have authentication from the start, which\nwas a huge problem in e-mail, there is much less expectation that you'll\njust accept messages from anyone, etc.) so it's not clear how much\nworse interoperability will make things.</p>\n<h2 id=\"final-thoughts\">Final Thoughts <a href=\"#final-thoughts\">#</a></h2>\n<p>As the extremely long writeup above should indicate, this is far\nfrom an easy problem. We have a giant installed base of software\nthat doesn't interoperate and changing that would be difficult\neven if the big players wanted to. Famously, Facebook\nhas been <a href=\"https://screenrant.com/whatsapp-cross-chat-facebook-messenger-instagram-optional-interoperability/\">trying to get Messenger and WhatsApp to interoperate\nin an end-to-end secure fashion for years</a>,\nand it seems likely that they're going to be a lot less excited about\ninteroperating with others. However, that's separate question\nfrom whether it's actually technically possible to do, which,\nas the analysis above suggests, I think it is.\nWith that said, this is also a much harder problem than\nthe EU guidelines seem to contemplate: for instance,\nthey require that basic 1-1 messaging be\navailable within three months, and group messaging within\ntwo years. Given that the MLS standardization process\nis just about complete after <a href=\"https://datatracker.ietf.org/wg/mls/history/\">four years</a>,\ntwo years seems pretty aggressive, and three months seems\nfairly implausible.</p>\n<hr>\n<section>\n<ol>\n<li id=\"fn1\"><p>\nNote that email frequently has <em>transport</em> encryption where\nmessages are encrypted between users and mail servers\nand between mail servers, but they are generally in the\nclear on the mail server. <a href=\"#fnref1\">↩︎</a></p>\n</li>\n<li id=\"fn2\"><p>What it looks up is\n<a href=\"https://en.wikipedia.org/w/index.php?title=MX_record&amp;oldid=1037761196\">mail exchanger (MX) record</a>. <a href=\"#fnref2\">↩︎</a></p>\n</li>\n<li id=\"fn3\"><p>\nAnd Alice doesn't even need to know that much. For instance,\nif Gmail suddenly decided to support domains\n<a href=\"/posts/dns-security-blockchain/\">rooted in the blockchain</a>,\nthis would just work transparently for Alice, because\nonly Gmail needs to know which server handles <code>example.eth</code>. <a href=\"#fnref3\">↩︎</a></p>\n</li>\n<li id=\"fn4\"><p>\nOf course, users don't always upgrade instantaneously, so it's\npossible to have some heterogeneity, but it's typically fairly\nshort term, especially because the service provider can\nforce you to update to continue using the service. <a href=\"#fnref4\">↩︎</a></p>\n</li>\n<li id=\"fn5\"><p>\nNote: The difference between\n\"APIs\" and \"protocols\" is largely a matter of terminology:\nprotocols are just the rules for what go over the network,\nbut things that run over HTTP are often called \"APIs\". <a href=\"#fnref5\">↩︎</a></p>\n</li>\n<li id=\"fn6\"><p>\nIn many protocols, that pairwise key is itself changed\n(\"ratcheted\") frequently. <a href=\"#fnref6\">↩︎</a></p>\n</li>\n<li id=\"fn7\"><p>\nAs an aside, am I just the only person who thinks that\nthe proliferation of these non-hierarchical namespaces\nis a huge regression? I'd much rather be <code>ekr@rtfm.com</code>\neverywhere than <code>ekr</code> on Github and <code>ekr____</code> on\nTwitter. <a href=\"#fnref7\">↩︎</a></p>\n</li>\n<li id=\"fn8\"><p>There\nare also questions about key transparency and the like,\nbut they're largely downstream of these bigger architectural\nquestions. <a href=\"#fnref8\">↩︎</a></p>\n</li>\n<li id=\"fn9\"><p>\nGoogle chat used to offer an XMPP interface but no longer does. <a href=\"#fnref9\">↩︎</a></p>\n</li>\n</ol>\n</section>\n\n    </article>\n\n    \n      \n  </div>\n\n<!-- Cloudflare Web Analytics --><!-- End Cloudflare Web Analytics -->\n\n\n          </main>\n        </div></div>","textContent":"\n          \n            \n\n    \n        \n        \n\n        The news the the EU\nwill require that messaging companies provide\ninteroperability\nhas gotten a lot of attention, both positive\n(matrix.org)\nand negative (Alex\nStamos,\nAlec Muffett, Steve\nBellovin),\nas detailed in this\nWired\narticle (see also this ISOC\nwhite paper). At a high level,\nI'm more positive on the idea of interoperability for messaging systems\nthan some others are, but it's certainly not a trivial problem and\nat least some of the EU timelines seem pretty unreasonable. Read on\nfor more.\nCritiques #\nAt a high level, there seem to be three broad critiques of messaging system\ninteroperability:\n\nIt will weaken security, for instance by requiring decryption\nand re-encryption at system boundaries or by creating\nconfusion about user identities.\nIt will hold back innovation by forcing messages to be\nsent using only features that are common to all systems.\nIt will make abuse (especially spam) worse.\n\nIt's useful to keep these in mind throughout the rest of the discussion.\nBefore covering messaging, however, it's helpful look at an existing\nsystem that has had interoperability for a long, where we can see the\nresulting dynamics: e-mail.\nAn Interoperable System: E-mail #\nE-mail has the\nopposite problem from messaging: where messaging consists of a number\nof independent islands of encrypted messaging with no way to talk\nbetween them, email is a globally interoperable system that—despite\na number of attempts—doesn't have anything like universal encryption.[1]\nE-mail operates on a hub-and-spoke model in which every user is\nassociated with a given mail domain, represented by a domain\nname (e.g., example.com) as shown below:\n\n\nTelephone Addressing #\nTelephone numbers actually are hierarchically structured but don't map 1-1 with providers.\nThe basic structure of a phone number is given by the E.164 standard and consists of a country code followed by a subscriber number,\nwith the structure of the subscriber number being defined by the country\ncode. For instance, in the North American Numbering Plan, identified by country code 1, numbers\nlook like: 415.555.1111.\n\n\n\nDescription\nDigits\nExample\n\n\n\n\nNumbering plan area (aka area code)\n3\n415\n\n\nCentral office prefix\n3\n555\n\n\nLine number, denoting subscriber\n4\n1111\n\n\n\nI don't know too much about the non-North American setting, so the remainder of\nthis aside is about North America.\nUntil 1984, North American telephony was basically monopolized by\nthe Bell System. In\nthat system, the number hierarchy was geographic, with the area codes\nand central office prefixes corresponding to geographic regions and\nspecific switches and the line number corresponding to lines on a given\nswitch. However, with the advent of local number competition following\nthe breakup of the Bell System and then mobile telephony, things started\nto get more complicated.\nInitially, central offices were controlled by a single carrier and\nso the phone number could be used straightforwardly for routing.\nHowever, subsequently the US required carriers\nto provide Local Number Portability, which allowed you to take your number from carrier to carrier.\nThus, even if you were originally assigned a number out of Verizon's\nblock, you could \"port\" it to T-Mobile, which means that this kind of hierarchical\nrouting no longer works. Instead, there's basically a giant—well,\nnot so giant, given that there are only 10 billion possible numbers—database\nthat indicates which carrier has responsibility for each number.\n\nE-mail addresses are hierarchically assigned, which means that if your\nmail service is example.com, then your address will end in\n@example.com, as in alice@example.com.\nIt's helpful to work through an example here. For instance, here is\nwhat happens when Alice (alice@hotmail.com) wants to send a message to Bob (bob@gmail.com):\n\n\nFirst, she transmits the message to her mail server\nover a protocol called the Simple Mail Transfer Protocol (SMTP),\nalong with the addressing information for bob@gmail.com.\n\n\nThe sending mail server looks up the receiving\ndomain name—in this case gmail.com—in the DNS\nto get the server associated with it.[2] It then connects to that server—again over\nSMTP—and transfers the message, along with the\naddressing information bob@gmail.com.\n\n\nAssuming that bob@gmail.com is actually a valid user on\nthe receiving server, that server stores the message somewhere\n(on disk, in a database, whatever) and waits for Bob to\ncome pick it up.\n\n\nFinally, Bob connects to his mail server (historically over\na protocol called Internet Message Access Protocol (IMAP))\nand retrieves any new messages.\n\n\nThis structure has a number of important properties:\nAddresses #\nBecause addresses are scoped by the mail domain they are\nassociated with, it's possible to immediately know where\na given message should be delivered just by looking at the\nright-hand side (RHS) of the address, namely the stuff\nafter the @-sign. That tells you which domain an\naddress is associated with. This is in contrast to addresses\non most popular services (e.g., Twitter), which are unqualified:\nif all I have is the identifier ekr____ I don't know if\nthat corresponds to Twitter, Github, or LinkedIn..[3]\nConversely, the fact that names are hierarchical means that\ntwo people can have the same left-hand side (LHS) as long as the RHS is\ndifferent (and vice versa). So, bob@gmail.com and bob@hotmail.com\nare totally distinct addresses and quite likely belong to different\npeople. This is of course true with Twitter handles and the\nlike, but because they are unqualified, the bare address\nisn't enough to tell you who is who. This becomes a real issue\nwhen you want to import identities from another namespace,\nfor example, when your address for messaging is actually your\ntelephone number.\nFinally, it means that the semantics of the LHS\nare opaque to the other end. For instance, if you had your\nown mail domain (for instance your-lastname.name) you\nmight have every address that ends in @your-lastname.name\ndelivered into the same mailbox. Another example is that\nGmail allows you to create new addresses by adding a plus sign\nto the end of your actual address, so example@gmail.com\nand example+newsletter@example.com go to the same place.\nThis is a useful trick to let you sort your email by giving\ndifferent addresses to each sender.\n\nHosted Domains #\nAlthough mail is scoped by domain, as a practical matter\nmany domains are actually hosted by the same service.\nFor instance, Gmail allows you to host your \"custom domain\"\non Gmail (that is how rtfm.com works), but your\naddress can still have your domain in it rather than\ngmail.com. It's also possible to have your mail\ndelivered to service A and have most of your accounts\nthere but send mail from service B. This is useful if you\nwant to send bulk email using a service like Mailgun.\n\nInteroperability #\nBecause SMTP and IMAP are standardized, any mail endpoint\ncan talk to any other mail endpoint. If you own example.com\nand want to send and receive mail there, all you have to do\nis stand up a server—or more likely, use an existing\nhosting server—set up the right DNS records, and\nyou're good to go. Similarly, most mail services will provide IMAP\nservice and so you can use any number of clients\n(the built in mail client on your Mac, Thunderbird, etc.) to\nread your mail.\nConversely, nothing says that a mail system has\nto have a separate client at all. For instance, instead\nof having people use IMAP to read their email you can just\nput up a Web front end that accesses it directly and, tada,\nyou have Gmail. Or, as is common, you can both have a Web interface\nand an IMAP interface. As long as you properly speak SMTP, everything\nwill work fine and the other end doesn't even need to know how\nyou have everything set up; it's just a matter of having the\nright protocol interfaces. In particular, it doesn't matter to\nthe receiver how the sender talks to their mail server\nand it doesn't matter to the sender how the receiver\ntalks to their mail server. All that's required is that\nthe servers speak SMTP to each other.\nThis is in contrast to most messaging systems, which are basically\nsilos that don't interoperate with each other.\nExtensibility #\nThe cost of interoperable protocols is a limited range of\nformat extensibility. The format of the emails is standardized using a\nformat called\nMIME,\nand if you send a compliant MIME message the receiver should be able\nto process it, at least to figure out what the type of\nthe message is.\nIdentifying the type of the message is only the first\nstep. Suppose that you want to introduce a new\nmail feature, say memoji\nin emails. Even if you write a new standard for it and Alice\nadds it to her email client, what happens if Bob hasn't upgraded?\nIdeally, the client would get some clear message that something\nwas wrong, and yet would still see the part that was\ninterpretable, but this doesn't always work.\nDepending on exactly how the new feature is designed, it either\nmight not work properly—for instance, the memoji might\nbe replaced with  some unknown character like �—\n(for a long time, emails from Outlook would render\nthe :) emoji to \"J\" on non-outlook systems)\nor the message might just not be readable at all (though hopefully\nyou wouldn't design a feature like that).\nAt the end of the day, this kind of mismatch can create\na pretty degraded experience and change the meaning of the message.\nThe converse of this property however, is that\nemail processing is highly extensible. Because mail formats\nare open and standardized, any client that speaks the\nprotocol will work. I gave the example of Webmail before,\nbut this also means that if you want to\nuse a mail client which offers some new feature—automatic\nemail summarization say—that's your business.\nBy contrast, most messaging systems are closed and so\nyou're limited to the features supported by the official\nclient.\nSecurity? #\nLike many things on the Internet, the e-mail system was designed\nbefore modern encryption and so initially everything was in\nthe clear. This allowed for a broad range of attacks:\n\n\nAnyone on the connection between you and the mail server\nor between mail servers could read or modify your messages.\n\n\nSenders weren't authenticated and so it was trivial to\nforge messages that appeared to come from someone else.\n\n\nIf your mail server was compromised, then it could read\nyour messages in transit or change them.\n\n\nSome of these issues have been gradually sort-of addressed\nwith partial solutions such as TLS encrypting the traffic\nbetween you and the mail server, TLS encrypting\nthe traffic between the mail servers, and server-based\nsigning mechanisms like DKIM. However, they're incompletely\napplied (for instance, the client-server connection\nis generally strongly authenticated but the server-server\nconnection often is not) and still don't provide any protection\nagainst a malicious or compromised mail server. For that\nyou need end-to-end encryption (E2EE), in which the\nmessages are encrypted (and authenticated) between the\nsending and receiving endpoints.\nThere have been quite a few attempts to provide end-to-end encryption\nfor e-mail (PGP, S/MIME, etc.) but I think it's fair to describe them\nas having largely failed. This isn't to say that there isn't any encrypted\nmail but it's a fairly small fraction of overall traffic. The\nreasons for the failure of encrypted email are complicated, but\nthere were a number of deployment problems that most likely\ncontributed.\nKey Management #\nLike any cryptographic system, encrypted email depends on\nknowing the cryptographic keys of the people you are talking to.\nIn e-mail, you use keys in two ways:\n\nYou sign your messages in order to authenticate them\nPeople who want to send you secure messages need to encrypt them to your\nkey.\n\nIt's technically possible to just start sending people messages with\nunauthenticated\nkeys, for instance by signing all of your messages and expecting\npeople to remember that this is your key (this is often called trust\non first use\n(TOFU)).\nOnce they have received a message from you, they can use your key to\nencrypt the return message. Obviously, TOFU is susceptible\nto attack if the that attacker is the first person to send you\na message pretending to be someone else, which makes the system\nless than ideal, especially for interactions with people you don't\ntalk to frequently.  If my bank sends me a signed message, then I want\nto know it's my bank right away. It's also a problem if you want to\nsend an encrypted message to someone you have never talked to\nbefore. What you really want is some system that lets you find out\nwhat people's keys are, which means solving two problems:\n\n\nYou need to somehow associate your key(s) with\nyour email address.\n\n\nYou need some way to look up people's keys so that\nyou can send them encrypted messages.\n\n\nDeploying the infrastructure for both of these has proven to be\nquite challenging. The basic problem is that there was\nnever a good way to automatically issue the credentials.\nThis meant that people had to go to a lot of effort to\nget credentials, which of course meant that most\npeople didn't get them. On the other side of the equation,\nthere was never really a great way to discover\npeople's credentials, which meant that you couldn't\nsend encrypted email to new people. It's in principle\npossible to build mechanisms for this (ACME\nand WebFinger\nrespectively are examples of the kind of thing I'm talking\nabout), but we have the usual deployment\nnetwork effect problems.\nConfusing Semantics #\nIn addition to the keying problems, the fact that email encryption was\nadded after the fact to an established system has resulted in some\nconfusing semantics.\nFor example, the major extension point in e-mail is via the message\nbody. As noted above, the bodies use an extensible message format\ncalled MIME. However the message subject line isn't extensible.\nThis means that the subject line that appears in\nthe email isn't either encrypted or authenticated. It's of course\npossible to have an inner subject line inside the encryption envelope,\nbut it's an obvious challenge for users to understand that they can\ntrust the body but not the subject.\nSecond, because some messages are protected and some are not,\nyou need some way to indicate to the user which are which.\nThis kind of indicator is a notorious source of confusion,\nespecially in a situation where most messages are\nunprotected, because you don't want a big scary warning for\nnearly every message. But this also reduces the incentive for people\nto use secure e-mail, especially to send signed\ne-mail: if recipients don't notice or care whether\nmessages are signed, then signing them doesn't add\na lot of value, as an attacker can just impersonate you\nwith the recipient being none the wiser.\nNetwork Effects #\nAll of this should be a familiar story to EG readers: you\nhave a situation where it's inconvenient for people to do\nsomething—in this case, deploy encryption—and\nthere's not much benefit to doing it. In these cases, you get the expected result which is\nlimited or minimal deployment. By contrast, most modern messaging systems\nwere either built with E2EE from the start or underwent\nsome mass upgrade that enabled it for everyone, rather\nthan relying on people to do it themselves.\nMessaging Systems #\nModern messaging systems have addressed these issues by making\nencryption both mandatory and automatic. This is comparatively\neasy because the messaging service is (usually) vertically integrated:\nall—or nearly all—users have clients which are provided\nby the service operator and can be updated as desired. The\nservice operator also provides message routing and identity.\nThis kind of uniform integrated system has a number of operational\nadvantages:\n\n\nThe service can automatically issue credentials based on the\nuser's account information, thus ensuring that every user\nhas a credential. They can also run a directory which makes\nit easy for any client to learn the credentials for every\nother client.\n\n\nWhen the service wants to add a new feature it can automatically\nupgrade everyone's client to support it. This means that they\ndon't need to deal with massive heterogeneity of client functionality\nfor very long, and can eventually just refuse to support older\nclients.[4]\n\n\nSpam and other kinds of abuse are easier to handle because\nall messages are authenticated by a user in the system. Of\ncourse, if you have a single central point where all\nmessages are handled, and no end-to-end encryption, then content\nfiltering is more difficult.\n\n\nOf course, many of these advantages depend on having a closed system:\nif a significant fraction of people use third party clients to talk to\nsuch a system then you can no longer update the clients whenever\nyou want to, which makes central extensibility much more difficult.\nIn other words, you're trading off user control and extensibility for users\nfor control and extensibility by the system operator. This is in\nstark contrast to the design of the Web, which is dominated by\nthe principle of end-user control as documented in\nthe HTML Priority of Constituencies\nand the Mozilla Web Vision.\nAnother consequence of a closed system is a lack of universal connectivity:\nwith e-mail—or telephony—you can contact anyone no matter\nwhich service provider they are on. In fact, you don't even have to\nthink about it: you just e-mail (or dial). Messaging, however, is different:\nif I want to send a message to someone on WhatsApp, I need to have\na WhatsApp account myself. And because people choose different messaging\nsystems, this means that it's now common to have accounts on a variety\nof messaging systems (I myself use three regular messaging systems, plus\ncountless Slacks).\nAll of this creates a set of market dynamics dominated by network\neffects\n(Metcalfe's Law)\nand getting big: if you have a lot of users, then people have\na strong incentive to join so they can talk to their friends. Conversely,\nif you are a new entrant into the market it is hard to break in\nbecause your early users don't have that many people to talk to.\nThis is probably why we see a lot of regional variation in which\napps are popular, because people want to use whatever app their\nfriends use. Unsurprisingly, this produces some fairly lopsided\nmarket numbers, with Meta controlling two of the top three\nmessaging platforms (WhatsApp and Facebook Messenger):\n\nThis brings us to the topic of interoperability: if it were possible\nfor anyone to start a new messenger app that could still talk to\nWhatsApp and Messenger users, then this would remove a big barrier\nto entry into the market. I don't want to sound too optimistic here:\neven in a nominally open system like e-mail, we still see a huge\namount of market concentration\non the big mail systems like Gmail, Outlook, and Yahoo. This isn't\ntoo surprising: it's a lot of work to run a good mail system\nand so we'd expect well-funded players to dominate. However,\nit's also quite possible to use one of the smaller services\nlike Fastmail, ProtonMail,\nor DreamHost or even run your own server,\nwhereas there's really no way to run your own WhatsApp server.\nTechnical Interoperability for Messenging #\nThe details of what the DMA will actually require are extraordinarily\nsketchy; as I understand it they would need to be filled out\nby some regulatory agency. However, broadly speaking, there seem to be two options for providing\ninteroperability, as laid out by ISOC:\n\nRequire services to offer stable APIs.\nRequire services to actually interoperate over a standardized\nprotocol.\n\nThese require a bit of unpacking.\nStable APIs #\nThe idea behind a stable API is that the service would design and publish interfaces\nthat others could use. There are actually two ways to offer stable APIs:\n\n\nTo clients, allowing someone else's messenger\nclient to work with your service.\n\n\nTo services, allowing someone else's messenger service to gateway\nmessages in and out of your service.\n\n\nThe first of this is actually a familiar concept in instant\nmessaging: because there was never a single standardized protocol,\nit was fairly common to have messaging clients, such as\nTrillian,\nwhich would speak multiple protocols but provide a unified interface\nto the user that hid the details. This isn't really a conceptual\nchange in the architecture of the system as it would still be\na monolithic identifier space and the clients would still have\nto conform to whatever rules the service laid out; indeed, some\nservices have open source clients, and so this is already possible\nfor them, though of course third party clients might not\nget upgraded when the official clients do, potentially\nresulting in stability problems.\nThe main result would be some decreased flexibility\nfor the service because they would need to get users of the API\nto update when they wanted to change something that affected\ninteroperability. However, as a practical matter, this probably\nwouldn't have that much of an impact on interoperability\nand market concentration because most people will just use the\nofficial client, and people who don't will be annoyed when\nthe service changes something and breaks them.\nThe second version is less familiar, but the idea is presumably that\nWhatsApp would have some published API that would allow\nekrMessage (TM pending!) to gateway messages into and out of\nWhatsApp. As with e-mail, each side would handle messages\naccording to its own rules, with the gateway just\ntransiting messages between the systems.\nThis comes with two main problems:\n\n\nHow do you handle identities? For instance, if ekrMessage\nand WhatsApp both use phone numbers for identities, how\ndo you know which messages stay on WhatsApp and which go\nto ekrMessage?\n\n\nHow do you manage different encryption protocols? Currently,\neach messenger has their own encryption protocol; while many\nof these are built along similar lines, they're not necessarily\nidentical. Making this work either requires gatewaying at\nthe provider—thus breaking end-to-end encryption, which\nis extremely undesirable from a security perspective—or\nhaving each client speak multiple encryption protocols,\nas in the multi-protocol client case.\n\n\nOf course, this would all be a lot easier if there was some\nstandardized protocol that everyone spoke, as with e-mail.\nNote: the difference between a stable API and a standardized protocol isn't\nreally technical so much as social and depends on whether there\nis some standard or just a document published by the service.[5]\nStandardized Protocol #\nHaving a standardized protocol is not an\nall-or-nothing proposition: there are actually a number of levels at which one might\nhave standardization, with the other levels potentially not\nbeing standardized:\n\nKey establishment and message encryption\nUse identity\nMessage transport\nMessage contents and features\n\nI go into these in some more detail below.\nKey Establishment and Message Encryption #\nThe basic structure of most messaging encryption systems is that\nyou have an identity (e.g., your phone number) which is tied\nto a cryptographic key or keys. When Alice and Bob want to exchange messages,\nthere is some protocol that lets them use their keys to establish a pairwise\n(or groupwise in the case of more than two people) cryptographic\nkey which they then use to encrypt messages.[6]\nObviously, if Alice and Bob don't speak the same protocol,\nthen they will not be able to establish pairwise keys and will\nnot be able to encrypt messages end-to-end, so this is probably\nthe most important place for everyone to use a common protocol.\nFortunately, while there are technical differences between the various\nprotocols in use, they're similar enough that it would\nprobably not be prohibitive for everyone to converge on\na common protocol: a number of the existing messenging\nsystems are based on the Signal protocol\nor one of its variants such such as Proteus\nor Megolm,\nand the IETF is currently in the final stages of standardizing\na protocol called Messaging Layer Security (MLS) which contains a number of similar concepts but is\nintended to be more optimized for group communication. It's too\nsoon to know how much adoption MLS will get, but the WG has\nhad participation from a number of messenging services such as\nFacebook Messenger, Matrix, Wickr, and Wire (full disclosure: I\nhave also been heavily involved in this effort). It would be a big\nlift for companies to change out their protocols, but, because\nright now they're noninteroperable silos, it's still\ntechnically feasible.\nIdentity #\nAs I said above, we need to have some notion of user identity. Identity\nis used for two purposes:\n\n\nBy the end-user clients (in an end-to-end system) to\nestablish the keys to use to encrypt a message.\n\n\nBy the service to know how to route messages.\n\n\nBoth of these require identifying other people you want\nto exchange messages with.\n\niMessage #\niMessage is actually quite an interesting case because the\nApple client is actually two clients in one, containing\nboth an SMS client for talking to non-Apple users (the\ngreen bubble) and\nan iMessage client for talking to Apple users (the blue\nbubble). iMessages are sent over the Internet (\"over the top\") and are\nend-to-end encrypted. SMS messages are sent over the\nphone network and are not. However, both categories\nof users have the same type of addresses in the form\nof phone numbers iMessage (which also supports\nemail addresses) and Apple automatically detects the\ncapabilities of the message recipient and sends a message\nof the appropriate type.\niMessage might be one of the strongest cases for the benefits\nof interoperability because it already interoperates\nwith Android devices, just in the clear over SMS. If iMessage\nwas forced to interoperate and Android played along, then\na large fraction of traffic would suddenly be encrypted.\n\nAt a high level, there are two main identity architectures we can have:\n\n\nHierarchical naming in which a given identity indicates\nwhich service it is attached to, as in e-mail.\n\n\nA shared namespace in which a given identity could be\nattached to any service (like phone numbers).\n\n\nWith messaging, the situation is even more complicated because\nmultiple messaging services use the same identifier (e.g.,\nWhatsApp and iMessage both use phone numbers) so that means\nthat even in an interoperable system, we'd need to find some way\nto manage that case, which seems like a real open question\n(though of course we already have that problem now when you\ntell someone \"I'm 1.415.555.1111 on WhatsApp\", so in the\nworst case scenario, we could just punt the problem to the user.)\nWe also have the potential problem that alice on\nsystem A may be a different person from alice on system B;\nthis shouldn't happen with phone numbers because they are uniquely\nassigned but it happens all the time with user-chosen handles.\nThe hierarchical design is obviously easier to manage, but it\nmay be quite hard to retrofit to the existing non-hierarchical\nsystem.[7]\nOne possible approach is to have a hierarchical system under\nthe hood but have UIs present unqualified namespaces,\ne.g., \"Connect with 1.415.555.1111 on WhatsApp\" in the UI\nturns into \"Connect with 1.415.555.1111@whatsapp.com at\nthe protocol layer.\"\nThis is likely to work OK if there are a small number of\nmessaging systems but less well if there are hundreds\nbecause the UI gets too cluttered. It's also possible to have a kind\nof hybrid UI like existing e-mail systems do for there\naccounts where you have a chooser for the common systems\nand then people can enter something freeform:\n\nThis brings us to the question of how users learn other\nusers keying material.\nIn a fully distributed/federated world like e-mail, you'd need\nsome sort of analog to the WebPKI in which there was a set of\nagreed up on roots of trust and those roots then somehow were\nable to attest to identities in a uniform manner, no matter\nwhich messaging service people used. This in contrast to the\ncurrent situation where each service runs its own disconnected\nidentity service. If there\nis a totally shared namespace, then this has a lot of the same\nproblems as the WebPKI in which anyone can attest to any name,\nbut if the names are arranged hierarchically—even if\nthat's not visible to the user—then we could potentially\ndodge some of those problems, as only WhatsApp would be able\nto attest to names for @whatsapp.com, etc.[8]\nIt's also possible that one could do something less universal:\nif there are only a modest number of messaging services, and you\nhave to make special arrangements to federate between services,\nthen each service could continue to maintain its own identity\nsystem and just publish documentation about how it\nworks, forcing the other systems could implement\nthat. The likely outcome here would be that the big gatekeeper\nsystems would each have something and if you wanted to talk\nto them, you would need to both consume and publish that, which\nis a burden on the smaller systems, but perhaps a bearable one\n(the tricky part is when Alice has accounts on WhatsApp and iMessage\nand wants to talk to someone on ekrMessage: which credentials\ndoes she use for the ekrMessage user?).\nMessage Transport #\nOnce we have established keys and are sending messages, we still need some\nway to transport them. There have been attempts to design standardized\nprotocols for this, in particular XMPP\nand SIMPLE (which is not),\nbut neither has seen the kind of adoption that would make it the\nobvious choice here.[9]\nAs with identity, while it would be convenient to offer something standardized,\nit's probably not a dealbreaker not to have it, as long as services\nare required to offer interoperable APIs for message sending\nand delivery. The good news here is that unlike the cryptographic\npieces, those APIs can largely be handled by the messaging\nservice, rather than the client, so my ekrMessage client just\nneeds to know that a given message is destined for someone on\nWhatsApp and it can route it there.\nMessage Contents and Features #\nAll of the above is just concerned with getting messages from point\nA to point B, but what people actually care about is the messages\nthemselves. In order for messaging to work properly, when the\nmessages finally get to the recipient, they need to be readable,\nwhich won't work if (say) system A uses ASCII messages\nand system B encodes them as images. Moreover, if system B\nwants to add some new feature, it's a problem if system\nA doesn't have it (critique 2).\nAs noted above, this is a sort-of solved problem in e-mail\nin that you can send MIME-encoded messages that describe their\ncontents. But of course, describing the contents doesn't\nhelp if someone sends me a message of type image/avif\nand I don't know how to parse that. The conventional solution\nhere is to have\nsome common format that it's assumed that everyone can read\n(in e-mail this is 7-bit ASCII text). The sender then sends\ntwo copies of the content bundled in the same message: (1) the \"basic\"\nversion that everyone should be able to read and (2) the \"enhanced\"\nversion that only newer clients can read.\nThis is a workable, if not ideal, solution, but actually it's\nprobably possible to do quite a bit better. The reason is that\nunlike e-mail, where you send messages to people based\nsolely on their address, in order to send someone an encrypted\nmessage you need their key. When people publish their keys then\ncan also publish other capabilities such as the various media\ntypes they understand, which gives senders some information about\nwhat messages are safe to send (Rohan Mahy has\ndescribed such a mechanism\nfor MLS.)\nUnfortunately, it's still possible to get into trouble with\nlarger groups with mixed capabilities, where you probably\nend up having to send a lowest common denominator version.\nThis isn't ideal for ordinary features, but is potentially\nmore problematic for security features, as discussed below.\nAs should be clear from the discussion above, any form of\ninteroperability places some limits on the freedom of each service to\nchange their offerings whenever they want. Some of these\ncosts—like using a standardized encryption protocol—are\nrelatively modest, but others may be larger. It's certainly a lot more\nwork to detect the capabilities of every client and carefully craft\nmessages which will work for all of them than it is to just generate\nmessages for one client type which you know works.\nSecurity Implications of Interoperability #\nAs discussed above, if connecting service A and\nservice B requires some kind of bridge that decrypts and reencrypts\nmessages, then this has a pretty negative impact on security (critique 1).\nHowever, it's also possible to have interoperable end-to-end encryption;\nI would also argue that with sufficient care it's even possible to design\nan identity infrastructure that doesn't badly weaken the system as\na whole. However, that isn't to say that there are no security\nimplications of requiring interoperability.\nFirst, even if you have a common protocol, there may be differences\nin application semantics. For example, when WhatsApp detects\nthat a recipient has changed their keys and so a message is\nundecryptable, it automatically re-sends the message.\nThis is a usability feature but is a difference from Signal, which\ndoes not automatically re-send—even though they use the same protocol as WhatsApp—because Signal is concerned that the new key might be compromised. This is an application\nbehavior and it's of course\nharder to frame the security guarantees of a system where there\nis more than kind of client; in this case, the security decision\nis made by the sender, but in other cases it might not be.\nOne case where that's so is that messaging systems\nsupport \"disappearing messages\" which get automatically deleted\nafter a certain time. This is not a cryptographic feature but\nrather a client side feature and depends on the receiving client\ncomplying with the sender's request to delete the message. Obviously,\nif the remote client doesn't comply, then it's not going to work.\nI'm less sympathetic to this case because this kind of feature\nis mostly an example of hope-based security: even in a closed\nsystem you have no way of knowing what software is running on the\nreceiver's computer; it could have been\nhacked or they could have reverse-engineered non-compliant\nsystem (the virtue of standards is that they allow for\ninteroperability without reverse engineering).\nEven if that's not the case, nothing stops them from\ntaking a photo of the screen, or, depending on the system,\na screenshot. This seems like a case where the recipient can\nadvertise its capabilities and you just have to trust them.\nThere might also be new security features that would not\nend up in whatever new standardized protocol was settled on,\nsuch as metadata protection or post-quantum security. This isn't\nideal, of course, but standardized protocols do evolve, and it's\npossible for messaging services to use private protocol extensions\nfor groups that just consist of their users on new clients, so\nthis doesn't seem like a fatal objection.\nProbably the most serious problem is spam and abuse (critique 3). As I\nmentioned earlier, this is a much easier problem if you\nhave relationships with all the users and don't need to\naccept messages from arbitrary counterparties. End-to-end\nencryption also presents a problem here because it means\nyou can't do content filtering centrally. I'm not sure how serious\nthis would actually be in practice: a lot of what makes\nemail spam work is that you have to accept email from\nnon-contacts, which is somewhat less of an issue in\nmessaging systems, but this still seems like a\nproblem that needs more work.\nCritique Recap #\nIt's probably useful to recap the critiques from the beginning of\nthis post. I don't think they are entirely without merit, but I also believe\nthat interoperability would have real benefits that need to be weighed\nagainst these concerns.\nInteroperability will weaken security #\nIt's certainly true that there are ways to implement interoperability\nwhich would have a very negative impact on security. However, as I\nargue above, I think it's also possible to implement interoperability\nin ways which would minimize those impacts, in particularly by maintaining\nend-to-end encryption across system boundaries. Clearly, the resulting\nsystem would be more complex, which is bad for security, but having\na common system would provide a single target for analysis and improvement,\nwhich is good.\nIt's also important to look at the non-technical picture here: right now users\nlargely choose their messaging systems based on who they want to talk to\nand get whatever security properties those systems have. Interoperability\nwould allow people to choose systems based on security properties—for\ninstance that they have key transparency\nand reproducible builds—while\nstill talking to people who have made other choices. Of course, those\nmixed conversations tend to have the security properties of the weaker\nsystem, but at least it would be easy to also talk to people who had\nmade stronger choices. In addition, we see many cases today where people use\nback to unencrypted channels in order to interoperate (e.g., iMessage falling back to SMS),\nwhich would be improved by end-to-end interoperability.\nInteroperability will hold back innovation #\nHere too, the situation is complicated. On the one hand, it's clearly true that\nmessaging services would be less free to innovate than if they were totally\nvertically integrated (although they would still retain substantial freedom).\nOn the other hand, there would be more room for innovation on the clients\nthemselves, something which is currently very difficult. It's worth noting\nthat the Web is one giant mostly interoperable system which is still\nexperiencing plenty of innovation, so I don't think it's a foregone\nconclusion that interoperable systems can't innovate; you just need\nmechanisms to manage compatibility and change.\nInteroperability will make abuse worse #\nIt does seem likely that interoperability will make abuse worse: if you\nhave to accept messages from basically anyone then reputation and\nsimilar systems become harder, and e-mail abuse (especially spam) is\na serious problem. However, we already see abuse even in monolithic systems,\nso it's also clear that being closed isn't a panacea.\nMoreover, messaging is fundamentally different from e-mail in a number\nof important ways (we'll have authentication from the start, which\nwas a huge problem in e-mail, there is much less expectation that you'll\njust accept messages from anyone, etc.) so it's not clear how much\nworse interoperability will make things.\nFinal Thoughts #\nAs the extremely long writeup above should indicate, this is far\nfrom an easy problem. We have a giant installed base of software\nthat doesn't interoperate and changing that would be difficult\neven if the big players wanted to. Famously, Facebook\nhas been trying to get Messenger and WhatsApp to interoperate\nin an end-to-end secure fashion for years,\nand it seems likely that they're going to be a lot less excited about\ninteroperating with others. However, that's separate question\nfrom whether it's actually technically possible to do, which,\nas the analysis above suggests, I think it is.\nWith that said, this is also a much harder problem than\nthe EU guidelines seem to contemplate: for instance,\nthey require that basic 1-1 messaging be\navailable within three months, and group messaging within\ntwo years. Given that the MLS standardization process\nis just about complete after four years,\ntwo years seems pretty aggressive, and three months seems\nfairly implausible.\n\n\n\n\nNote that email frequently has transport encryption where\nmessages are encrypted between users and mail servers\nand between mail servers, but they are generally in the\nclear on the mail server. ↩︎\n\nWhat it looks up is\nmail exchanger (MX) record. ↩︎\n\n\nAnd Alice doesn't even need to know that much. For instance,\nif Gmail suddenly decided to support domains\nrooted in the blockchain,\nthis would just work transparently for Alice, because\nonly Gmail needs to know which server handles example.eth. ↩︎\n\n\nOf course, users don't always upgrade instantaneously, so it's\npossible to have some heterogeneity, but it's typically fairly\nshort term, especially because the service provider can\nforce you to update to continue using the service. ↩︎\n\n\nNote: The difference between\n\"APIs\" and \"protocols\" is largely a matter of terminology:\nprotocols are just the rules for what go over the network,\nbut things that run over HTTP are often called \"APIs\". ↩︎\n\n\nIn many protocols, that pairwise key is itself changed\n(\"ratcheted\") frequently. ↩︎\n\n\nAs an aside, am I just the only person who thinks that\nthe proliferation of these non-hierarchical namespaces\nis a huge regression? I'd much rather be ekr@rtfm.com\neverywhere than ekr on Github and ekr____ on\nTwitter. ↩︎\n\nThere\nare also questions about key transparency and the like,\nbut they're largely downstream of these bigger architectural\nquestions. ↩︎\n\n\nGoogle chat used to offer an XMPP interface but no longer does. ↩︎\n\n\n\n\n    \n\n    \n      \n  \n\n\n\n\n          \n        ","length":41168,"excerpt":"The news the the EU\nwill require that messaging companies provide\ninteroperability\nhas gotten a lot of attention, both positive\n(matrix.org)\nand negative (Alex\nStamos,\nAlec Muffett, Steve\nBellovin),\nas detailed in this\nWired\narticle (see also this ISOC\nwhite paper). At a high level,\nI'm more positive on the idea of interoperability for messaging systems\nthan some others are, but it's certainly not a trivial problem and\nat least some of the EU timelines seem pretty unreasonable. Read on\nfor more.","byline":"Posted by ekr on 07 Apr 2022","dir":null,"siteName":null,"lang":"en"},"finalizedMeta":{"title":"End-to-End Encryption and Messaging Interoperability","description":"The news the the EU\nwill require that messaging companies provide\ninteroperability\nhas gotten a lot of attention, both positive\n(matrix.org)\nand negative (Alex\nStamos,\nAlec Muffett, Steve\nBellovin),\nas detailed in this\nWired\narticle (see also this ISOC\nwhite paper). At a high level,\nI'm more positive on the idea of interoperability for messaging systems\nthan some others are, but it's certainly not a trivial problem and\nat least some of the EU timelines seem pretty unreasonable. Read on\nfor more.","author":false,"creator":"@ekr____","publisher":false,"date":"2022-08-23T17:34:13.720Z","topics":[]},"jsonLd":{"@type":false,"headline":false,"description":false,"image":[],"mainEntityOfPage":{"@type":false,"@id":false},"datePublished":false,"dateModified":false,"isAccessibleForFree":false,"isPartOf":{"@type":[],"name":false,"productID":false},"discussionUrl":false,"license":false,"author":{"@type":false,"name":false,"description":false,"sameAs":false,"image":{"@type":false,"url":false},"givenName":false,"familyName":false,"alternateName":false,"publishingPrinciples":false},"publisher":{"@type":false,"name":false,"description":false,"sameAs":false,"logo":{"@type":false,"url":false},"publishingPrinciples":false},"editor":{"@type":false,"name":false,"description":false,"sameAs":false,"image":{"@type":false,"url":false},"givenName":false,"familyName":false,"alternateName":false,"publishingPrinciples":false}},"twitterObj":false,"status":200,"metadata":{"author":false,"title":"End-to-End Encryption and Messaging Interoperability","description":"","canonical":"https://educatedguesswork.org/posts/messaging-e2e/","keywords":[],"image":"/img/email.drawio.png","firstParagraph":"Posted by ekr on 07 Apr 2022"},"dublinCore":{},"opengraph":{"title":"End-to-End Encryption and Messaging Interoperability","description":false,"url":false,"site_name":false,"locale":false,"type":"article","typeObject":{"published_time":false,"modified_time":false,"author":false,"publisher":false,"section":false,"tag":[]},"image":false},"twitter":{"site":false,"description":false,"card":"summary","creator":"@ekr____","title":false,"image":false},"archivedData":{"link":"https://web.archive.org/web/20220602011351/https://educatedguesswork.org/posts/messaging-e2e/","wayback":"https://web.archive.org/web/20220602011351/https://educatedguesswork.org/posts/messaging-e2e/"}}}