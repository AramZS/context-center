{"initialLink":"https://educatedguesswork.org/posts/messaging-discovery/","sanitizedLink":"https://educatedguesswork.org/posts/messaging-discovery/","finalLink":"https://educatedguesswork.org/posts/messaging-discovery/","htmlEmbed":"<script>window.contexterSetup=window.contexterSetup||function(){window.contexterSetupComplete=!0;class ContexterLink extends HTMLAnchorElement{constructor(){super()}connectedCallback(){this.setAttribute(\"target\",\"_blank\")}}customElements.define(\"contexter-link\",ContexterLink,{extends:\"a\"}),customElements.define(\"contexter-inner\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__inner\"}}),customElements.define(\"contexter-thumbnail\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__thumbnail\"}}),customElements.define(\"contexter-byline\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__byline\"}}),customElements.define(\"contexter-keywordset\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__keywordset\"}}),customElements.define(\"contexter-linkset\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__linkset\"}}),customElements.define(\"contexter-meta\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"contexter-box__meta\"}}),customElements.define(\"contexter-summary\",class extends HTMLElement{constructor(){super()}attributeChangedCallback(name,oldValue,newValue){}connectedCallback(){this.className=\"p-summary entry-summary\"}}),customElements.define(\"contexter-box-head\",class extends HTMLElement{constructor(){super()}connectedCallback(){this.className=\"contexter-box__head\"}}),customElements.define(\"contexter-box-inner\",class extends HTMLElement{constructor(){super()}connectedCallback(){}});class ContexterBox extends HTMLElement{constructor(){super(),this.first=!0,this.shadow=this.attachShadow({mode:\"open\"})}connectedCallback(){if(this.first){this.first=!1;var style=document.createElement(\"style\"),lightDomStyle=(style.innerHTML=`:host {--background: #f5f6f7;--border: darkblue;--blue: #0000ee;--font-color: black;--inner-border: black;font-family: Franklin,Arial,Helvetica,sans-serif;font-size: 14px;background: var(--background);width: 600px;color: var(--font-color);min-height: 90px;display: block;padding: 8px;border: 1px solid var(--border);cursor: pointer;box-sizing: border-box;margin: 6px;contain: content;margin: 6px auto;}// can only select top-level nodes with slotted::slotted(*) {max-width: 100%;display:block;}::slotted([slot=thumbnail]) {max-width: 100%;display:block;}::slotted([slot=header]) {width: 100%;font-size: 1.25rem;font-weight: bold;display:block;margin-bottom: 6px;}::slotted([slot=author]) {max-width: 50%;font-size: 12px;display:inline-block;float: left;}::slotted([slot=time]) {max-width: 50%;font-size: 12px;display:inline-block;float: right;}::slotted([slot=summary]) {width: 100%;margin-top: 6px;padding: 10px 2px;border-top: 1px solid var(--inner-border);font-size: 15px;display:inline-block;margin-bottom: 6px;}contexter-meta {height: auto;margin-bottom: 4px;width: 100%;display: grid;position: relative;min-height: 16px;grid-template-columns: repeat(2, 1fr);}::slotted([slot=keywords]) {width: 80%;padding: 2px 4px;border-top: 1px solid var(--inner-border);font-size: 11px;display: block;float: right;font-style: italic;text-align: right;grid-column: 2/2;grid-row: 1;align-self: end;justify-self: end;}::slotted([slot=keywords]):empty {border-top: 0px solid var(--inner-border);}::slotted([slot=archive-link]) {font-size: 1em;display: inline;}::slotted([slot=archive-link])::after {content: \"|\";display: inline;color: var(--font-color);text-decoration: none;margin: 0 .5em;}::slotted([slot=read-link]) {font-size: 1em;display: inline;}contexter-linkset {width: 80%;padding: 2px 4px;font-size: 13px;float: left;font-weight: bold;grid-row: 1;grid-column: 1/2;align-self: end;justify-self: start;}/* Extra small devices (phones, 600px and down) */@media only screen and (max-width: 600px) {:host {width: 310px;}}/* Small devices (portrait tablets and large phones, 600px and up) */@media only screen and (min-width: 600px) {...}/* Medium devices (landscape tablets, 768px and up) */@media only screen and (min-width: 768px) {...}/* Large devices (laptops/desktops, 992px and up) */@media only screen and (min-width: 992px) {...}/* Extra large devices (large laptops and desktops, 1200px and up) */@media only screen and (min-width: 1200px) {...}@media (prefers-color-scheme: dark){:host {--background: #354150;--border: #1f2b37;--blue: #55b0ff;--font-color: #ffffff;--inner-border: #787a7c;background: var(--background);border: 1px solid var(--border)}}`,document.createElement(\"style\"));lightDomStyle.innerHTML=`contexter-box {contain: content;}contexter-box .read-link {font-weight: bold;}contexter-box a {color: #0000ee;}contexter-box img {width: 100%;border: 0;padding: 0;margin: 0;}/* Extra small devices (phones, 600px and down) */@media only screen and (max-width: 600px) {...}/* Small devices (portrait tablets and large phones, 600px and up) */@media only screen and (min-width: 600px) {...}/* Medium devices (landscape tablets, 768px and up) */@media only screen and (min-width: 768px) {...}/* Large devices (laptops/desktops, 992px and up) */@media only screen and (min-width: 992px) {...}/* Extra large devices (large laptops and desktops, 1200px and up) */@media only screen and (min-width: 1200px) {...}@media (prefers-color-scheme: dark){contexter-box a {color: #55b0ff;}}`,this.appendChild(lightDomStyle),this.shadow.appendChild(style);const innerContainer=document.createElement(\"contexter-box-inner\"),innerSlotThumbnail=(this.shadow.appendChild(innerContainer),document.createElement(\"slot\")),innerSlotHeader=(innerSlotThumbnail.name=\"thumbnail\",innerContainer.appendChild(innerSlotThumbnail),document.createElement(\"slot\")),innerSlotAuthor=(innerSlotHeader.name=\"header\",innerContainer.appendChild(innerSlotHeader),document.createElement(\"slot\")),innerSlotTime=(innerSlotAuthor.name=\"author\",innerContainer.appendChild(innerSlotAuthor),document.createElement(\"slot\")),innerSlotSummary=(innerSlotTime.name=\"time\",innerContainer.appendChild(innerSlotTime),document.createElement(\"slot\")),metaContainer=(innerSlotSummary.name=\"summary\",innerContainer.appendChild(innerSlotSummary),document.createElement(\"contexter-meta\")),innerSlotInfo=(innerContainer.appendChild(metaContainer),document.createElement(\"slot\")),linkContainer=(innerSlotInfo.name=\"keywords\",metaContainer.appendChild(innerSlotInfo),document.createElement(\"contexter-linkset\")),innerSlotArchiveLink=(metaContainer.appendChild(linkContainer),document.createElement(\"slot\")),innerSlotReadLink=(innerSlotArchiveLink.name=\"archive-link\",linkContainer.appendChild(innerSlotArchiveLink),document.createElement(\"slot\"));innerSlotReadLink.name=\"read-link\",linkContainer.appendChild(innerSlotReadLink),this.className=\"contexter-box\",this.onclick=e=>{if(!e.target.className.includes(\"read-link\")&&!e.target.className.includes(\"title-link\")){const mainLinks=this.querySelectorAll(\"a.main-link\");mainLinks[0].click()}}}}}customElements.define(\"contexter-box\",ContexterBox)},window.contexterSetupComplete||window.contexterSetup();</script><contexter-box class=\"link-card h-entry hentry\" itemscope=\"\" itemtype=\"https://schema.org/CreativeWork\"><contexter-thumbnail class=\"thumbnail\" slot=\"thumbnail\"></contexter-thumbnail><contexter-box-head slot=\"header\" class=\"p-name entry-title\" itemprop=\"headline\"><contexter-box-head slot=\"header\" class=\"p-name entry-title\" itemprop=\"headline\"><a is=\"contexter-link\" href=\"https://educatedguesswork.org/posts/messaging-discovery/\" itemprop=\"url\">Discovery Mechanisms for Messaging and Calling Interoperability</a></contexter-box-head></contexter-box-head><contexter-byline class=\"p-author author\" slot=\"author\"><span class=\"p-name byline\" rel=\"author\" itemprop=\"author\">@ekr____</span></contexter-byline><time class=\"dt-published published\" slot=\"time\" itemprop=\"datePublished\" datetime=\"2022-08-23T17:33:53.223Z\">7/23/2022</time><contexter-summary class=\"p-summary entry-summary\" itemprop=\"abstract\" slot=\"summary\"><p>New phone, who dis?</p></contexter-summary><contexter-keywordset itemprop=\"keywords\" slot=\"keywords\"></contexter-keywordset><a href=\"https://web.archive.org/web/20220808000630/https://educatedguesswork.org/posts/messaging-discovery/\" is=\"contexter-link\" target=\"_blank\" rel=\"timemap\" class=\"read-link archive-link\" itemprop=\"archivedAt\" slot=\"archive-link\">Archived</a><a is=\"contexter-link\" href=\"https://educatedguesswork.org/posts/messaging-discovery/\" class=\"read-link main-link\" itemprop=\"sameAs\" slot=\"read-link\">Read</a></contexter-box>","linkId":"4dd96675c36b69f238eac81f563f2281bc94000c","data":{"originalLink":"https://educatedguesswork.org/posts/messaging-discovery/","sanitizedLink":"https://educatedguesswork.org/posts/messaging-discovery/","canonical":"https://educatedguesswork.org/posts/messaging-discovery/","htmlText":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Discovery Mechanisms for Messaging and Calling Interoperability</title>\n    <meta name=\"description\" content=\"\">\n\n    <meta name=\"twitter:card\" content=\"summary\" />\n    <meta name=\"twitter:creator\" content=\"@ekr____\" />\n    <meta property=\"og:title\" content=\"Discovery Mechanisms for Messaging and Calling Interoperability\" />\n    <meta property=\"og:description\" content=\"New phone, who dis?\" />\n    <meta property=\"og:type\" content=\"article\" />\n\n    <link rel=\"stylesheet\" href=\"/css/prism-base16-monokai.dark.css\">\n    <link rel=\"stylesheet\" href=\"/css/index.css\">\n    <link rel=\"alternate\" href=\"/feed/feed.xml\" type=\"application/atom+xml\" title=\"Educated Guesswork\">\n    <link rel=\"alternate\" href=\"/feed/feed.json\" type=\"application/json\" title=\"Educated Guesswork\">\n  </head>\n  <body>\n      <header>\n        <div class=\"wrapper\">\n          <h1 class=\"nav-title\"><a href=\"/\">Educated Guesswork</a></h1>\n          <ul class=\"nav\">\n            <li class=\"nav-item\"><a  href=\"/posts/\">Archive</a></li>\n            <li class=\"nav-item\"><a  href=\"/about/\">About Me</a></li>\n            <li class=\"nav-item desktop-only\"><a href=\"mailto:ekr@rtfm.com\">Contact</a></li>\n            <li class=\"nav-item desktop-only\"><a href=\"https://twitter.com/ekr____\">Follow on Twitter</a></li>\n            <li class=\"nav-item highlight\"><a href=\"/subscribe\">Subscribe</a></li>\n          </ul>\n        </div>\n      </header>\n        <div class=\"wrapper\">\n          <main class=\"tmpl-post\">\n            \n<div class=\"grid\">\n  <div class=\"grid-main\">\n    <article>\n        <h1>Discovery Mechanisms for Messaging and Calling Interoperability</h1><p class=\"subtitle\">New phone, who dis?</subtitle>\n        <p class=\"dateline\">Posted by <a target=\"_blank\" href=\"https://twitter.com/ekr____\">ekr</a> on 04 Aug 2022</p>\n\n        <p>As I discussed in an <a href=\"/posts/messaging-e2e\">earlier post</a>, it looks like the EU [<em>corrected an embarassing typo that had this as UK</em> -- EKR]\nDigital Markets Act (DMA) is going to require\n<a href=\"(https://www.ianbrown.tech/wp-content/uploads/2022/03/Final-DMA-interoperability-text.pdf)\">interoperability</a>\nbetween messaging systems. That previous post focused on how to\nestablishing end-to-end encryption between messaging systems.\nIn this post I want to talk about the problem of discovering\nwhich messaging system someone is on.</p>\n<h2 id=\"identifier-portability\">Identifier Portability <a class=\"direct-link\" href=\"#identifier-portability\">#</a></h2>\n<p>Many messaging systems bootstrap\noff of existing identifiers in the form of of phone numbers\n(jargon: <a href=\"https://en.wikipedia.org/w/index.php?title=E.164&amp;oldid=1092734805\">&quot;E.164 number&quot;</a>).\nPhone numbers are <a href=\"/posts/messaging-e2e/#telephone-addressing\">structured</a>,\nwhich means that when you place a call over the\n<em>Public Switched Telephone Network (PSTN)</em>\nit incrementally routes the call via the country,\narea code, etc., but from the perspective of a messaging system, they are <em>opaque</em>\nand <em>unstructured</em>, which is to say that\nthe identifier <code>+1.415.555.0123</code> might be for a user who is\non iMessage, WhatsApp, or even both. If all I have is someone's\nphone number, how do I know which service to reach them on?</p>\n<div class=\"callout\">\n<h4 id=\"phone-numbers-as-a-shared-namespace\">Phone numbers as a shared namespace <a class=\"direct-link\" href=\"#phone-numbers-as-a-shared-namespace\">#</a></h4>\n<p>Phone numbers weren't originally designed to be a single\nnamespace that was shared between carriers, but rather\nas a single namespace to be used by a single carrier,\nthe Bell System (motto: &quot;One Policy, One System, Universal Service&quot;).\nEven then, numbers were structured, but the structure\nrepresented the topology of the system so that you\ncould incrementally route calls. For instance, you could use the\narea code to direct traffic to the right region followed by the\nlocal office code to direct it to the right switch, and then\ndown to the right subscriber line.</p>\n<p>When the Bell System was <a href=\"https://en.wikipedia.org/w/index.php?title=Breakup_of_the_Bell_System&amp;oldid=1098874467\">broken up</a>\nthe breakup was done along geographic lines into\nwhat were called <em>Regional Bell Operating Companies (RBOCs)</em>. Because\nthe topology of the system was also roughly geographic—unlike,\nsay, the Internet, where number prefixes\ndo not really correspond to geographic regions—you\ncould at least roughly align the RBOC boundaries with the\nnumber structure.\nHowever, subsequently jurisdictions started to require\n<a href=\"https://en.wikipedia.org/w/index.php?title=Local_number_portability&amp;oldid=1077125532\">Local Number Portability</a>, which allowed you to take your number from carrier to carrier.\nThus, even if you were originally assigned a number out of Verizon's\nblock, you could &quot;port&quot; it to T-Mobile, with the result that you\nhave a shared namespace.</p>\n</div>\n<p>One possibility would be to simply sidestep this question\nby having identifiers be scoped, either by having people say\n&quot;connect with me on WhatsApp at <code>1.415.555.0123</code>&quot; or by\njust adding an explicit scoping parameter, so your address\nis <code>1.415.555.0123@whatsapp.com</code> (see <a href=\"/posts/messaging-e2e/#identity\">here</a> for\nmore on this).\nThis is how e-mail works and\nisn't the worst thing in the world, but does make it more\ncomplicated to contact someone else if all you have is their\nnumber, as well as making things confusing if they change\ntheir preferred app.\nBy contrast, phone numbers are <em>portable</em> across carriers,\nwhich is to say that if you move from T-Mobile to Verizon\nyou get to keep your phone number, and I don't need to\nknow what carrier you have in order to call you: I just enter\nthe phone number. This is implemented by having a giant—well, not really\nthat giant, as the entire US number space is less than 10 billion numbers and so\nbasically fits on a USB stick<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>—<a href=\"https://www.nationalnanpa.com/\">database</a>\nthat knows which carrier is responsible for each number.\nWhen you want to call someone, your carrier checks this\ndatabase (technical term: &quot;dip&quot;) to see where to route\nthe call.</p>\n<p>So, what if you want to have this same property for instant\nmessaging or video calling systems? This actually turns\nout to be surprisingly complicated.</p>\n<h2 id=\"phone-number-based-addressing-for-single-applications\">Phone Number-Based Addressing for Single Applications <a class=\"direct-link\" href=\"#phone-number-based-addressing-for-single-applications\">#</a></h2>\n<p>Before trying to solve the problem of routing between\napplications who use phone number-based addresses, it's\nuseful to look at the simpler problem of a single application\nthat uses phone numbers as addresses (e.g., WhatsApp).\nInstead of using the number portability database,\nwhich doesn't really have the information you need\nhere, these devices bootstrap authentication off of\nSMS.</p>\n<div class=\"callout\">\n<h4 id=\"how-does-the-pstn-authenticate-you%3F\">How does the PSTN authenticate you? <a class=\"direct-link\" href=\"#how-does-the-pstn-authenticate-you%3F\">#</a></h4>\n<p>You might be wondering how the PSTN knows which\nnumber is associated with a given device. Back in the\ndays of landline phones, the answer was simple:\neach subscriber had their own literal line. I.e.,\nthere was a separate pair of copper wires that went\nfrom the central office to the subscriber's house and\nthe switch knew which pair of wires went with each\nnumber.</p>\n<p>Obviously this doesn't work with mobile phones. Instead,\neach phone has its own cryptographic key which it uses\nto authenticate to the network. When your number is\nassigned to you, that key is then associated with the\nnumber in the carrier's database. In modern phones,\nthat key is generally stored in a <a href=\"https://en.wikipedia.org/w/index.php?title=SIM_card&amp;oldid=1100219575\">Subscriber Interface Module (SIM)</a>,\nwhich is a small chip embedded in a plastic card:</p>\n<img width=\"200\" src=\"/img/sim-card.jpg\" alt=\"SIM card\">\n<p>[From Wikipedia]</p>\n<p>The SIM card is actually what gives your phone its identity,\nand if you swap SIM cards between devices, you will also\nswap their numbers.</p>\n</div>\n<ol>\n<li>\n<p>The app prompts you for a password and your phone number.</p>\n</li>\n<li>\n<p>The service then sends you an SMS message with\na random code.</p>\n</li>\n<li>\n<p>You enter that code into the app's user interface.</p>\n</li>\n</ol>\n<p>This demonstrates that you can receive messages at the indicated\nphone number.<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<p>This authentication mechanism relies on the assumption that\nthe PSTN correctly routes messages to the right\nlocation and that nobody else can read them. When you\nthink about it, this is actually a bit of an odd assumption to make\nat the time you are installing a messaging application that\noffers stronger security than SMS, but that's actually\na surprisingly common scenario: certificate issuance on the\nWeb relies on the weak security properties provided by\nunencrypted DNS to bootstrap up to TLS, after which the\nDNS no longer needs to be trusted.</p>\n<p>The general concept\nhere is that you only trust the weaker system once\nto form the initial association\nand from then on you have strong continuity of\nauthentication (in some systems,\nthis is known as <a href=\"https://en.wikipedia.org/w/index.php?title=Trust_on_first_use&amp;oldid=1085537067\">Trust On First Use (TOFU)</a>).\nIn both cases, you\ncan build supplementary mechanisms like Certificate\n<a href=\"https://certificate.transparency.dev/\">Certificate Transparency</a>\nor <a href=\"https://transparency.dev/application/strengthen-discovery-of-encryption-keys/\">Key Transparency</a> to detect mississuance.</p>\n<p>One natural question to ask is why the app can't just ask\nthe device, which, after all, knows its own phone number.\nThe problem is that the device can't be trusted. Remember\nthat what we are trying to do is to convince the <em>service</em>\nthat a given device is associated with this number, and\neven though the service wrote the app in question, it's very\n<a href=\"/verifying-software/\">difficult for them to determine</a>\nthat an attacker hasn't modified the app to lie about its number.\nThe SMS verification mechanism doesn't have this problem;\nbecause it actually checks that you can receive messages,\nit works even if the device and the code running on it are\ntotally untrusted.</p>\n<p>It's easier to see the trust relationships if we look at\nwhat's really happening, as shown in the diagram below:</p>\n<p><img src=\"/img/phone-number-auth.png\" alt=\"Phone number verification via SMS\"></p>\n<p>In the first phase, the user is interacting with the\napplication, which is what collects the password and the\nphone number and sends them to the server. The server\nthen sends the code through the phone network to\nthe <em>device</em>. The device shows it to the user, who then\ngives it to the app. The app then sends it back to the\nserver, which is then able to confirm the code and\nverify the account. Importantly, even though the server\nis sending the code to the app (via the user)\nthe SMS channel to the phone  is <em>out of band</em> from the app's connection to\nthe server. In fact, they may even be using different\ntechnology; for instance, if you are on WiFi, then the\nconnection to the server will use that radio even though\nthe SMS comes in over the mobile telephony network.\nEven if all the data is going over the mobile channel,\nthe IP communications from the app aren't strongly\nbound to your phone number.</p>\n<p>Note that even if you don't trust the answer, if you could\nask the device for its number, you could still\nskip prompting the user. However, the number\nmay not be available. Apple's\nsecurity and privacy policies <a href=\"https://stackoverflow.com/questions/193182/programmatically-get-own-phone-number-in-ios\">forbid</a> this (presumably for privacy reasons) though it appears to be\n<a href=\"https://stackoverflow.com/questions/2480288/programmatically-obtain-the-phone-number-of-the-android-phone\">possible</a> on Android. For similar security reasons,\nthe app can't just reach into your SMSes—which are received\nby the operating system—and grab the confirmation code,\nas this would allow it to read any SMS.<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>\nThe exception here is iMessage, which uses similar techniques\nto verify the phone number, but because it ships as part\nof the operating system is able to do so silently, even\nthough Apple doesn't permit other apps to do so.</p>\n<p>Once the service has associated the user's account with their\nphone number, the rest of the system is fairly straightforward\nthe app connects and authenticates as the user and the service\njust routes messages/calls to the user; no further interaction\nwith the PSTN is required. It is worth noting, however, that\nthis has some funny results if the phone number is ever\nreassigned because the service won't be notified. The result\ncan be that Alice has an account on some service for a\nnumber that has been reassigned to Bob. It's hard to avoid\nthis situation with this kind of loose service coupling,\nbut of course it's not unique to the Internet: I still\nget paper mail addressed to the people who lived in my house\nover 20 years ago.</p>\n<h2 id=\"phone-number-based-addressing-for-multiple-applications\">Phone Number-Based Addressing for Multiple Applications <a class=\"direct-link\" href=\"#phone-number-based-addressing-for-multiple-applications\">#</a></h2>\n<p>The basic situation isn't that different when different users\nuse different apps, except that you not only need to determine which\ndevice is associated with a given user but also which app they\nare using. As a simplification, let's assume that everyone\njust uses a single app (analogous to the situation with\nmobile phones where each subscriber just has a single carrier);\nWe'll look at the multi-app situation <a href=\"#multiple-apps-per-user\">below</a>.</p>\n<p>Consider the following three users:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">User</th>\n<th style=\"text-align:left\">App</th>\n<th style=\"text-align:left\">Number</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Alice</td>\n<td style=\"text-align:left\"><strong>A</strong></td>\n<td style=\"text-align:left\">1.650.555.0011<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Bob</td>\n<td style=\"text-align:left\"><strong>B</strong></td>\n<td style=\"text-align:left\">1.415.555.0022</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Charlie</td>\n<td style=\"text-align:left\"><strong>A</strong></td>\n<td style=\"text-align:left\">1.510.555.0033</td>\n</tr>\n</tbody>\n</table>\n<p>What happens if Alice gets Bob's number and wants to contact him in\nApp <strong>A</strong>? The obvious thing would be for Alice to just SMS\nBob and ask &quot;which app are you using?&quot; She could then tell\n<strong>A</strong> to contact &quot;1.415.55.0022 via app <strong>B</strong>&quot;\n(assuming that <strong>A</strong> and <strong>B</strong>) can already talk to each\nother as discussed in my <a href=\"/posts/messaging-e2e\">earlier post</a>).\nThis will work but it's clumsy and inconvenient; what you want\nis for Alice to put Bob's number into app <strong>A</strong> and for <strong>A</strong> to figure\nthings out. Unfortunately, this doesn't appear to be something that <strong>A</strong> can do\non its own; rather, we need some additional infrastructure.</p>\n<p>I'm aware of two major designs here. In the first design, you have\na directory service which knows which number is associated with\nwhich app. In the second design, each user—or rather their\napp—has to discover it out for itself.</p>\n<h3 id=\"directory-services\">Directory Services <a class=\"direct-link\" href=\"#directory-services\">#</a></h3>\n<p>The obvious way to approach this is just to use the same approach as\nfor number portability, i.e., to have some sort of global directory\nservice that tells you which app to use for each number.</p>\n<p>It's possible you could directly integrate it with the\nexisting PSTN databases, but that's probably going to be a lot of work and it's\nprobably easier to just use the same kind of SMS verification we\ndiscussed in the previous section. For instance, suppose you had a\nsingle global directory service. When you installed the app you would\nprove possession of your number to the directory service which\nwould then create a record mapping your number to the app you\nwere using. This directory can then be queried by other people,\nas shown in the diagram below.</p>\n<p><img src=\"/img/phone-number-service.png\" alt=\"A simple phone number service\"></p>\n<p><em>[Update: fixed diagram -- 2022-08-04]</em></p>\n<p>In this example, Alice installs app <strong>A</strong>, which automatically\ncontacts the directory and proves possession of her number. The\ndirectory then creates a record mapping her number to app <strong>A</strong>.<sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup>\nWhen Bob wants to contact Alice, he puts her number into\napp <strong>B</strong>, which contacts the directory and finds out that\nAlice uses <strong>A</strong>. <strong>B</strong> then uses whatever interoperability\nmechanism it has with <strong>A</strong> to establish communication.</p>\n<p>This system is obviously massively oversimplified. If we wanted\nto build something real, we'd need to address some important design\nquestions and fix some—as-yet-unsolved—privacy\nissues.</p>\n<h4 id=\"authentication\">Authentication <a class=\"direct-link\" href=\"#authentication\">#</a></h4>\n<p>The first question we'd need to address is the authentication\nstructure. In the design I sketched above, the directory service is\nsolely responsible for knowing which app a given number is associated\nwith, but <em>not</em> for authenticating the user. For instance, if Alice\nand Charlie both use app <strong>A</strong> then when Bob tries to call Alice,\n<strong>A</strong> can redirect the call to Charlie. Of course, <strong>A</strong> might run\nsome kind of certificate/key transparency type of system to prevent\nthis kind of attack, but that requires every app to engage with that.</p>\n<p>Note that the reverse is also true: when Bob calls Alice, Alice is\nrelying on <strong>B</strong>'s representation that it's really Bob, and <strong>B</strong> can\nlie. Moreover, it's important for Alice to check the directory to make\nsure that Bob's number is actually associated with <strong>B</strong>. Otherwise,\nservice <strong>C</strong> could just claim to be speaking for Bob even if he's not\na user of app <strong>C</strong> at all.</p>\n<p>An alternate approach would be to have a global authentication\nsystem in which the directory issues a credential to each user\nbinding their number to whatever cryptographic credentials their\napp uses (effectively, this is a certificate authority for\nphone numbers). In this case, it wouldn't be possible for\nan app to lie about user, though of course we now\nhave to trust the directory. The advantage of this design\nwould be that you only have to trust one thing and maybe\nyou could have better auditing and transparency\nfor a global service.</p>\n<p>It's also possible to run both kinds\nof systems simultaneously, where each app uses its own\nauthentication system internally but also is able to make\nuse of a global credential system. This allows for innovation\ninside an app but also provides interoperability.</p>\n<h4 id=\"centralization\">Centralization <a class=\"direct-link\" href=\"#centralization\">#</a></h4>\n<p>Another problem with this design is that it seems to require\na centralized directory service, or at best a small number of\nsuch services. The basic invariant here is that you need\na procedure that takes in a number and outputs the app it's\nassociated with. The easiest way to do that is to have a\nsingle service. Perhaps if there were only a small number\nof apps you could check them individually but if there\nare tens or hundreds it's a real scalability problem (and may also be\na privacy problem, as discussed below).</p>\n<div class=\"callout\">\n<h4 id=\"enum\">ENUM <a class=\"direct-link\" href=\"#enum\">#</a></h4>\n<p>For the real nerds here, there is actually an RFC documenting\na less centralized design rooted in the DNS called <a href=\"https://datatracker.ietf.org/doc/html/rfc6116\">ENUM</a>.\nThe idea was that you would store records in the DNS under your phone number\n(hilariously, reversed, because phone numbers read left to right and DNS addresses\nread right to left), so you might have <code>8.4.1.0.6.4.9.7.0.2.4.4.e164.arpa.</code>.\nThis never took off for a host of reasons, and I don't think it's\nreally a viable option here because it requires DNS delegations\nto match the phone number structure, which seems like a lot of\nwork for everyone involved.</p>\n</div>\n<p>There are really two objections here: one about deployability\nand one about network architecture. The deployability objection\nis that someone has to run the service and that has to be paid\nfor, so who is going to do that. I tend to think that this isn't\nthat big an issue: this really isn't that big a service by modern\nstandards, and we have a reference point for what it costs to\nrun something similar in the form of Let's Encrypt, which\nhas a budget of around <a href=\"https://projects.propublica.org/nonprofits/organizations/463344200\">6 million dollars</a>,\nwith the costs scaling sublinearly. The whole premise of the\nsituation is that companies like Apple and Facebook will\nbe required to interoperate, and against that background,\nthis isn't really that much money.</p>\n<p>I take the network architecture objection more seriously:\nyet another centralized service isn't great for the Internet.\nI think there are some ways to make it somewhat less\ncentralized, for instance by having each app maintain\nits own mirror of the database, but at the end of the day\nthere's a tradeoff here between the good of interoperability—assuming\nyou think it is good—and the bad of centralization.\nI tend to think that the balance is in favor of interoperability\nbut it's not a slam dunk, especially if you think that there\nare other architectures that would do a better job (see <a href=\"#spin\">below</a>).</p>\n<h4 id=\"privacy\">Privacy <a class=\"direct-link\" href=\"#privacy\">#</a></h4>\n<p>Probably the biggest issue with this design is that it has\nsome fairly unfortunate privacy properties. Specifically\nin the naive version of this design:</p>\n<ul>\n<li>\n<p>The directory service gets to see which app(s) a given\nphone number is associated with.</p>\n</li>\n<li>\n<p>It's possible for ordinary users to scrape the directory\nservice and learn which app(s) a given user is associated\nwith.</p>\n</li>\n<li>\n<p>The directory server gets to see every lookup\nand so be able to learn who is trying to connect with who.\n(This is even worse if the user has to try every possible app)</p>\n</li>\n</ul>\n<p>It's probably possible to address some of these issues, though it's not immediately\nobvious that they can be completely fixed. The rest of this section\ncontains some handwaving in the direction of potential solutions.\nI just came up with these recently, so don't blame me if they\nare horrifically broken.</p>\n<p>The last one is probably the easiest, as there are a number of\nreasonably efficient <a href=\"https://en.wikipedia.org/w/index.php?title=Private_information_retrieval&amp;oldid=1068898272\">private information\nretrieval (PIR)</a>\nschemes for allowing a client to retrieve a single value from a server\nwithout disclosing the value to the server. So, if we just\nrequire those values to be retrieved over PIR (or even over\na proxy!), we can probably provide some kind of privacy\nfor who is connecting to who.</p>\n<p>Similarly, I think it's probably possible to prevent large-scale\nscraping of user data by clients. This is a pretty typical\nrate limiting problem and it's already a problem existing apps have\nto face, so we could probably apply similar techniques here.\nThis doesn't do much to prevent learning about a single individual,\nthough, for instance, suppose I want to know if someone is on\nWhatsApp. There seems to be an inherent tension here between allowing\nseamless discovery and connection and providing privacy in this\ncase, so I'm not sure if it's really soluble at the end of the\nday.</p>\n<p>The best idea I have for the directory service getting to\nsee which apps a given number is associated with is to split\nup the data between two servers. The idea would be that you would have two directory\nservers operated by unaffiliated entities. The client would then\nprove its identity to both servers (as above) and this would\ngive it a credential that it could use to authenticate to that\nserver. It would then take encrypt its app identity and send the\nkey to one server and the encrypted value to the other. Then\nwhen someone wanted to contact you, they would contact both\nservers and reconstruct the original value, as shown below<sup class=\"footnote-ref\"><a href=\"#fn6\" id=\"fnref6\">[6]</a></sup></p>\n<p><img src=\"/img/phone-number-split.png\" alt=\"Split storage for records\"></p>\n<p><em>[Update: fixed diagram --2022-08-04]</em></p>\n<p>This stops the servers from being able to access the entire database,\nthough you still need to worry about scraping attacks, either\nagainst both servers or by one against the other, so it's not\nperfect.</p>\n<h3 id=\"spin\">SPIN <a class=\"direct-link\" href=\"#spin\">#</a></h3>\n<p>Recently,\n<a href=\"https://www.jdrosen.com/\">Jonathan Rosenberg</a>,\n<a href=\"https://www.linkedin.com/in/cullen/\">Cullen Jennings</a>,\n<a href=\"https://alissacooper.com/\">Alissa Cooper</a>,\nand <a href=\"http://playingattheworld.blogspot.com/\">Jon Peterson</a>—a group of\nheavy hitters in real time communications if there ever was one—published\nan <a href=\"https://www.ietf.org/archive/id/draft-rosenberg-dispatch-spin-00.html\">alternative design called SPIN</a>\nfor this problem. The idea is to replace the centralized server by having\neach client do its own phone number mapping via SMS. I.e., when Alice<br>\nwants to contact Bob, her device sends an SMS to Bob's device (again,\nwith some unpredictable random value). Bob's device responds with the app(s)\nthat Bob supports and perhaps with his identities on those apps.\nThe reasoning here is the same as with the directory service: only\nsomeone who could receive SMS at Bob's number could complete the\nchallenge, so you must be talking to Bob.</p>\n<p>Of course, this leaves us with the problem of Bob knowing who is calling,\nbecause Alice just asserts her number. One way to address this would\nbe for Bob to issue a challenge in the opposite direction,\nbut this isn't actually what SPIN does. Instead it assumes that Alice\nhas obtained a credential—presumably using a similar\nissuance process to the one I indicated above—that she\nuses to sign her message to Bob, but that's a design choice.\nIf you wanted to entirely eliminate centralized infrastructure\nyou could certainly do that, and that's an obvious selling\npoint of SPIN. Even with this kind of hybrid design, the\ndirectory service doesn't need to be available for query\nand so you don't have the privacy problems I discussed above\n(it also isn't in the critical path for calls, but availability\nof this kind of server system seems like a mostly solved\nproblem at this point).</p>\n<p>Of course, the SPIN design has a number of drawbacks (in fact,\nI originally started thinking about this problem because I read\nthe draft and I wanted to try to fix them).</p>\n<h4 id=\"offline-access\">Offline Access <a class=\"direct-link\" href=\"#offline-access\">#</a></h4>\n<p>With SPIN, you can't really do discovery of anyone who isn't online at the\nsame time as you (more precisely, it just stalls until they are\nonline and you can get the return message).\nThis isn't necessarily <em>that</em> big an issue for\nreal-time calls because if someone isn't online then you're not\ngoing to be able to call them anyway (though there's voicemail) but\nit's a big issue for instant messaging, which is inherently\nasynchronous. Jonathan Rosenberg\n<a href=\"https://mailarchive.ietf.org/arch/msg/dispatch/CFFoX9vNXthejIPGpmLf_pmY01Y/\">argues</a>\nthat mobile devices are basically always connected.  I'm not sure\nthat this is really true, but if you want to extend to systems\nwhich have e-mail style identifiers, then those may be on desktop\nnot mobile devices, so this is a drawback.\nThis isn't an issue for the directory service design: once\na user has registered with the directory service then anyone\ncan do a lookup whether you are offline or not.</p>\n<p>One partial mitigation for this might be for the operator of\neach app to record (cache) phone number validations as they\nhappen, so that they gradually learn some of the mappings\nand can resolve them immediately. For instance, once\nAlice (on service <strong>A</strong>) has discovered that Bob is on service <strong>B</strong>,\nif Charlie (also on service <strong>A</strong>) can learn this information\nfrom <strong>A</strong> without a new verification stage.\nThis has the advantage that it's &quot;soft state&quot; in that things work without it,\nbut the disadvantage that some things work and some don't.</p>\n<h4 id=\"it-(mostly)-requires-changing-the-operating-system\">It (mostly) requires changing the operating system <a class=\"direct-link\" href=\"#it-(mostly)-requires-changing-the-operating-system\">#</a></h4>\n<p>Because the SPIN design involves every client doing its own phone\nnumber verification, people are going to get a lot of SMS messages\nrequiring them to verify, which is annoying. SPIN expects to\naddress this by having the device operating system absorb the\nmessages and respond for you so the user doesn't see them.\nThis isn't necessarily a bad idea, but it's kind of ugly and\nmeans that people with older operating systems will have a bad\nexperience.</p>\n<p>Again, this isn't an issue with the directory service version\nbecause apps can just register themselves. That version <em>does</em>\nwork better if the operating system helps out with SMS verification,\nbut even in the worst case the user is just bothered once for\neach app they use, not for each person who wants to call them.</p>\n<h4 id=\"attack-resistance\">Attack Resistance <a class=\"direct-link\" href=\"#attack-resistance\">#</a></h4>\n<p>As noted above, SMS routing in the PSTN isn't really that\nsecure, and so you have to worry about misissuance. One way\nto mitigate this is to have the results of verification\npublished in a transparency log. This allows everyone to see\nwhich credentials have been assigned to each number and\npotentially detect misissuance. This works fine in a directory\nservice type system but in a system where each user does their\nown verification, you might run into a scenario where an\nattacker hijacked just the connection between Alice and Bob\nbut not between Charlie and Bob. This would need some fancier\nmechanisms to detect, though we could probably design\nsomething.</p>\n<h4 id=\"privacy-2\">Privacy <a class=\"direct-link\" href=\"#privacy-2\">#</a></h4>\n<p>As noted above, the privacy situation is largely better without\na centralized server, but there's still an issue around probing\nfor individual user information. I.e., Alice wants to know\nwhich app(s) Bob has and so sends an SMS and looks at the results.\nOne way to address this is for Bob to have some logic that runs\non the device that determines whether to answer the query—perhaps\ndepending on whether Alice's number is in the contact list—though\nit's not clear how easy that is to configure.<sup class=\"footnote-ref\"><a href=\"#fn7\" id=\"fnref7\">[7]</a></sup></p>\n<h3 id=\"multiple-apps-per-user\">Multiple Apps Per User <a class=\"direct-link\" href=\"#multiple-apps-per-user\">#</a></h3>\n<p>Multiple apps are a pretty straightforward extension to either of these\nsystems. In both cases, you can basically think of the system as\npublishing a &quot;record&quot; attached to the phone number. I've implicitly\nassumed that the record would contain a single app, but there's no\ntechnical reason why they can't contain a list of apps (this is slightly\nmore complicated in the directory service version for cryptographic\nreasons, but not really that hard).</p>\n<p>The situation for the initiator is somewhat more complicated: I'm\nusing app <strong>A</strong> and I want to call someone and learn that they\nhave apps <strong>B</strong> and <strong>C</strong>. What now? Presumably each app is going\nto have a priority list of apps it would prefer to interoperate\nwith (favoring itself!) and will just pick the top one. But this\ncan lead to some obvious problems, such as: will you get the same\napp in each direction? What happens if someone installs a new\napp that is more preferred? These aren't strictly discovery problems\nbut are definitely ergonomics issues that apps will need to work out\nsomehow.</p>\n<h2 id=\"final-thoughts\">Final Thoughts <a class=\"direct-link\" href=\"#final-thoughts\">#</a></h2>\n<p>Obviously this is a difficult problem without a single great solution.\nI <em>do</em> think it's possible to come up with something reasonably good here, especially\nif we're willing to make some technical compromises. That's a\nlot more likely if there really will be a requirement to interoperate;\nwhile there are real technical problems, many of the problems\nare around incentives (e.g., why should I run a server so some people\ncan talk to my users?) and regulation provides those incentives.</p>\n<p>This problem would be vastly easier\nif the addresses people were using had been structured from the very beginning: as an\nexample, e-mail addresses already consist of a user portion and a domain\nportion, and so it's easy to know where to route any given message.\nBut because instant messaging addresses are largely opaque, you're\nstuck with clumsier solutions. On the other hand, most e-mail addresses\naren't portable—you can't take <code>example@gmail.com</code> over to Hotmail—so\nif you ever wanted that you'd be back in the soup. To the best of my knowledge\nthere's no real way to have address portability without some kind of\nrouting database, either an explicit one like the DNS or my directory service,\nor an implicit one like the PSTN fabric that powers SMS verification.</p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>\nYou can now buy 128 GB flash\ndrives, so this gives us 12 bytes per record. <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>\nNote that it <em>does not</em> demonstrate that this device is\nassociated with that number. For instance, you could\nhave two devices, one of which is associated with that\nnumber and one of which you are installing the device on. <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>\nYes, it's possible to design a system that doesn't\nrequire full SMS access, but that's not how these\nAPIs work. <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p>See <a href=\"https://en.wikipedia.org/w/index.php?title=555_(telephone_number)&amp;oldid=1101658698\">here</a> for why I am using 555 numbers. <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p>\nIn a real system, we'd probably want to prevent malicious\napps on Alice's phone from registering for another app,\nin what's called an &quot;identity misbinding&quot; attack, but\nI'm ignoring that here. <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn6\" class=\"footnote-item\"><p>\nUpdate 2022-08-04:\nYou could also use secret sharing, but encryption has\nthe advantage that if the record you want to store is\nlarge then the total size is smaller. <a href=\"#fnref6\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn7\" class=\"footnote-item\"><p>\nIt might be possible to replicate this functionality in the\ndirectory service model. Naively, Bob could just upload the\nalgorithm for which numbers to answer for, but this has its\nown privacy problems because it leaks Bob's contact list to the service.\nThere may be some fancy cryptographic solution that addresses\nall these privacy problems at once, but I don't have it\nin my pocket. <a href=\"#fnref7\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n\n    </article>\n\n    <section class=\"header-line\">\n      <h3>Keep Reading</h3>\n      <ul><li>Next: <a href=\"/posts/safe-browsing-privacy/\">Can we make Safe Browsing safer?</a></li><li>Previous: <a href=\"/posts/pacifica-foothills/\">Pacifica Foothills Race Report</a></li>\n      </ul>\n    </section>\n      \n  </div>\n  <aside class=\"grid-sidebar\">\n\n    <section class=\"box\">\n      <h2>More from Educated Guesswork</h2>\n      <p>Tech, tech policy, and sometimes running by <a href=\"/about\">Eric Rescorla</a>. Subscribe to the newsletter for more like this:</p>\n      <form class=\"inline-form\" action=\"https://educatedguesswork-subscribe.herokuapp.com/subscribe\" method=\"post\">\n  <input type=\"email\" placeholder=\"Your e-mail address...\" id=\"email\" name=\"email\">\n  <button class=\"subscribe-button\">Subscribe</button>\n</form>\n\n\n    </section>\n\n    <section>\n      <h3>Recent Posts</h3>\n\n      \n      <ul reversed class=\"postlist\"}\">\n\n  <li class=\"postlist-item\">\n    <a href=\"/posts/safe-browsing-privacy/\" class=\"postlist-link\">Can we make Safe Browsing safer?</a>\n    <time class=\"postlist-date\" datetime=\"2022-08-16\">16 Aug 2022</time>\n    <span class=\"post-tags\">\n    \n      <a href=\"/tags/networking/\" class=\"post-tag\">networking</a>\n      <a href=\"/tags/security/\" class=\"post-tag\">security</a>\n      <a href=\"/tags/privacy/\" class=\"post-tag\">privacy</a>\n      <a href=\"/tags/pir/\" class=\"post-tag\">pir</a>\n    </span>\n  </li>\n\n  <li class=\"postlist-item\">\n    <a href=\"/posts/messaging-discovery/\" class=\"postlist-link\">Discovery Mechanisms for Messaging and Calling Interoperability</a>\n    <time class=\"postlist-date\" datetime=\"2022-08-04\">04 Aug 2022</time>\n    <span class=\"post-tags\">\n    \n      <a href=\"/tags/encryption/\" class=\"post-tag\">encryption</a>\n      <a href=\"/tags/policy/\" class=\"post-tag\">policy</a>\n      <a href=\"/tags/messaging/\" class=\"post-tag\">messaging</a>\n    </span>\n  </li>\n\n  <li class=\"postlist-item\">\n    <a href=\"/posts/pacifica-foothills/\" class=\"postlist-link\">Pacifica Foothills Race Report</a>\n    <time class=\"postlist-date\" datetime=\"2022-07-25\">25 Jul 2022</time>\n    <span class=\"post-tags\">\n    \n      <a href=\"/tags/running/\" class=\"post-tag\">running</a>\n      <a href=\"/tags/race report/\" class=\"post-tag\">race report</a>\n    </span>\n  </li>\n\n  <li class=\"postlist-item\">\n    <a href=\"/posts/random-audits/\" class=\"postlist-link\">Verifiably selecting taxpayers for random audit</a>\n    <time class=\"postlist-date\" datetime=\"2022-07-11\">11 Jul 2022</time>\n    <span class=\"post-tags\">\n    \n      <a href=\"/tags/privacy/\" class=\"post-tag\">privacy</a>\n      <a href=\"/tags/security/\" class=\"post-tag\">security</a>\n    </span>\n  </li>\n\n  <li class=\"postlist-item\">\n    <a href=\"/posts/tenaya-loop2/\" class=\"postlist-link\">Tenaya Loop Adventure Run 2: Redemption</a>\n    <time class=\"postlist-date\" datetime=\"2022-07-08\">08 Jul 2022</time>\n    <span class=\"post-tags\">\n    \n      <a href=\"/tags/running/\" class=\"post-tag\">running</a>\n      <a href=\"/tags/race report/\" class=\"post-tag\">race report</a>\n    </span>\n  </li>\n\n</ul>\n\n      <p><a href=\"/posts/\">Full archives ...</a></p>\n    </section>\n\n  </aside>\n</div>\n\n<!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{\"token\": \"8950ce09297145caa48662b027542727\"}'></script><!-- End Cloudflare Web Analytics -->\n\n\n          </main>\n        </div>\n\n      <footer>\n        <div class=\"wrapper\">\n          <p>Subscribe to the newsletter for more like this:</p>\n          <form class=\"inline-form\" action=\"https://educatedguesswork-subscribe.herokuapp.com/subscribe\" method=\"post\">\n  <input type=\"email\" placeholder=\"Your e-mail address...\" id=\"email\" name=\"email\">\n  <button class=\"subscribe-button\">Subscribe</button>\n</form>\n\n\n          </div>\n      </footer>\n    </div>\n    <!-- Current page: /posts/messaging-discovery/ -->\n  </body>\n</html>\n","oembed":false,"readabilityObject":{"title":"Discovery Mechanisms for Messaging and Calling Interoperability","content":"<div id=\"readability-page-1\" class=\"page\"><div>\n          <main>\n            \n<div>\n    <article>\n        <p>New phone, who dis?\n        </p>\n\n        <p>As I discussed in an <a href=\"/posts/messaging-e2e\">earlier post</a>, it looks like the EU [<em>corrected an embarassing typo that had this as UK</em> -- EKR]\nDigital Markets Act (DMA) is going to require\n<a href=\"(https://www.ianbrown.tech/wp-content/uploads/2022/03/Final-DMA-interoperability-text.pdf)\">interoperability</a>\nbetween messaging systems. That previous post focused on how to\nestablishing end-to-end encryption between messaging systems.\nIn this post I want to talk about the problem of discovering\nwhich messaging system someone is on.</p>\n<h2 id=\"identifier-portability\">Identifier Portability <a href=\"#identifier-portability\">#</a></h2>\n<p>Many messaging systems bootstrap\noff of existing identifiers in the form of of phone numbers\n(jargon: <a href=\"https://en.wikipedia.org/w/index.php?title=E.164&amp;oldid=1092734805\">\"E.164 number\"</a>).\nPhone numbers are <a href=\"/posts/messaging-e2e/#telephone-addressing\">structured</a>,\nwhich means that when you place a call over the\n<em>Public Switched Telephone Network (PSTN)</em>\nit incrementally routes the call via the country,\narea code, etc., but from the perspective of a messaging system, they are <em>opaque</em>\nand <em>unstructured</em>, which is to say that\nthe identifier <code>+1.415.555.0123</code> might be for a user who is\non iMessage, WhatsApp, or even both. If all I have is someone's\nphone number, how do I know which service to reach them on?</p>\n<div>\n<h4 id=\"phone-numbers-as-a-shared-namespace\">Phone numbers as a shared namespace <a href=\"#phone-numbers-as-a-shared-namespace\">#</a></h4>\n<p>Phone numbers weren't originally designed to be a single\nnamespace that was shared between carriers, but rather\nas a single namespace to be used by a single carrier,\nthe Bell System (motto: \"One Policy, One System, Universal Service\").\nEven then, numbers were structured, but the structure\nrepresented the topology of the system so that you\ncould incrementally route calls. For instance, you could use the\narea code to direct traffic to the right region followed by the\nlocal office code to direct it to the right switch, and then\ndown to the right subscriber line.</p>\n<p>When the Bell System was <a href=\"https://en.wikipedia.org/w/index.php?title=Breakup_of_the_Bell_System&amp;oldid=1098874467\">broken up</a>\nthe breakup was done along geographic lines into\nwhat were called <em>Regional Bell Operating Companies (RBOCs)</em>. Because\nthe topology of the system was also roughly geographic—unlike,\nsay, the Internet, where number prefixes\ndo not really correspond to geographic regions—you\ncould at least roughly align the RBOC boundaries with the\nnumber structure.\nHowever, subsequently jurisdictions started to require\n<a href=\"https://en.wikipedia.org/w/index.php?title=Local_number_portability&amp;oldid=1077125532\">Local Number Portability</a>, which allowed you to take your number from carrier to carrier.\nThus, even if you were originally assigned a number out of Verizon's\nblock, you could \"port\" it to T-Mobile, with the result that you\nhave a shared namespace.</p>\n</div>\n<p>One possibility would be to simply sidestep this question\nby having identifiers be scoped, either by having people say\n\"connect with me on WhatsApp at <code>1.415.555.0123</code>\" or by\njust adding an explicit scoping parameter, so your address\nis <code>1.415.555.0123@whatsapp.com</code> (see <a href=\"/posts/messaging-e2e/#identity\">here</a> for\nmore on this).\nThis is how e-mail works and\nisn't the worst thing in the world, but does make it more\ncomplicated to contact someone else if all you have is their\nnumber, as well as making things confusing if they change\ntheir preferred app.\nBy contrast, phone numbers are <em>portable</em> across carriers,\nwhich is to say that if you move from T-Mobile to Verizon\nyou get to keep your phone number, and I don't need to\nknow what carrier you have in order to call you: I just enter\nthe phone number. This is implemented by having a giant—well, not really\nthat giant, as the entire US number space is less than 10 billion numbers and so\nbasically fits on a USB stick<sup><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>—<a href=\"https://www.nationalnanpa.com/\">database</a>\nthat knows which carrier is responsible for each number.\nWhen you want to call someone, your carrier checks this\ndatabase (technical term: \"dip\") to see where to route\nthe call.</p>\n<p>So, what if you want to have this same property for instant\nmessaging or video calling systems? This actually turns\nout to be surprisingly complicated.</p>\n<h2 id=\"phone-number-based-addressing-for-single-applications\">Phone Number-Based Addressing for Single Applications <a href=\"#phone-number-based-addressing-for-single-applications\">#</a></h2>\n<p>Before trying to solve the problem of routing between\napplications who use phone number-based addresses, it's\nuseful to look at the simpler problem of a single application\nthat uses phone numbers as addresses (e.g., WhatsApp).\nInstead of using the number portability database,\nwhich doesn't really have the information you need\nhere, these devices bootstrap authentication off of\nSMS.</p>\n<div>\n<h4 id=\"how-does-the-pstn-authenticate-you%3F\">How does the PSTN authenticate you? <a href=\"#how-does-the-pstn-authenticate-you%3F\">#</a></h4>\n<p>You might be wondering how the PSTN knows which\nnumber is associated with a given device. Back in the\ndays of landline phones, the answer was simple:\neach subscriber had their own literal line. I.e.,\nthere was a separate pair of copper wires that went\nfrom the central office to the subscriber's house and\nthe switch knew which pair of wires went with each\nnumber.</p>\n<p>Obviously this doesn't work with mobile phones. Instead,\neach phone has its own cryptographic key which it uses\nto authenticate to the network. When your number is\nassigned to you, that key is then associated with the\nnumber in the carrier's database. In modern phones,\nthat key is generally stored in a <a href=\"https://en.wikipedia.org/w/index.php?title=SIM_card&amp;oldid=1100219575\">Subscriber Interface Module (SIM)</a>,\nwhich is a small chip embedded in a plastic card:</p>\n<p><img width=\"200\" src=\"/img/sim-card.jpg\" alt=\"SIM card\"></p><p>[From Wikipedia]</p>\n<p>The SIM card is actually what gives your phone its identity,\nand if you swap SIM cards between devices, you will also\nswap their numbers.</p>\n</div>\n<ol>\n<li>\n<p>The app prompts you for a password and your phone number.</p>\n</li>\n<li>\n<p>The service then sends you an SMS message with\na random code.</p>\n</li>\n<li>\n<p>You enter that code into the app's user interface.</p>\n</li>\n</ol>\n<p>This demonstrates that you can receive messages at the indicated\nphone number.<sup><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<p>This authentication mechanism relies on the assumption that\nthe PSTN correctly routes messages to the right\nlocation and that nobody else can read them. When you\nthink about it, this is actually a bit of an odd assumption to make\nat the time you are installing a messaging application that\noffers stronger security than SMS, but that's actually\na surprisingly common scenario: certificate issuance on the\nWeb relies on the weak security properties provided by\nunencrypted DNS to bootstrap up to TLS, after which the\nDNS no longer needs to be trusted.</p>\n<p>The general concept\nhere is that you only trust the weaker system once\nto form the initial association\nand from then on you have strong continuity of\nauthentication (in some systems,\nthis is known as <a href=\"https://en.wikipedia.org/w/index.php?title=Trust_on_first_use&amp;oldid=1085537067\">Trust On First Use (TOFU)</a>).\nIn both cases, you\ncan build supplementary mechanisms like Certificate\n<a href=\"https://certificate.transparency.dev/\">Certificate Transparency</a>\nor <a href=\"https://transparency.dev/application/strengthen-discovery-of-encryption-keys/\">Key Transparency</a> to detect mississuance.</p>\n<p>One natural question to ask is why the app can't just ask\nthe device, which, after all, knows its own phone number.\nThe problem is that the device can't be trusted. Remember\nthat what we are trying to do is to convince the <em>service</em>\nthat a given device is associated with this number, and\neven though the service wrote the app in question, it's very\n<a href=\"/verifying-software/\">difficult for them to determine</a>\nthat an attacker hasn't modified the app to lie about its number.\nThe SMS verification mechanism doesn't have this problem;\nbecause it actually checks that you can receive messages,\nit works even if the device and the code running on it are\ntotally untrusted.</p>\n<p>It's easier to see the trust relationships if we look at\nwhat's really happening, as shown in the diagram below:</p>\n<p><img src=\"/img/phone-number-auth.png\" alt=\"Phone number verification via SMS\"></p>\n<p>In the first phase, the user is interacting with the\napplication, which is what collects the password and the\nphone number and sends them to the server. The server\nthen sends the code through the phone network to\nthe <em>device</em>. The device shows it to the user, who then\ngives it to the app. The app then sends it back to the\nserver, which is then able to confirm the code and\nverify the account. Importantly, even though the server\nis sending the code to the app (via the user)\nthe SMS channel to the phone  is <em>out of band</em> from the app's connection to\nthe server. In fact, they may even be using different\ntechnology; for instance, if you are on WiFi, then the\nconnection to the server will use that radio even though\nthe SMS comes in over the mobile telephony network.\nEven if all the data is going over the mobile channel,\nthe IP communications from the app aren't strongly\nbound to your phone number.</p>\n<p>Note that even if you don't trust the answer, if you could\nask the device for its number, you could still\nskip prompting the user. However, the number\nmay not be available. Apple's\nsecurity and privacy policies <a href=\"https://stackoverflow.com/questions/193182/programmatically-get-own-phone-number-in-ios\">forbid</a> this (presumably for privacy reasons) though it appears to be\n<a href=\"https://stackoverflow.com/questions/2480288/programmatically-obtain-the-phone-number-of-the-android-phone\">possible</a> on Android. For similar security reasons,\nthe app can't just reach into your SMSes—which are received\nby the operating system—and grab the confirmation code,\nas this would allow it to read any SMS.<sup><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>\nThe exception here is iMessage, which uses similar techniques\nto verify the phone number, but because it ships as part\nof the operating system is able to do so silently, even\nthough Apple doesn't permit other apps to do so.</p>\n<p>Once the service has associated the user's account with their\nphone number, the rest of the system is fairly straightforward\nthe app connects and authenticates as the user and the service\njust routes messages/calls to the user; no further interaction\nwith the PSTN is required. It is worth noting, however, that\nthis has some funny results if the phone number is ever\nreassigned because the service won't be notified. The result\ncan be that Alice has an account on some service for a\nnumber that has been reassigned to Bob. It's hard to avoid\nthis situation with this kind of loose service coupling,\nbut of course it's not unique to the Internet: I still\nget paper mail addressed to the people who lived in my house\nover 20 years ago.</p>\n<h2 id=\"phone-number-based-addressing-for-multiple-applications\">Phone Number-Based Addressing for Multiple Applications <a href=\"#phone-number-based-addressing-for-multiple-applications\">#</a></h2>\n<p>The basic situation isn't that different when different users\nuse different apps, except that you not only need to determine which\ndevice is associated with a given user but also which app they\nare using. As a simplification, let's assume that everyone\njust uses a single app (analogous to the situation with\nmobile phones where each subscriber just has a single carrier);\nWe'll look at the multi-app situation <a href=\"#multiple-apps-per-user\">below</a>.</p>\n<p>Consider the following three users:</p>\n<table>\n<thead>\n<tr>\n<th>User</th>\n<th>App</th>\n<th>Number</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Alice</td>\n<td><strong>A</strong></td>\n<td>1.650.555.0011<sup><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup></td>\n</tr>\n<tr>\n<td>Bob</td>\n<td><strong>B</strong></td>\n<td>1.415.555.0022</td>\n</tr>\n<tr>\n<td>Charlie</td>\n<td><strong>A</strong></td>\n<td>1.510.555.0033</td>\n</tr>\n</tbody>\n</table>\n<p>What happens if Alice gets Bob's number and wants to contact him in\nApp <strong>A</strong>? The obvious thing would be for Alice to just SMS\nBob and ask \"which app are you using?\" She could then tell\n<strong>A</strong> to contact \"1.415.55.0022 via app <strong>B</strong>\"\n(assuming that <strong>A</strong> and <strong>B</strong>) can already talk to each\nother as discussed in my <a href=\"/posts/messaging-e2e\">earlier post</a>).\nThis will work but it's clumsy and inconvenient; what you want\nis for Alice to put Bob's number into app <strong>A</strong> and for <strong>A</strong> to figure\nthings out. Unfortunately, this doesn't appear to be something that <strong>A</strong> can do\non its own; rather, we need some additional infrastructure.</p>\n<p>I'm aware of two major designs here. In the first design, you have\na directory service which knows which number is associated with\nwhich app. In the second design, each user—or rather their\napp—has to discover it out for itself.</p>\n<h3 id=\"directory-services\">Directory Services <a href=\"#directory-services\">#</a></h3>\n<p>The obvious way to approach this is just to use the same approach as\nfor number portability, i.e., to have some sort of global directory\nservice that tells you which app to use for each number.</p>\n<p>It's possible you could directly integrate it with the\nexisting PSTN databases, but that's probably going to be a lot of work and it's\nprobably easier to just use the same kind of SMS verification we\ndiscussed in the previous section. For instance, suppose you had a\nsingle global directory service. When you installed the app you would\nprove possession of your number to the directory service which\nwould then create a record mapping your number to the app you\nwere using. This directory can then be queried by other people,\nas shown in the diagram below.</p>\n<p><img src=\"/img/phone-number-service.png\" alt=\"A simple phone number service\"></p>\n<p><em>[Update: fixed diagram -- 2022-08-04]</em></p>\n<p>In this example, Alice installs app <strong>A</strong>, which automatically\ncontacts the directory and proves possession of her number. The\ndirectory then creates a record mapping her number to app <strong>A</strong>.<sup><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup>\nWhen Bob wants to contact Alice, he puts her number into\napp <strong>B</strong>, which contacts the directory and finds out that\nAlice uses <strong>A</strong>. <strong>B</strong> then uses whatever interoperability\nmechanism it has with <strong>A</strong> to establish communication.</p>\n<p>This system is obviously massively oversimplified. If we wanted\nto build something real, we'd need to address some important design\nquestions and fix some—as-yet-unsolved—privacy\nissues.</p>\n<h4 id=\"authentication\">Authentication <a href=\"#authentication\">#</a></h4>\n<p>The first question we'd need to address is the authentication\nstructure. In the design I sketched above, the directory service is\nsolely responsible for knowing which app a given number is associated\nwith, but <em>not</em> for authenticating the user. For instance, if Alice\nand Charlie both use app <strong>A</strong> then when Bob tries to call Alice,\n<strong>A</strong> can redirect the call to Charlie. Of course, <strong>A</strong> might run\nsome kind of certificate/key transparency type of system to prevent\nthis kind of attack, but that requires every app to engage with that.</p>\n<p>Note that the reverse is also true: when Bob calls Alice, Alice is\nrelying on <strong>B</strong>'s representation that it's really Bob, and <strong>B</strong> can\nlie. Moreover, it's important for Alice to check the directory to make\nsure that Bob's number is actually associated with <strong>B</strong>. Otherwise,\nservice <strong>C</strong> could just claim to be speaking for Bob even if he's not\na user of app <strong>C</strong> at all.</p>\n<p>An alternate approach would be to have a global authentication\nsystem in which the directory issues a credential to each user\nbinding their number to whatever cryptographic credentials their\napp uses (effectively, this is a certificate authority for\nphone numbers). In this case, it wouldn't be possible for\nan app to lie about user, though of course we now\nhave to trust the directory. The advantage of this design\nwould be that you only have to trust one thing and maybe\nyou could have better auditing and transparency\nfor a global service.</p>\n<p>It's also possible to run both kinds\nof systems simultaneously, where each app uses its own\nauthentication system internally but also is able to make\nuse of a global credential system. This allows for innovation\ninside an app but also provides interoperability.</p>\n<h4 id=\"centralization\">Centralization <a href=\"#centralization\">#</a></h4>\n<p>Another problem with this design is that it seems to require\na centralized directory service, or at best a small number of\nsuch services. The basic invariant here is that you need\na procedure that takes in a number and outputs the app it's\nassociated with. The easiest way to do that is to have a\nsingle service. Perhaps if there were only a small number\nof apps you could check them individually but if there\nare tens or hundreds it's a real scalability problem (and may also be\na privacy problem, as discussed below).</p>\n<div>\n<h4 id=\"enum\">ENUM <a href=\"#enum\">#</a></h4>\n<p>For the real nerds here, there is actually an RFC documenting\na less centralized design rooted in the DNS called <a href=\"https://datatracker.ietf.org/doc/html/rfc6116\">ENUM</a>.\nThe idea was that you would store records in the DNS under your phone number\n(hilariously, reversed, because phone numbers read left to right and DNS addresses\nread right to left), so you might have <code>8.4.1.0.6.4.9.7.0.2.4.4.e164.arpa.</code>.\nThis never took off for a host of reasons, and I don't think it's\nreally a viable option here because it requires DNS delegations\nto match the phone number structure, which seems like a lot of\nwork for everyone involved.</p>\n</div>\n<p>There are really two objections here: one about deployability\nand one about network architecture. The deployability objection\nis that someone has to run the service and that has to be paid\nfor, so who is going to do that. I tend to think that this isn't\nthat big an issue: this really isn't that big a service by modern\nstandards, and we have a reference point for what it costs to\nrun something similar in the form of Let's Encrypt, which\nhas a budget of around <a href=\"https://projects.propublica.org/nonprofits/organizations/463344200\">6 million dollars</a>,\nwith the costs scaling sublinearly. The whole premise of the\nsituation is that companies like Apple and Facebook will\nbe required to interoperate, and against that background,\nthis isn't really that much money.</p>\n<p>I take the network architecture objection more seriously:\nyet another centralized service isn't great for the Internet.\nI think there are some ways to make it somewhat less\ncentralized, for instance by having each app maintain\nits own mirror of the database, but at the end of the day\nthere's a tradeoff here between the good of interoperability—assuming\nyou think it is good—and the bad of centralization.\nI tend to think that the balance is in favor of interoperability\nbut it's not a slam dunk, especially if you think that there\nare other architectures that would do a better job (see <a href=\"#spin\">below</a>).</p>\n<h4 id=\"privacy\">Privacy <a href=\"#privacy\">#</a></h4>\n<p>Probably the biggest issue with this design is that it has\nsome fairly unfortunate privacy properties. Specifically\nin the naive version of this design:</p>\n<ul>\n<li>\n<p>The directory service gets to see which app(s) a given\nphone number is associated with.</p>\n</li>\n<li>\n<p>It's possible for ordinary users to scrape the directory\nservice and learn which app(s) a given user is associated\nwith.</p>\n</li>\n<li>\n<p>The directory server gets to see every lookup\nand so be able to learn who is trying to connect with who.\n(This is even worse if the user has to try every possible app)</p>\n</li>\n</ul>\n<p>It's probably possible to address some of these issues, though it's not immediately\nobvious that they can be completely fixed. The rest of this section\ncontains some handwaving in the direction of potential solutions.\nI just came up with these recently, so don't blame me if they\nare horrifically broken.</p>\n<p>The last one is probably the easiest, as there are a number of\nreasonably efficient <a href=\"https://en.wikipedia.org/w/index.php?title=Private_information_retrieval&amp;oldid=1068898272\">private information\nretrieval (PIR)</a>\nschemes for allowing a client to retrieve a single value from a server\nwithout disclosing the value to the server. So, if we just\nrequire those values to be retrieved over PIR (or even over\na proxy!), we can probably provide some kind of privacy\nfor who is connecting to who.</p>\n<p>Similarly, I think it's probably possible to prevent large-scale\nscraping of user data by clients. This is a pretty typical\nrate limiting problem and it's already a problem existing apps have\nto face, so we could probably apply similar techniques here.\nThis doesn't do much to prevent learning about a single individual,\nthough, for instance, suppose I want to know if someone is on\nWhatsApp. There seems to be an inherent tension here between allowing\nseamless discovery and connection and providing privacy in this\ncase, so I'm not sure if it's really soluble at the end of the\nday.</p>\n<p>The best idea I have for the directory service getting to\nsee which apps a given number is associated with is to split\nup the data between two servers. The idea would be that you would have two directory\nservers operated by unaffiliated entities. The client would then\nprove its identity to both servers (as above) and this would\ngive it a credential that it could use to authenticate to that\nserver. It would then take encrypt its app identity and send the\nkey to one server and the encrypted value to the other. Then\nwhen someone wanted to contact you, they would contact both\nservers and reconstruct the original value, as shown below<sup><a href=\"#fn6\" id=\"fnref6\">[6]</a></sup></p>\n<p><img src=\"/img/phone-number-split.png\" alt=\"Split storage for records\"></p>\n<p><em>[Update: fixed diagram --2022-08-04]</em></p>\n<p>This stops the servers from being able to access the entire database,\nthough you still need to worry about scraping attacks, either\nagainst both servers or by one against the other, so it's not\nperfect.</p>\n<h3 id=\"spin\">SPIN <a href=\"#spin\">#</a></h3>\n<p>Recently,\n<a href=\"https://www.jdrosen.com/\">Jonathan Rosenberg</a>,\n<a href=\"https://www.linkedin.com/in/cullen/\">Cullen Jennings</a>,\n<a href=\"https://alissacooper.com/\">Alissa Cooper</a>,\nand <a href=\"http://playingattheworld.blogspot.com/\">Jon Peterson</a>—a group of\nheavy hitters in real time communications if there ever was one—published\nan <a href=\"https://www.ietf.org/archive/id/draft-rosenberg-dispatch-spin-00.html\">alternative design called SPIN</a>\nfor this problem. The idea is to replace the centralized server by having\neach client do its own phone number mapping via SMS. I.e., when Alice<br>\nwants to contact Bob, her device sends an SMS to Bob's device (again,\nwith some unpredictable random value). Bob's device responds with the app(s)\nthat Bob supports and perhaps with his identities on those apps.\nThe reasoning here is the same as with the directory service: only\nsomeone who could receive SMS at Bob's number could complete the\nchallenge, so you must be talking to Bob.</p>\n<p>Of course, this leaves us with the problem of Bob knowing who is calling,\nbecause Alice just asserts her number. One way to address this would\nbe for Bob to issue a challenge in the opposite direction,\nbut this isn't actually what SPIN does. Instead it assumes that Alice\nhas obtained a credential—presumably using a similar\nissuance process to the one I indicated above—that she\nuses to sign her message to Bob, but that's a design choice.\nIf you wanted to entirely eliminate centralized infrastructure\nyou could certainly do that, and that's an obvious selling\npoint of SPIN. Even with this kind of hybrid design, the\ndirectory service doesn't need to be available for query\nand so you don't have the privacy problems I discussed above\n(it also isn't in the critical path for calls, but availability\nof this kind of server system seems like a mostly solved\nproblem at this point).</p>\n<p>Of course, the SPIN design has a number of drawbacks (in fact,\nI originally started thinking about this problem because I read\nthe draft and I wanted to try to fix them).</p>\n<h4 id=\"offline-access\">Offline Access <a href=\"#offline-access\">#</a></h4>\n<p>With SPIN, you can't really do discovery of anyone who isn't online at the\nsame time as you (more precisely, it just stalls until they are\nonline and you can get the return message).\nThis isn't necessarily <em>that</em> big an issue for\nreal-time calls because if someone isn't online then you're not\ngoing to be able to call them anyway (though there's voicemail) but\nit's a big issue for instant messaging, which is inherently\nasynchronous. Jonathan Rosenberg\n<a href=\"https://mailarchive.ietf.org/arch/msg/dispatch/CFFoX9vNXthejIPGpmLf_pmY01Y/\">argues</a>\nthat mobile devices are basically always connected.  I'm not sure\nthat this is really true, but if you want to extend to systems\nwhich have e-mail style identifiers, then those may be on desktop\nnot mobile devices, so this is a drawback.\nThis isn't an issue for the directory service design: once\na user has registered with the directory service then anyone\ncan do a lookup whether you are offline or not.</p>\n<p>One partial mitigation for this might be for the operator of\neach app to record (cache) phone number validations as they\nhappen, so that they gradually learn some of the mappings\nand can resolve them immediately. For instance, once\nAlice (on service <strong>A</strong>) has discovered that Bob is on service <strong>B</strong>,\nif Charlie (also on service <strong>A</strong>) can learn this information\nfrom <strong>A</strong> without a new verification stage.\nThis has the advantage that it's \"soft state\" in that things work without it,\nbut the disadvantage that some things work and some don't.</p>\n<h4 id=\"it-(mostly)-requires-changing-the-operating-system\">It (mostly) requires changing the operating system <a href=\"#it-(mostly)-requires-changing-the-operating-system\">#</a></h4>\n<p>Because the SPIN design involves every client doing its own phone\nnumber verification, people are going to get a lot of SMS messages\nrequiring them to verify, which is annoying. SPIN expects to\naddress this by having the device operating system absorb the\nmessages and respond for you so the user doesn't see them.\nThis isn't necessarily a bad idea, but it's kind of ugly and\nmeans that people with older operating systems will have a bad\nexperience.</p>\n<p>Again, this isn't an issue with the directory service version\nbecause apps can just register themselves. That version <em>does</em>\nwork better if the operating system helps out with SMS verification,\nbut even in the worst case the user is just bothered once for\neach app they use, not for each person who wants to call them.</p>\n<h4 id=\"attack-resistance\">Attack Resistance <a href=\"#attack-resistance\">#</a></h4>\n<p>As noted above, SMS routing in the PSTN isn't really that\nsecure, and so you have to worry about misissuance. One way\nto mitigate this is to have the results of verification\npublished in a transparency log. This allows everyone to see\nwhich credentials have been assigned to each number and\npotentially detect misissuance. This works fine in a directory\nservice type system but in a system where each user does their\nown verification, you might run into a scenario where an\nattacker hijacked just the connection between Alice and Bob\nbut not between Charlie and Bob. This would need some fancier\nmechanisms to detect, though we could probably design\nsomething.</p>\n<h4 id=\"privacy-2\">Privacy <a href=\"#privacy-2\">#</a></h4>\n<p>As noted above, the privacy situation is largely better without\na centralized server, but there's still an issue around probing\nfor individual user information. I.e., Alice wants to know\nwhich app(s) Bob has and so sends an SMS and looks at the results.\nOne way to address this is for Bob to have some logic that runs\non the device that determines whether to answer the query—perhaps\ndepending on whether Alice's number is in the contact list—though\nit's not clear how easy that is to configure.<sup><a href=\"#fn7\" id=\"fnref7\">[7]</a></sup></p>\n<h3 id=\"multiple-apps-per-user\">Multiple Apps Per User <a href=\"#multiple-apps-per-user\">#</a></h3>\n<p>Multiple apps are a pretty straightforward extension to either of these\nsystems. In both cases, you can basically think of the system as\npublishing a \"record\" attached to the phone number. I've implicitly\nassumed that the record would contain a single app, but there's no\ntechnical reason why they can't contain a list of apps (this is slightly\nmore complicated in the directory service version for cryptographic\nreasons, but not really that hard).</p>\n<p>The situation for the initiator is somewhat more complicated: I'm\nusing app <strong>A</strong> and I want to call someone and learn that they\nhave apps <strong>B</strong> and <strong>C</strong>. What now? Presumably each app is going\nto have a priority list of apps it would prefer to interoperate\nwith (favoring itself!) and will just pick the top one. But this\ncan lead to some obvious problems, such as: will you get the same\napp in each direction? What happens if someone installs a new\napp that is more preferred? These aren't strictly discovery problems\nbut are definitely ergonomics issues that apps will need to work out\nsomehow.</p>\n<h2 id=\"final-thoughts\">Final Thoughts <a href=\"#final-thoughts\">#</a></h2>\n<p>Obviously this is a difficult problem without a single great solution.\nI <em>do</em> think it's possible to come up with something reasonably good here, especially\nif we're willing to make some technical compromises. That's a\nlot more likely if there really will be a requirement to interoperate;\nwhile there are real technical problems, many of the problems\nare around incentives (e.g., why should I run a server so some people\ncan talk to my users?) and regulation provides those incentives.</p>\n<p>This problem would be vastly easier\nif the addresses people were using had been structured from the very beginning: as an\nexample, e-mail addresses already consist of a user portion and a domain\nportion, and so it's easy to know where to route any given message.\nBut because instant messaging addresses are largely opaque, you're\nstuck with clumsier solutions. On the other hand, most e-mail addresses\naren't portable—you can't take <code>example@gmail.com</code> over to Hotmail—so\nif you ever wanted that you'd be back in the soup. To the best of my knowledge\nthere's no real way to have address portability without some kind of\nrouting database, either an explicit one like the DNS or my directory service,\nor an implicit one like the PSTN fabric that powers SMS verification.</p>\n<hr>\n<section>\n<ol>\n<li id=\"fn1\"><p>\nYou can now buy 128 GB flash\ndrives, so this gives us 12 bytes per record. <a href=\"#fnref1\">↩︎</a></p>\n</li>\n<li id=\"fn2\"><p>\nNote that it <em>does not</em> demonstrate that this device is\nassociated with that number. For instance, you could\nhave two devices, one of which is associated with that\nnumber and one of which you are installing the device on. <a href=\"#fnref2\">↩︎</a></p>\n</li>\n<li id=\"fn3\"><p>\nYes, it's possible to design a system that doesn't\nrequire full SMS access, but that's not how these\nAPIs work. <a href=\"#fnref3\">↩︎</a></p>\n</li>\n<li id=\"fn4\"><p>See <a href=\"https://en.wikipedia.org/w/index.php?title=555_(telephone_number)&amp;oldid=1101658698\">here</a> for why I am using 555 numbers. <a href=\"#fnref4\">↩︎</a></p>\n</li>\n<li id=\"fn5\"><p>\nIn a real system, we'd probably want to prevent malicious\napps on Alice's phone from registering for another app,\nin what's called an \"identity misbinding\" attack, but\nI'm ignoring that here. <a href=\"#fnref5\">↩︎</a></p>\n</li>\n<li id=\"fn6\"><p>\nUpdate 2022-08-04:\nYou could also use secret sharing, but encryption has\nthe advantage that if the record you want to store is\nlarge then the total size is smaller. <a href=\"#fnref6\">↩︎</a></p>\n</li>\n<li id=\"fn7\"><p>\nIt might be possible to replicate this functionality in the\ndirectory service model. Naively, Bob could just upload the\nalgorithm for which numbers to answer for, but this has its\nown privacy problems because it leaks Bob's contact list to the service.\nThere may be some fancy cryptographic solution that addresses\nall these privacy problems at once, but I don't have it\nin my pocket. <a href=\"#fnref7\">↩︎</a></p>\n</li>\n</ol>\n</section>\n\n    </article>\n\n    \n      \n  </div>\n\n<!-- Cloudflare Web Analytics --><!-- End Cloudflare Web Analytics -->\n\n\n          </main>\n        </div></div>","textContent":"\n          \n            \n\n    \n        New phone, who dis?\n        \n\n        As I discussed in an earlier post, it looks like the EU [corrected an embarassing typo that had this as UK -- EKR]\nDigital Markets Act (DMA) is going to require\ninteroperability\nbetween messaging systems. That previous post focused on how to\nestablishing end-to-end encryption between messaging systems.\nIn this post I want to talk about the problem of discovering\nwhich messaging system someone is on.\nIdentifier Portability #\nMany messaging systems bootstrap\noff of existing identifiers in the form of of phone numbers\n(jargon: \"E.164 number\").\nPhone numbers are structured,\nwhich means that when you place a call over the\nPublic Switched Telephone Network (PSTN)\nit incrementally routes the call via the country,\narea code, etc., but from the perspective of a messaging system, they are opaque\nand unstructured, which is to say that\nthe identifier +1.415.555.0123 might be for a user who is\non iMessage, WhatsApp, or even both. If all I have is someone's\nphone number, how do I know which service to reach them on?\n\nPhone numbers as a shared namespace #\nPhone numbers weren't originally designed to be a single\nnamespace that was shared between carriers, but rather\nas a single namespace to be used by a single carrier,\nthe Bell System (motto: \"One Policy, One System, Universal Service\").\nEven then, numbers were structured, but the structure\nrepresented the topology of the system so that you\ncould incrementally route calls. For instance, you could use the\narea code to direct traffic to the right region followed by the\nlocal office code to direct it to the right switch, and then\ndown to the right subscriber line.\nWhen the Bell System was broken up\nthe breakup was done along geographic lines into\nwhat were called Regional Bell Operating Companies (RBOCs). Because\nthe topology of the system was also roughly geographic—unlike,\nsay, the Internet, where number prefixes\ndo not really correspond to geographic regions—you\ncould at least roughly align the RBOC boundaries with the\nnumber structure.\nHowever, subsequently jurisdictions started to require\nLocal Number Portability, which allowed you to take your number from carrier to carrier.\nThus, even if you were originally assigned a number out of Verizon's\nblock, you could \"port\" it to T-Mobile, with the result that you\nhave a shared namespace.\n\nOne possibility would be to simply sidestep this question\nby having identifiers be scoped, either by having people say\n\"connect with me on WhatsApp at 1.415.555.0123\" or by\njust adding an explicit scoping parameter, so your address\nis 1.415.555.0123@whatsapp.com (see here for\nmore on this).\nThis is how e-mail works and\nisn't the worst thing in the world, but does make it more\ncomplicated to contact someone else if all you have is their\nnumber, as well as making things confusing if they change\ntheir preferred app.\nBy contrast, phone numbers are portable across carriers,\nwhich is to say that if you move from T-Mobile to Verizon\nyou get to keep your phone number, and I don't need to\nknow what carrier you have in order to call you: I just enter\nthe phone number. This is implemented by having a giant—well, not really\nthat giant, as the entire US number space is less than 10 billion numbers and so\nbasically fits on a USB stick[1]—database\nthat knows which carrier is responsible for each number.\nWhen you want to call someone, your carrier checks this\ndatabase (technical term: \"dip\") to see where to route\nthe call.\nSo, what if you want to have this same property for instant\nmessaging or video calling systems? This actually turns\nout to be surprisingly complicated.\nPhone Number-Based Addressing for Single Applications #\nBefore trying to solve the problem of routing between\napplications who use phone number-based addresses, it's\nuseful to look at the simpler problem of a single application\nthat uses phone numbers as addresses (e.g., WhatsApp).\nInstead of using the number portability database,\nwhich doesn't really have the information you need\nhere, these devices bootstrap authentication off of\nSMS.\n\nHow does the PSTN authenticate you? #\nYou might be wondering how the PSTN knows which\nnumber is associated with a given device. Back in the\ndays of landline phones, the answer was simple:\neach subscriber had their own literal line. I.e.,\nthere was a separate pair of copper wires that went\nfrom the central office to the subscriber's house and\nthe switch knew which pair of wires went with each\nnumber.\nObviously this doesn't work with mobile phones. Instead,\neach phone has its own cryptographic key which it uses\nto authenticate to the network. When your number is\nassigned to you, that key is then associated with the\nnumber in the carrier's database. In modern phones,\nthat key is generally stored in a Subscriber Interface Module (SIM),\nwhich is a small chip embedded in a plastic card:\n[From Wikipedia]\nThe SIM card is actually what gives your phone its identity,\nand if you swap SIM cards between devices, you will also\nswap their numbers.\n\n\n\nThe app prompts you for a password and your phone number.\n\n\nThe service then sends you an SMS message with\na random code.\n\n\nYou enter that code into the app's user interface.\n\n\nThis demonstrates that you can receive messages at the indicated\nphone number.[2]\nThis authentication mechanism relies on the assumption that\nthe PSTN correctly routes messages to the right\nlocation and that nobody else can read them. When you\nthink about it, this is actually a bit of an odd assumption to make\nat the time you are installing a messaging application that\noffers stronger security than SMS, but that's actually\na surprisingly common scenario: certificate issuance on the\nWeb relies on the weak security properties provided by\nunencrypted DNS to bootstrap up to TLS, after which the\nDNS no longer needs to be trusted.\nThe general concept\nhere is that you only trust the weaker system once\nto form the initial association\nand from then on you have strong continuity of\nauthentication (in some systems,\nthis is known as Trust On First Use (TOFU)).\nIn both cases, you\ncan build supplementary mechanisms like Certificate\nCertificate Transparency\nor Key Transparency to detect mississuance.\nOne natural question to ask is why the app can't just ask\nthe device, which, after all, knows its own phone number.\nThe problem is that the device can't be trusted. Remember\nthat what we are trying to do is to convince the service\nthat a given device is associated with this number, and\neven though the service wrote the app in question, it's very\ndifficult for them to determine\nthat an attacker hasn't modified the app to lie about its number.\nThe SMS verification mechanism doesn't have this problem;\nbecause it actually checks that you can receive messages,\nit works even if the device and the code running on it are\ntotally untrusted.\nIt's easier to see the trust relationships if we look at\nwhat's really happening, as shown in the diagram below:\n\nIn the first phase, the user is interacting with the\napplication, which is what collects the password and the\nphone number and sends them to the server. The server\nthen sends the code through the phone network to\nthe device. The device shows it to the user, who then\ngives it to the app. The app then sends it back to the\nserver, which is then able to confirm the code and\nverify the account. Importantly, even though the server\nis sending the code to the app (via the user)\nthe SMS channel to the phone  is out of band from the app's connection to\nthe server. In fact, they may even be using different\ntechnology; for instance, if you are on WiFi, then the\nconnection to the server will use that radio even though\nthe SMS comes in over the mobile telephony network.\nEven if all the data is going over the mobile channel,\nthe IP communications from the app aren't strongly\nbound to your phone number.\nNote that even if you don't trust the answer, if you could\nask the device for its number, you could still\nskip prompting the user. However, the number\nmay not be available. Apple's\nsecurity and privacy policies forbid this (presumably for privacy reasons) though it appears to be\npossible on Android. For similar security reasons,\nthe app can't just reach into your SMSes—which are received\nby the operating system—and grab the confirmation code,\nas this would allow it to read any SMS.[3]\nThe exception here is iMessage, which uses similar techniques\nto verify the phone number, but because it ships as part\nof the operating system is able to do so silently, even\nthough Apple doesn't permit other apps to do so.\nOnce the service has associated the user's account with their\nphone number, the rest of the system is fairly straightforward\nthe app connects and authenticates as the user and the service\njust routes messages/calls to the user; no further interaction\nwith the PSTN is required. It is worth noting, however, that\nthis has some funny results if the phone number is ever\nreassigned because the service won't be notified. The result\ncan be that Alice has an account on some service for a\nnumber that has been reassigned to Bob. It's hard to avoid\nthis situation with this kind of loose service coupling,\nbut of course it's not unique to the Internet: I still\nget paper mail addressed to the people who lived in my house\nover 20 years ago.\nPhone Number-Based Addressing for Multiple Applications #\nThe basic situation isn't that different when different users\nuse different apps, except that you not only need to determine which\ndevice is associated with a given user but also which app they\nare using. As a simplification, let's assume that everyone\njust uses a single app (analogous to the situation with\nmobile phones where each subscriber just has a single carrier);\nWe'll look at the multi-app situation below.\nConsider the following three users:\n\n\n\nUser\nApp\nNumber\n\n\n\n\nAlice\nA\n1.650.555.0011[4]\n\n\nBob\nB\n1.415.555.0022\n\n\nCharlie\nA\n1.510.555.0033\n\n\n\nWhat happens if Alice gets Bob's number and wants to contact him in\nApp A? The obvious thing would be for Alice to just SMS\nBob and ask \"which app are you using?\" She could then tell\nA to contact \"1.415.55.0022 via app B\"\n(assuming that A and B) can already talk to each\nother as discussed in my earlier post).\nThis will work but it's clumsy and inconvenient; what you want\nis for Alice to put Bob's number into app A and for A to figure\nthings out. Unfortunately, this doesn't appear to be something that A can do\non its own; rather, we need some additional infrastructure.\nI'm aware of two major designs here. In the first design, you have\na directory service which knows which number is associated with\nwhich app. In the second design, each user—or rather their\napp—has to discover it out for itself.\nDirectory Services #\nThe obvious way to approach this is just to use the same approach as\nfor number portability, i.e., to have some sort of global directory\nservice that tells you which app to use for each number.\nIt's possible you could directly integrate it with the\nexisting PSTN databases, but that's probably going to be a lot of work and it's\nprobably easier to just use the same kind of SMS verification we\ndiscussed in the previous section. For instance, suppose you had a\nsingle global directory service. When you installed the app you would\nprove possession of your number to the directory service which\nwould then create a record mapping your number to the app you\nwere using. This directory can then be queried by other people,\nas shown in the diagram below.\n\n[Update: fixed diagram -- 2022-08-04]\nIn this example, Alice installs app A, which automatically\ncontacts the directory and proves possession of her number. The\ndirectory then creates a record mapping her number to app A.[5]\nWhen Bob wants to contact Alice, he puts her number into\napp B, which contacts the directory and finds out that\nAlice uses A. B then uses whatever interoperability\nmechanism it has with A to establish communication.\nThis system is obviously massively oversimplified. If we wanted\nto build something real, we'd need to address some important design\nquestions and fix some—as-yet-unsolved—privacy\nissues.\nAuthentication #\nThe first question we'd need to address is the authentication\nstructure. In the design I sketched above, the directory service is\nsolely responsible for knowing which app a given number is associated\nwith, but not for authenticating the user. For instance, if Alice\nand Charlie both use app A then when Bob tries to call Alice,\nA can redirect the call to Charlie. Of course, A might run\nsome kind of certificate/key transparency type of system to prevent\nthis kind of attack, but that requires every app to engage with that.\nNote that the reverse is also true: when Bob calls Alice, Alice is\nrelying on B's representation that it's really Bob, and B can\nlie. Moreover, it's important for Alice to check the directory to make\nsure that Bob's number is actually associated with B. Otherwise,\nservice C could just claim to be speaking for Bob even if he's not\na user of app C at all.\nAn alternate approach would be to have a global authentication\nsystem in which the directory issues a credential to each user\nbinding their number to whatever cryptographic credentials their\napp uses (effectively, this is a certificate authority for\nphone numbers). In this case, it wouldn't be possible for\nan app to lie about user, though of course we now\nhave to trust the directory. The advantage of this design\nwould be that you only have to trust one thing and maybe\nyou could have better auditing and transparency\nfor a global service.\nIt's also possible to run both kinds\nof systems simultaneously, where each app uses its own\nauthentication system internally but also is able to make\nuse of a global credential system. This allows for innovation\ninside an app but also provides interoperability.\nCentralization #\nAnother problem with this design is that it seems to require\na centralized directory service, or at best a small number of\nsuch services. The basic invariant here is that you need\na procedure that takes in a number and outputs the app it's\nassociated with. The easiest way to do that is to have a\nsingle service. Perhaps if there were only a small number\nof apps you could check them individually but if there\nare tens or hundreds it's a real scalability problem (and may also be\na privacy problem, as discussed below).\n\nENUM #\nFor the real nerds here, there is actually an RFC documenting\na less centralized design rooted in the DNS called ENUM.\nThe idea was that you would store records in the DNS under your phone number\n(hilariously, reversed, because phone numbers read left to right and DNS addresses\nread right to left), so you might have 8.4.1.0.6.4.9.7.0.2.4.4.e164.arpa..\nThis never took off for a host of reasons, and I don't think it's\nreally a viable option here because it requires DNS delegations\nto match the phone number structure, which seems like a lot of\nwork for everyone involved.\n\nThere are really two objections here: one about deployability\nand one about network architecture. The deployability objection\nis that someone has to run the service and that has to be paid\nfor, so who is going to do that. I tend to think that this isn't\nthat big an issue: this really isn't that big a service by modern\nstandards, and we have a reference point for what it costs to\nrun something similar in the form of Let's Encrypt, which\nhas a budget of around 6 million dollars,\nwith the costs scaling sublinearly. The whole premise of the\nsituation is that companies like Apple and Facebook will\nbe required to interoperate, and against that background,\nthis isn't really that much money.\nI take the network architecture objection more seriously:\nyet another centralized service isn't great for the Internet.\nI think there are some ways to make it somewhat less\ncentralized, for instance by having each app maintain\nits own mirror of the database, but at the end of the day\nthere's a tradeoff here between the good of interoperability—assuming\nyou think it is good—and the bad of centralization.\nI tend to think that the balance is in favor of interoperability\nbut it's not a slam dunk, especially if you think that there\nare other architectures that would do a better job (see below).\nPrivacy #\nProbably the biggest issue with this design is that it has\nsome fairly unfortunate privacy properties. Specifically\nin the naive version of this design:\n\n\nThe directory service gets to see which app(s) a given\nphone number is associated with.\n\n\nIt's possible for ordinary users to scrape the directory\nservice and learn which app(s) a given user is associated\nwith.\n\n\nThe directory server gets to see every lookup\nand so be able to learn who is trying to connect with who.\n(This is even worse if the user has to try every possible app)\n\n\nIt's probably possible to address some of these issues, though it's not immediately\nobvious that they can be completely fixed. The rest of this section\ncontains some handwaving in the direction of potential solutions.\nI just came up with these recently, so don't blame me if they\nare horrifically broken.\nThe last one is probably the easiest, as there are a number of\nreasonably efficient private information\nretrieval (PIR)\nschemes for allowing a client to retrieve a single value from a server\nwithout disclosing the value to the server. So, if we just\nrequire those values to be retrieved over PIR (or even over\na proxy!), we can probably provide some kind of privacy\nfor who is connecting to who.\nSimilarly, I think it's probably possible to prevent large-scale\nscraping of user data by clients. This is a pretty typical\nrate limiting problem and it's already a problem existing apps have\nto face, so we could probably apply similar techniques here.\nThis doesn't do much to prevent learning about a single individual,\nthough, for instance, suppose I want to know if someone is on\nWhatsApp. There seems to be an inherent tension here between allowing\nseamless discovery and connection and providing privacy in this\ncase, so I'm not sure if it's really soluble at the end of the\nday.\nThe best idea I have for the directory service getting to\nsee which apps a given number is associated with is to split\nup the data between two servers. The idea would be that you would have two directory\nservers operated by unaffiliated entities. The client would then\nprove its identity to both servers (as above) and this would\ngive it a credential that it could use to authenticate to that\nserver. It would then take encrypt its app identity and send the\nkey to one server and the encrypted value to the other. Then\nwhen someone wanted to contact you, they would contact both\nservers and reconstruct the original value, as shown below[6]\n\n[Update: fixed diagram --2022-08-04]\nThis stops the servers from being able to access the entire database,\nthough you still need to worry about scraping attacks, either\nagainst both servers or by one against the other, so it's not\nperfect.\nSPIN #\nRecently,\nJonathan Rosenberg,\nCullen Jennings,\nAlissa Cooper,\nand Jon Peterson—a group of\nheavy hitters in real time communications if there ever was one—published\nan alternative design called SPIN\nfor this problem. The idea is to replace the centralized server by having\neach client do its own phone number mapping via SMS. I.e., when Alice\nwants to contact Bob, her device sends an SMS to Bob's device (again,\nwith some unpredictable random value). Bob's device responds with the app(s)\nthat Bob supports and perhaps with his identities on those apps.\nThe reasoning here is the same as with the directory service: only\nsomeone who could receive SMS at Bob's number could complete the\nchallenge, so you must be talking to Bob.\nOf course, this leaves us with the problem of Bob knowing who is calling,\nbecause Alice just asserts her number. One way to address this would\nbe for Bob to issue a challenge in the opposite direction,\nbut this isn't actually what SPIN does. Instead it assumes that Alice\nhas obtained a credential—presumably using a similar\nissuance process to the one I indicated above—that she\nuses to sign her message to Bob, but that's a design choice.\nIf you wanted to entirely eliminate centralized infrastructure\nyou could certainly do that, and that's an obvious selling\npoint of SPIN. Even with this kind of hybrid design, the\ndirectory service doesn't need to be available for query\nand so you don't have the privacy problems I discussed above\n(it also isn't in the critical path for calls, but availability\nof this kind of server system seems like a mostly solved\nproblem at this point).\nOf course, the SPIN design has a number of drawbacks (in fact,\nI originally started thinking about this problem because I read\nthe draft and I wanted to try to fix them).\nOffline Access #\nWith SPIN, you can't really do discovery of anyone who isn't online at the\nsame time as you (more precisely, it just stalls until they are\nonline and you can get the return message).\nThis isn't necessarily that big an issue for\nreal-time calls because if someone isn't online then you're not\ngoing to be able to call them anyway (though there's voicemail) but\nit's a big issue for instant messaging, which is inherently\nasynchronous. Jonathan Rosenberg\nargues\nthat mobile devices are basically always connected.  I'm not sure\nthat this is really true, but if you want to extend to systems\nwhich have e-mail style identifiers, then those may be on desktop\nnot mobile devices, so this is a drawback.\nThis isn't an issue for the directory service design: once\na user has registered with the directory service then anyone\ncan do a lookup whether you are offline or not.\nOne partial mitigation for this might be for the operator of\neach app to record (cache) phone number validations as they\nhappen, so that they gradually learn some of the mappings\nand can resolve them immediately. For instance, once\nAlice (on service A) has discovered that Bob is on service B,\nif Charlie (also on service A) can learn this information\nfrom A without a new verification stage.\nThis has the advantage that it's \"soft state\" in that things work without it,\nbut the disadvantage that some things work and some don't.\nIt (mostly) requires changing the operating system #\nBecause the SPIN design involves every client doing its own phone\nnumber verification, people are going to get a lot of SMS messages\nrequiring them to verify, which is annoying. SPIN expects to\naddress this by having the device operating system absorb the\nmessages and respond for you so the user doesn't see them.\nThis isn't necessarily a bad idea, but it's kind of ugly and\nmeans that people with older operating systems will have a bad\nexperience.\nAgain, this isn't an issue with the directory service version\nbecause apps can just register themselves. That version does\nwork better if the operating system helps out with SMS verification,\nbut even in the worst case the user is just bothered once for\neach app they use, not for each person who wants to call them.\nAttack Resistance #\nAs noted above, SMS routing in the PSTN isn't really that\nsecure, and so you have to worry about misissuance. One way\nto mitigate this is to have the results of verification\npublished in a transparency log. This allows everyone to see\nwhich credentials have been assigned to each number and\npotentially detect misissuance. This works fine in a directory\nservice type system but in a system where each user does their\nown verification, you might run into a scenario where an\nattacker hijacked just the connection between Alice and Bob\nbut not between Charlie and Bob. This would need some fancier\nmechanisms to detect, though we could probably design\nsomething.\nPrivacy #\nAs noted above, the privacy situation is largely better without\na centralized server, but there's still an issue around probing\nfor individual user information. I.e., Alice wants to know\nwhich app(s) Bob has and so sends an SMS and looks at the results.\nOne way to address this is for Bob to have some logic that runs\non the device that determines whether to answer the query—perhaps\ndepending on whether Alice's number is in the contact list—though\nit's not clear how easy that is to configure.[7]\nMultiple Apps Per User #\nMultiple apps are a pretty straightforward extension to either of these\nsystems. In both cases, you can basically think of the system as\npublishing a \"record\" attached to the phone number. I've implicitly\nassumed that the record would contain a single app, but there's no\ntechnical reason why they can't contain a list of apps (this is slightly\nmore complicated in the directory service version for cryptographic\nreasons, but not really that hard).\nThe situation for the initiator is somewhat more complicated: I'm\nusing app A and I want to call someone and learn that they\nhave apps B and C. What now? Presumably each app is going\nto have a priority list of apps it would prefer to interoperate\nwith (favoring itself!) and will just pick the top one. But this\ncan lead to some obvious problems, such as: will you get the same\napp in each direction? What happens if someone installs a new\napp that is more preferred? These aren't strictly discovery problems\nbut are definitely ergonomics issues that apps will need to work out\nsomehow.\nFinal Thoughts #\nObviously this is a difficult problem without a single great solution.\nI do think it's possible to come up with something reasonably good here, especially\nif we're willing to make some technical compromises. That's a\nlot more likely if there really will be a requirement to interoperate;\nwhile there are real technical problems, many of the problems\nare around incentives (e.g., why should I run a server so some people\ncan talk to my users?) and regulation provides those incentives.\nThis problem would be vastly easier\nif the addresses people were using had been structured from the very beginning: as an\nexample, e-mail addresses already consist of a user portion and a domain\nportion, and so it's easy to know where to route any given message.\nBut because instant messaging addresses are largely opaque, you're\nstuck with clumsier solutions. On the other hand, most e-mail addresses\naren't portable—you can't take example@gmail.com over to Hotmail—so\nif you ever wanted that you'd be back in the soup. To the best of my knowledge\nthere's no real way to have address portability without some kind of\nrouting database, either an explicit one like the DNS or my directory service,\nor an implicit one like the PSTN fabric that powers SMS verification.\n\n\n\n\nYou can now buy 128 GB flash\ndrives, so this gives us 12 bytes per record. ↩︎\n\n\nNote that it does not demonstrate that this device is\nassociated with that number. For instance, you could\nhave two devices, one of which is associated with that\nnumber and one of which you are installing the device on. ↩︎\n\n\nYes, it's possible to design a system that doesn't\nrequire full SMS access, but that's not how these\nAPIs work. ↩︎\n\nSee here for why I am using 555 numbers. ↩︎\n\n\nIn a real system, we'd probably want to prevent malicious\napps on Alice's phone from registering for another app,\nin what's called an \"identity misbinding\" attack, but\nI'm ignoring that here. ↩︎\n\n\nUpdate 2022-08-04:\nYou could also use secret sharing, but encryption has\nthe advantage that if the record you want to store is\nlarge then the total size is smaller. ↩︎\n\n\nIt might be possible to replicate this functionality in the\ndirectory service model. Naively, Bob could just upload the\nalgorithm for which numbers to answer for, but this has its\nown privacy problems because it leaks Bob's contact list to the service.\nThere may be some fancy cryptographic solution that addresses\nall these privacy problems at once, but I don't have it\nin my pocket. ↩︎\n\n\n\n\n    \n\n    \n      \n  \n\n\n\n\n          \n        ","length":27804,"excerpt":"New phone, who dis?","byline":"Posted by ekr on 04 Aug 2022","dir":null,"siteName":null,"lang":"en"},"finalizedMeta":{"title":"Discovery Mechanisms for Messaging and Calling Interoperability","description":"New phone, who dis?","author":false,"creator":"@ekr____","publisher":false,"date":"2022-08-23T17:33:53.223Z","topics":[]},"jsonLd":{"@type":false,"headline":false,"description":false,"image":[],"mainEntityOfPage":{"@type":false,"@id":false},"datePublished":false,"dateModified":false,"isAccessibleForFree":false,"isPartOf":{"@type":[],"name":false,"productID":false},"discussionUrl":false,"license":false,"author":{"@type":false,"name":false,"description":false,"sameAs":false,"image":{"@type":false,"url":false},"givenName":false,"familyName":false,"alternateName":false,"publishingPrinciples":false},"publisher":{"@type":false,"name":false,"description":false,"sameAs":false,"logo":{"@type":false,"url":false},"publishingPrinciples":false},"editor":{"@type":false,"name":false,"description":false,"sameAs":false,"image":{"@type":false,"url":false},"givenName":false,"familyName":false,"alternateName":false,"publishingPrinciples":false}},"twitterObj":false,"status":200,"metadata":{"author":false,"title":"Discovery Mechanisms for Messaging and Calling Interoperability","description":"","canonical":"https://educatedguesswork.org/posts/messaging-discovery/","keywords":[],"image":"/img/sim-card.jpg","firstParagraph":"New phone, who dis?\n        "},"dublinCore":{},"opengraph":{"title":"Discovery Mechanisms for Messaging and Calling Interoperability","description":"New phone, who dis?","url":false,"site_name":false,"locale":false,"type":"article","typeObject":{"published_time":false,"modified_time":false,"author":false,"publisher":false,"section":false,"tag":[]},"image":false},"twitter":{"site":false,"description":false,"card":"summary","creator":"@ekr____","title":false,"image":false},"archivedData":{"link":"https://web.archive.org/web/20220808000630/https://educatedguesswork.org/posts/messaging-discovery/","wayback":"https://web.archive.org/web/20220808000630/https://educatedguesswork.org/posts/messaging-discovery/"}}}